[{"id":0,"title":"图片来源于网络","content":"#\n\n\nlaysakura#\n\nAutomotive CTF 2024 世界決勝 - 体験記 & Writeup\n\n\n\n\nThomas Faschang#\n\nLinkedIn 帖子\n\n\n\n\nToyotaTimes#\n\nWhy Toyota Runs a Car-Hacking Event\n\n\n\n\n\n\nTOYOTA Otemachi#\n\nAutomotive Security workshop using RAMN boards held at SINCON 2021 conference.\n\n","routePath":"/case","lang":"","toc":[{"text":"laysakura","id":"laysakura","depth":2,"charIndex":3},{"text":"Thomas Faschang","id":"thomas-faschang","depth":2,"charIndex":60},{"text":"ToyotaTimes","id":"toyotatimes","depth":2,"charIndex":94},{"text":"TOYOTA Otemachi","id":"toyota-otemachi","depth":2,"charIndex":150}],"domain":"","frontmatter":{},"version":""},{"id":1,"title":"CTF 题解","content":"#\n\n本页面包含 RAMN 参与过的历届 CTF 题解。您可从 GitHub 仓库的 misc 文件夹下载历届 CTF\n固件及挑战题目。欢迎随时联系我们，以添加或移除您自己的题解。\n\n\nDEFCON Embedded Systems Village 2024#\n\n参赛者题解：\n\n * https://justinapplegate.me/2024/esvctf-playagame/\n\n\nDEFCON Car Hacking Village 2024#\n\n标志格式为 flag{xxxx}。在 CHV 现场的桌子上提供了十块 RAMN 板。明确指出每块 ECU 都配备了不同的诊断接口（USB、UDS、KWP2000\n或 XCP）。同时提醒，Flash 地址范围为0x08000000-0x08040000，RAM 地址范围为 0x20000000-0x20040000。\n\n本页面包含简单的简要说明。带有详细解决方案的 Jupyter Notebook 可在 misc 文件夹中获取。\n\n\n[A] Secret Menu#\n\n\n\n可以立即确定，具有 USB 诊断接口的正是 ECU A，因为它是唯一配备 USB 接口的设备。通过浏览各个屏幕，我们可以发现存在一个等待输入秘密代码的调试界面。\n\n\n\n我们可以将提供的固件文件加载到 Ghidra 中。由于这是一个带有调试符号的.elf 文件，因此很容易进行逆向工程。\n\n使用“窗口 > 已定义字符串”功能，查找“Awaiting secret code”字符串，并跟踪其引用，我们可以确定当 DEBUG_MODE_UNLOCKED\n变量被设置为 1 时，调试模式即被解锁。\n\n通过跟踪 WRITE 引用，我们可以发现，如果 verify_secret_input 函数返回 1，则该变量会被设置为 1。\n\n\n\n通过分析 verify_secret_input 函数，我们可以确定哪些 RAMN 输入会触发调试模式的解锁。\n\n\n\n借助 cansniffer（或 RAMN 的 CAN RX MONITOR 界面），我们可以通过实际操作控制装置并观察相应变化的 CAN ID\n及其有效载荷，来识别每个控制对应的 CAN ID。随后，我们可以按照 verify_secret_input 函数所指定的方式设置 RAMN 的输入。\n\n\n\n调试界面现在显示，通过输入“#”可以访问一个新的 USB 命令接口，并且当前用户名的 CRC 校验值不正确。\n\n\n\n通过在 USB 接口中输入“#”后跟“help”，我们发现存在一个名为“username”的命令，该命令接受一个参数。\n\n通过将“default_user”输入到 https://crccalc.com/ 并查找生成 C862ED4F 的算法，我们确定所使用的 CRC 算法为\nCRC-32/ISO-HDLC。只需输入一个 CRC 值为 0xDA5D344D 的用户名，即可获取到 flag，这一 CRC 值可使用 CRC RevEng\n或 crchack 等工具计算得出。\n\n\n\n\n\n\n[B] Sit Next To Me#\n\n\n\n通过使用诸如 caringcaribou 之类的扫描工具，可以确认 ECU B 具有一个活跃的 XCP 接口（位于 CAN ID 0x552/0x553）：\n\n\n\n\n\n进一步使用 caringcaribou 进行探测后发现，CAL/PAG 资源是可用的，但需要身份验证。\n\n\n\n\n\n命令 caringcaribou xcp commands 0x552 0x553\n可用于识别当前可用的命令包括：GET_STATUS、SYNCH、GET_SEED、UNLOCK、SET_MTA、UPLOAD 和 DOWNLOAD。\n\n从提示信息以及目前收集到的数据可以推断，如果使用 DOWNLOAD 命令（0xF0），标志将通过 CAN ID 0x777 传输——但该命令需要身份验证（通过\nGET_SEED 和 UNLOCK）。\n\n我们可以利用 SET_MTA 和 UPLOAD 命令从 ECU 中转储内存。通过 caringcaribou xcp dump 0x552 0x553\n0x08000000 256 可以观察到，闪存范围无法访问，但 RAM 范围是可以访问的（例如，通过 caringcaribou xcp dump 0x552\n0x553 0x20000000 256 ）。需要注意的是，某些版本的 caringcaribou 可能存在漏洞，导致该命令无法成功执行。\n\nCaringcaribou 不支持 XCP 身份验证，因此后续步骤应直接按照 XCP 规范发送 CAN 报文来完成。种子可以通过以下命令请求：cansend\ncan0 552#f80001。\n\n\n\n这表明种子为6字节。 我们可以使用 dump 命令转储完整的 RAM 地址范围（0x20000000-0x20040000），并在其中搜索种子。\nCaringcaribou 不应未经修改直接使用，因为它会在每次执行命令时重置 XCP 连接，从而导致种子被重置。种子可能位于多个位置（例如，在 TRNG\n缓冲区中），因此应检查所有可能的位置。\n\n要通过 XCP 转储 RAM，我们可以使用 SET_MTA（0xF6）和 UPLOAD（0xF5）。例如，要从 0x20000000 转储 6\n个字节，我们使用：\n\n\n\n每次调用 UPLOAD 都会转储下一个地址（例如，对于上述示例，地址为 0x20000006）。通过对不同种子的整个 RAM 进行转储，我们可以确定种子始终位于\n0x20033f50 附近。此外还可以观察到，在其紧邻位置存在另一个 6\n字节的变量，该变量会随之变化。这很可能就是我们期望找到的种子答案。由于没有身份验证尝试次数限制，我们可以自由地尝试不同的排列组合。\n\n\n\n可以通过请求种子、转储 RAM 以读取预期答案、利用该答案解锁 ECU，然后使用 DOWNLOAD 命令让 ECU 传输标志来读取标志。\n\n\n\n\n[C] Come again?#\n\n\n\n挑战提示表明 ECU C 使用了 KWP2000 协议。我们可以使用 caringcaribou 工具来查找使用 UDS 和 KWP2000 协议的 ECU：\n\n\n\n\n\n根据 RAMN 的文档，我们可以确定 7e3 对应于 ECU D 的 UDS 接口，而 7e6 对应于 ECU C 的 KWP2000 接口（这一点可以通过\nReadDataByIdentifier 读取信息来确认）。在本挑战中，我们重点关注 7e6/7ee（即 ECU C 的 KWP2000 接口）。\n\n通过 caringcaribou 的服务发现功能，我们可以看到有许多可用的服务：\n\n\n\n\n\n服务 0x1a 的存在表明该接口是 KWP2000 协议，而非 UDS 协议。服务 0x29 并不对应于认证（AUTHENTICATION），因为这不是一个\nUDS 接口（从技术上讲，我们也不应该用 caringcaribou 来处理它）。\n\n尝试使用 ReadDataByIdentifier 读取所有 DID 时发现，DID 0x0000\n返回“安全访问被拒绝”。由此可以推断，本挑战的目标就是绕过这一安全访问限制。\n\n\n\n尝试使用默认会话请求种子时，将返回错误代码 0x80，对于 KWP2000 而言，这意味着当前会话不支持该服务。我们可以通过暴力破解所有会话来观察到，会话\n0x92（KWP2000\n扩展会话）是可用的。然而，在请求安全访问种子时，我们可能会遇到其他错误：要么是“无需时间延迟”（意味着我们必须等待暴力破解保护计时器到期），要么是“子功能不支持\n”。\n\n通过暴力破解所有安全等级，我们观察到安全等级 0x05 存在，并返回一个 16 位的种子：\n\n\n\n我们可以请求任意数量的种子，这些种子似乎是随机的。由于种子长度仅为 16 位，因此暴力破解似乎是最简单的方法。然而，ECU 会限制尝试次数：\n\n\n\n幸运的是，通过进一步探索可以发现，每当调用“诊断会话控制”服务以请求新会话时，ECU 都会重置尝试次数，这使我们能够随意尝试任意多次，而无需重启 ECU。\n\n因此，我们可以使用以下脚本，该脚本会反复请求新的种子，并尝试答案“1234”（一旦最终成功解锁 ECU，应立即停止脚本）。\n\n\n\n（请注意，此脚本速度非常慢但功能正常；我们原本期望参赛者编写一个更高效的脚本。）几分钟后，ECU 应该会被解锁，并且可以通过\nReadDataByIdentifier 服务，使用 DID 0x0000 读取标志位：\n\n\n\n\n\n\n[D] Light the way#\n\n\n\n通过之前的挑战，我们了解到 ECU D 在 7e3/7eb 处存在 UDS 接口。我们可以使用 caringcaribou 来扫描可用的服务：\n\n\n\n\n\n我们可以使用 dump_dids 模块来读取所有 DID：\n\n\n\n\n\n我们可以观察到，WriteDataByIdentifier 处于激活状态，并且唯一可写入的 DID 是 0x0207，其值似乎指向 RAM\n中的一个地址。我们尝试对该值进行轻微修改，结果发现 RAMN 上的 LED 随之发生变化。由于 DID 0x206 的描述为“LED\n控制指针”，并且提示和标题均表明与 LED 有关，因此我们可以推断，该 DID 用于指定内存中显示在 LED\n上的地址。此外，我们还可以观察到，该值也可以指向闪存地址。\n\n\n\n因此，我们可以预期能够将标志位的值逐字节地显示在 RAMN 的 LED 上。然而，我们目前仍不清楚标志位的具体地址。\n\n我们可以观察到，REQUEST_UPLOAD 和 TRANSFER_DATA 处于激活状态，这使我们能够转储固件（参见 请求上传\n(0x35))。挑战提示中已明确指出固件的大小为 0x0c548 字节。\n\n转储固件后，我们可以在 Ghidra 中打开它（使用与 ECUA_REDACTED.elf 相同的设置）。通过搜索“flag”，我们可以找到字符串 Loaded\nFLAG from private flash at address %p ，其中 %p 被替换为“0x0803e000”。因此，我们可以得出结论：标志位于\n0x0803e000 处，我们只需利用按标识符写入数据服务逐字节转储即可（文档中可立即识别出哪个 LED 对应哪个位，详见 正文 )。\n\n\n\n标志：flag{BEST_LIGHT_SHOW_IN_VEGAS}\n\n\nAutomotive CTF Japan 2024#\n\n参赛者题解：\n\n * https://laysakura.github.io/2024/09/14/automotive-ctf-2024-japan-final/ (日文)\n * https://qiita.com/kusano_k/items/140d08521b9667cd6ab9 (日文)\n * https://blog.hamayanhamayan.com/entry/2024/09/14/112907 (日文)\n * https://emeth.jp/diary/2024/09/automotive-ctf-japan-writeup/ (日文)\n\n\nBlock Harbor VicOne Automotive CTF 2024#\n\nFlag 格式为 bh{xxxx}。六支队伍每队均获得两套带有 CTF 固件的 RAMN 设备，此外还有一套配备标准固件的参考 RAMN\n设备供参赛者共享使用。题目标题中括号内的字母表示 flag 所在的 ECU。\n\n\n[FILE] SWD 1 （6 次解出）#\n\n预计难度：简单。标签：取证。\n\n\n\n提供的文件是一个逻辑分析仪捕获数据（来自 Scanaquad SQ200）。\n\n\n\n它可以在诸如 PulseView 之类的工具中加载并进行解码（应在导入选项中输入正确的 CSV 格式）。加载完成后，信号即可通过 SWD\n协议分析器进行解码（正如标题所提示的那样）。\n\n\n\n解码后的数据可以导出为文本文件。只需在小端序（7B6862）中搜索字符串“bh{”（十六进制为 62 68 7B），即可直接显示出明文形式的标志。\n\n\n\n标志：bh{an4lyst_s3ssION_Ro4d}。\n\n\n[FILE] SWD 2 （3 次解出）#\n\n预期难度：非常困难。标签：取证、逆向。\n\n\n\n本挑战延续 SWD 1。第一步是从逻辑分析仪捕获中提取完整的固件。这可以通过查找“W AP4”命令（指示地址）以及“W\nAPc”命令（指示要写入该地址的数据）来实现。选手需编写脚本，以重建固件的二进制文件（代码 FLASH 起始于 0x08000000；数据以 32\n位小端字节序分块写入）。\n\n\n\n固件文件重构完成后，可在 Ghidra 中加载。为便于分析，需根据提示设置内存映射。\n\n\n\n搜索 0x12345678 可发现发送标志的函数。由此可知，第二个标志（未混淆时）位于 0x20030020。\n\n\n\n仅存在另一处对 0x20030020 的引用——由此可推断，该函数正是用于加载其中标志的函数。\n\n\n\n这揭示了用于对标志进行去混淆处理的函数。\n\n\n\n其核心部分最初是用 C 语言编写的：\n\n\n\n剩下的唯一一步是确定混淆标志位于何处。根据之前的步骤可知，0x20037750 是混淆标志在 RAM 中的位置。挑战提示中提供了 Reset_Handler()\n函数的地址：\n\n\n\n可以推断，RAM 的默认值是从 FLASH 的 0x0800ab94 加载到 RAM 的 0x20037750（混淆标志恰好位于.data\n节的第一个地址，紧挨着 SWD1 标志之前）：\n\n\n\n以上步骤可用于对标志进行去混淆处理，得到 bh{pr0duct_AMB1tion}。\n\n\n[D] Follow Me （6 次解出）#\n\n预期难度：简单。标签：硬件。\n\n\n\nLED 由 ECU D 的 SPI 接口控制，且 SPI 信号在车身 PCB 上有明确标记的探针。使用逻辑分析仪观察 SPI 信号可以发现，ECU D\n正常情况下每 10 毫秒更新一次 LED 的状态。\n\n\n\n当发动机钥匙处于 IGN 位置时，可以看到在传输 LED 状态之前有一段突发的数据——这是以明文 ASCII 格式的标志位。\n\n\n\n标志：bh{TREE_FORMS_WIND}。\n\n\n[D] I2C （4 次解出）#\n\n预期难度：中等。标签：硬件。\n\n\n\n本挑战要求玩家阅读 STM32L5x2 数据手册 ,并确定 I2C2 端口的可能引脚。\n\nSDA 可能位于 PF0、PB11 或 PB14；SCL 可能位于 PF1、PB10 或 PB13。PB13 已被“Follow Me”挑战中的 SPI\n接口占用，而 PF0/PF1 在 RAMN 使用的 48 引脚封装上不可用。因此，板上可供尝试的配置仅剩下 SDA:PB11/SCL:PB10 和\nSDA:PB14/SCL:PB10（其中前者为正确配置）。可以使用任何 I2C 工具进行尝试，例如配置为 I2C 模式的 FT2232H 板。\n\n\n\n这将触发标志的传输。\n\n\n\n标志：bh{INFAMOUS_REMAKE}。\n\n\n[D] Forgotten Field （4 次解出）#\n\n预计难度：中/难。标签：CAN，硬件。\n\n\n\n挑战提示表明，存在一个“被遗忘的字段”，大多数 CAN 工具（如 candump）并未显示该字段。快速查阅维基百科上的 CAN 页面后发现，这很可能是指 CRC\n字段（提示中的“check some”进一步暗示了这一点）。\n\n因此，解决方案是查看 ID 为 0x607 的 CAN 帧的 CRC 字段。最简单的方法是使用逻辑分析仪观察 CAN 帧（如果关闭其他 ECU，并直接观察\nECU D 的 TX 引脚而非 CANH/CANL，则更为方便）。另一种解决方法是根据 candump 的数据重建 CAN 帧（注意，在计算 CAN 协议的\nCRC15 之前，必须重现位填充过程）。\n\n\n\nflag 即为 CAN 帧的 CRC 值（每帧一个字节）：bh{LAGGING_BEHIND}。\n\n\n\n\n[C] CVE-2017-14937（4 次解出）#\n\n预计难度：简单。标签：CAN，硬件。\n\n\n\n正如标题所示，本挑战是对 CVE-2017-14937 的简单复现。CVE-2017-14937 详细描述了如何利用 ECU 的安全访问服务来解锁 ECU。一旦\nECU 被解锁，玩家只需使用 WriteDataByIdentifier 服务，在 DID 0x1111 处写入任意数据，即可通过\nReadDataByIdentifier 服务，利用 DID 0x0000 读取标志。\n\n详细的参赛者报告可在此处查看。\n\nFlag: bh{SUP3RS0NIc}。\n\n\n[B] Rush Hour （3 次解出）#\n\n预计难度：中等。标签：CAN，硬件。\n\n\n\n本挑战以附件形式提供了 ECU B 的固件（其中包含已屏蔽的标志）。该固件采用 ELF 格式，并带有调试符号，便于进行逆向工程。（另一个以 ELF\n格式提供固件的原因是，在仅提供.HEX 文件的挑战中，这样可以更轻松地确定正确的 Ghidra 设置。）\n\n通过搜索标志位可以发现，它能够使用 ReadDataByIdentifier UDS 服务，并以 DID 0x0001（由于 ARM32 的字节序问题，在\nGhidra 中显示为 0x100）进行读取。\n\n\n\n然而，正如挑战提示中所说明的，存在一个全局变量 UDS_ENABLE，当其值为 0 时，会阻止玩家使用 UDS。\n\n\n\n玩家应注意，该变量的默认值为 1（表示 UDS 可用），但在启动过程中被设置为 0。\n\n\n\n由于该值是在 CAN 外设被激活之后才被设置为 0，因此存在一个 10 毫秒的窗口期，在此期间可以使用 UDS。因此，解决方案是在 ECU 启动时持续发送请求。\n\n\n\n标志：bh{an4lyst_s3ssION_Ro4d}。\n\n\n[A] slcan’t （2 次解出）#\n\n预期难度：中等。标签：CAN、USB。\n\n\n\nramn_utils.c 中的 ascii_hashmap 表（其代码可在 github 上获取）用于将 ASCII\n十六进制字符串转换为字节。由于十六进制字符仅由“0 到 9”、“A 到 F”以及“a 到 f”组成，因此该表大部分区域均填充了 0x00。\n\n\n\n挑战提示表明，flag 位于该表中。通过阅读源代码可知，在使用 slcan 接口请求发送 CAN 消息时，slcan 协议的‘t’命令会调用\nASCIItoUint8 函数。\n\n\n\n发送 SLCAN 命令的格式为 t<id><dlc><data>。一种从表中转储单个字节的简单方法是执行 SLCAN 命令 t00210 <index>,以强制\nECU A 通过 CAN ID 0x002 发送位于<index>处的字节。通过重复执行该命令并同时观察 CAN 总线（使用外部 CAN\n适配器），我们可以转储整个表格——其中就包含该标志位。\n\n\n\n\n\n标志：bh{B4RK_B0RK_bOrK}。\n\n\n[C] DID not done （2 次解出）#\n\n预计难度：中/难。标签：UDS。\n\n\n\n挑战提示给出了标志的地址和大小。扫描 ECU C 的 UDS 服务发现，DynamicallyDefineDataIdentifier\n服务处于激活状态。因此，可以利用该服务在 0x0803e000 处定义一个动态 DID（根据 UDS 标准，该 DID 应位于 0xF300-0xF3FF\n范围内），大小为 26。随后，通过使用 ReadDataByIdentifier 读取该 DID，即可获取标志。\n\n\n\nFlag: bh{TAKE_THE_LONG_WAY_HOME}。\n\n参赛者 报告请见此处 。\n\n\n[A/C] Ramen Clicker （1 次解出）#\n\n预计难度：中等/困难。标签：CAN，硬件。\n\n\n\n屏幕上显示了一个“拉面点击器”游戏，每次按下 SHIFT 操纵杆的中心按钮时，计数器就会加一。提示表明，当计数器超过 0x9000 时，即可显示 flag。\n\n\n\n通过观察 CAN 总线，可以发现 ECU A 与 ECU C 之间不存在任何身份验证机制，因此伪造操纵杆状态轻而易举。利用 cansniffer\n工具，我们可以观察到 045#0106 对应“操纵杆按下”，而 045#0101 对应“操纵杆松开”（第一个字节表示档位状态，可忽略不计）。\n\n然而，尝试伪造这些消息将触发以下画面：\n\n\n\n反作弊系统并不会进行惩罚，游戏无需断电重启即可重新开始。由于未提供固件，目前尚不清楚究竟是什么触发了反作弊系统。不过，由于缺乏适当的身份验证机制，我们可以确定，\n只要伪装不被轻易识破，就应当有可能冒充 ECU C。\n\n第一步是将 ECU C（通常负责传输操纵杆消息）从 CAN 总线上移除，例如可以通过以下方式实现：\n\n * 利用 ECU C 的扩展接口，将复位引脚（21）与地线引脚（4）短接（为此目的已提供了跳线）。\n * 或通过 USB 串行接口关闭 ECU C 的电源。 %%\n\n此后，玩家只需发送045#0106和045#0101即可增加点击次数。\n\n注意：当 ECU A 超过 500 毫秒未收到 CAN ID 为 045 的消息时，或当 ECU A 接收到 ID 为 001 的消息时（即 ECU C\n在自身接收到 ID 为 045 的消息后，会发送 ID 为 001 的消息以警告 ECU\nA，从而得知有人正在作弊），反作弊系统将被触发。系统并未对消息频率进行检查。玩家无需完全了解这些具体条件，只需在正常流量与被篡改流量之间尝试实现相对平滑的过渡即\n可。\n\n\n\n另一种解决方案是物理上按下该按钮 0x9000 次。\n\nFlag: bh{N1NN1KUM4SHIMA5HI}.\n\n\n[D] Security Access 1 （1 次解出）#\n\n预计难度：非常困难。标签：逆向、UDS、硬件。\n\n\n\n所附文件为一个.hex 文件，不含调试符号，因此逆向工程难度稍大。这种.hex 文件在“Security Access 1”和“Security Access\n2”挑战中较为常见。使用 Ghidra 进行初步分析（以 ARM v8 LE 模式加载）后发现，正如标题所示，在完成安全访问认证后（分别针对级别 0x01 和\n0x03），可通过 ReadDataByIdentifier（DID 0x0001 和 DID 0x0002）读取标志位。\n\n参考以下内容可引导我们找到安全访问算法。\n\n\n\n“安全访问 1”的安全访问检查由 FUN_0900be24 执行，通过 ChatGPT 等 AI\n工具可识别其为“memcmp”。由此可以推断，08002310h 处存储的是预期的 16 字节（静态）密码的地址。\n\n\n\n08002310h 包含 0BF974C0h，但该地址在固件文件中无法找到。\n\n根据参考手册中的地址映射，我们可以观察到 0BF974C0h 位于系统内存引导加载程序区域（位于 ROM 中）。诀窍在于识别出该值位于系统内存中，因此对所有\nSTM32L552 微控制器（至少是同一批次的）都是通用的，从而可以从另一台 ECU 中读取。因此，密码可以被读取：\n\n * 通过使用 ECU C 的 ReadMemoryByAddress UDS 服务（与 ECU D 不同，该服务并未被禁用）。\n * 或者，通过使用多种内存转储方法之一（UDS、FDCAN 引导加载程序、JTAG 等），从已解锁且固件为标准版本的 RAMN 中获取（该 RAMN\n   已提供给参与者使用）。\n\n借助 ECU C 的 UDS：\n\n\n\n\n\n在参考 RAMN 的 ECU D 上启用 JTAG：\n\n\n\n通过发送该密码并读取 DID 0x0001，即可获取标志。\n\n\n\n\n\n标志：bh{an4lyst_s3ssION_Ro4d}。\n\n\n[D] Security Access 2 （1 次解出）#\n\n预计难度：非常困难。标签：逆向、UDS。\n\n\n\n按照与“安全访问 1”相同的步骤，我们可以识别出用于检查密码的函数。\n\n\n\n该函数将提供的密码与四个 32 位值进行比较，其依据是一个函数，该函数以字符串“HAPPY HAPPY HAPPY HAPPY”、“HAPPY HAPPY\nHAPPY”、“HAPPY HAPPY”和“HAPPY”（及其相应长度）作为参数。\n\n参考相关资料，并借助 ChatGPT 的帮助，我们可以确定：\n\n * FUN_080013a8 函数从 080013b8h 处读取数据（该地址的值为 20032A14h）。\n * 20032A14h 由 FUN_0800139c 函数初始化，参数为 20032820h。\n * 20032820h 则从 08000c64h 加载，该地址的值为 40023000h。\n\n因此，密码是以 32 位块的形式从 40023000h 处读取的。再次查阅参考手册 ,我们可以确认该地址对应于 CRC\n引擎外设的一个特殊功能寄存器。尽管我们可以通过参考文献逆向工程该引擎的参数（这些参数在 FUN_08003580\n中被初始化），但由于没有尝试次数限制，我们也可以简单地尝试所有常见的 CRC32 算法（采用不同的字节序）。\n\n我们可以使用 https://crccalc.com/ 并采用默认的 STM32 CRC 引擎算法（CRC-32/MPEG-2），这将为我们提供\n0x14b311c9、0x6442CA33、0xC25DE077 和 0x6DA5F0C1，它们对应正确的密码。\n\n\n\n\n\nFlag: bh{Thanks_P3riPH3Rals!}。","routePath":"/docs/ctf_writeups","lang":"","toc":[{"text":"DEFCON Embedded Systems Village 2024","id":"defcon-embedded-systems-village-2024","depth":2,"charIndex":92},{"text":"DEFCON Car Hacking Village 2024","id":"defcon-car-hacking-village-2024","depth":2,"charIndex":194},{"text":"[A] Secret Menu","id":"a-secret-menu","depth":3,"charIndex":446},{"text":"[B] Sit Next To Me","id":"b-sit-next-to-me","depth":3,"charIndex":1292},{"text":"[C] Come again?","id":"c-come-again","depth":3,"charIndex":2518},{"text":"[D] Light the way","id":"d-light-the-way","depth":3,"charIndex":3594},{"text":"Automotive CTF Japan 2024","id":"automotive-ctf-japan-2024","depth":2,"charIndex":4383},{"text":"Block Harbor VicOne Automotive CTF 2024","id":"block-harbor-vicone-automotive-ctf-2024","depth":2,"charIndex":4696},{"text":"[FILE] SWD 1 （6 次解出）","id":"file-swd-1-6-次解出","depth":3,"charIndex":4848},{"text":"[FILE] SWD 2 （3 次解出）","id":"file-swd-2-3-次解出","depth":3,"charIndex":5134},{"text":"[D] Follow Me （6 次解出）","id":"d-follow-me-6-次解出","depth":3,"charIndex":5765},{"text":"[D] I2C （4 次解出）","id":"d-i2c-4-次解出","depth":3,"charIndex":6004},{"text":"[D] Forgotten Field （4 次解出）","id":"d-forgotten-field-4-次解出","depth":3,"charIndex":6351},{"text":"[C] CVE-2017-14937（4 次解出）","id":"c-cve-2017-149374-次解出","depth":3,"charIndex":6751},{"text":"[B] Rush Hour （3 次解出）","id":"b-rush-hour-3-次解出","depth":3,"charIndex":7034},{"text":"[A] slcan’t （2 次解出）","id":"a-slcant-2-次解出","depth":3,"charIndex":7534},{"text":"[C] DID not done （2 次解出）","id":"c-did-not-done-2-次解出","depth":3,"charIndex":8010},{"text":"[A/C] Ramen Clicker （1 次解出）","id":"ac-ramen-clicker-1-次解出","depth":3,"charIndex":8313},{"text":"[D] Security Access 1 （1 次解出）","id":"d-security-access-1-1-次解出","depth":3,"charIndex":9167},{"text":"[D] Security Access 2 （1 次解出）","id":"d-security-access-2-1-次解出","depth":3,"charIndex":10036}],"domain":"","frontmatter":{},"version":""},{"id":2,"title":"固件架构","content":"#\n\nECU A、B、C 和 D 共享一种通用架构，但 ECU A 还启用了 USB 功能。在本页中，我们将详细介绍每个 ECU 的固件架构，首先从较为简单的 ECU\nB、C 和 D 开始。\n\n\nECU B、C 和 D#\n\nECU B、C 和 D 的固件包含六个任务：\n\n * CAN 接收任务，通过由 CAN-FD 外设中断服务例程 (ISR) 填充的 流缓冲区接收并处理 CAN 消息。\n * 诊断 RX 任务，通过由 CAN 接收任务填充的 流缓冲区接收并处理完整的（重构的）诊断消息。\n * 主周期任务，以指定的时间间隔定期执行（通常为 10ms）。该任务负责更新固件中的各个模块。周期性的 CAN 消息传输即由该任务请求。\n * Diag TX 任务，负责对诊断应答进行分片并发送，同时应用指定的流量控制设置。\n * CAN 发送任务，负责发送通过 流缓冲区请求的 CAN 消息。任何需要通过 CAN 进行通信的任务均可请求发送消息。\n * 错误处理任务，在需要处理和报告错误时被唤醒。\n\nECU B、C 和 D 固件的架构\n\n\nECU A#\n\nECU A 的固件与 ECU B、C 和 D 完全相同，但额外增加了两项任务：\n\n * USB 接收任务，用于接收 USB 命令并进行处理；\n * USB 发送任务，该任务通过 USB 发送请求的数据（同样，通过 流缓冲区 ）。\n\n对于 ECU A，诊断命令也可以通过 USB 而非 CAN 发送。\n\nECU A 固件的架构\n\n\n附加任务#\n\n在最新版本中，新增了一些任务，以方便用户轻松实现自定义任务。ECU A 可（可选地）使用这些任务来实现 gs_usb（candlelight）设备。","routePath":"/docs/firmware/architecture","lang":"","toc":[{"text":"ECU B、C 和 D","id":"ecu-bc-和-d","depth":2,"charIndex":97},{"text":"ECU A","id":"ecu-a","depth":2,"charIndex":469},{"text":"附加任务","id":"附加任务","depth":2,"charIndex":642}],"domain":"","frontmatter":{},"version":""},{"id":3,"title":"故障排除","content":"#\n\n本页面包含针对 RAMN 的常见故障排除方法，主要用于解决重新刷写和调试相关的问题。\n\n\nUSB 不稳定#\n\n如果您遇到 USB 问题，请尝试使用计算机上的其他 USB 端口。如果您通过 USB 集线器连接到 RAMN，请尝试直接将 RAMN 连接到计算机的 USB\n端口。\n\n\n预期选项字节#\n\n如果您在重新编程或调试 RAMN 时遇到困难，请使用STM32CubeProgrammer确保选项字节如下所示。\n\nECU A 与 ECU B/C/D 的配置有所不同。\n\nECU A 选项字节的正确配置 ：\n\n警告\n\n如果 ECU A 没有有效的固件（例如，因编程失败或中断），请勿更新其 Option Bytes。\n\n\n\nECU B/C/D 选项字节的正确配置 ：\n\n\n\n在使用 UDS 重新编程时，SWAP_BANK 和 DBANK 可能会被修改，但如果您遇到问题，请尝试恢复为默认设置。\n\n应将 RDP 选项字节设置为 0xAA,以确保未启用任何内存保护。\n\n重置选项字节后，您可能需要重新刷新固件。\n\n\n调试失败#\n\n如果您在使用 STM32CubeIDE 时遇到调试问题，但确定 JTAG 连接正确（例如，您可以使用STM32CubeProgrammer进行连接），请参阅\n调试 RAMN 固件。\n\n\n内存保护不一致#\n\n您可以使用 STM32 引导加载程序来启用内存读取和写入保护。同样，您也可以通过修改 RDP 选项字节来启用或禁用内存保护。\n\n如果您使用一种方法启用了保护，而用另一种方法将其移除（例如，您使用 STM32 引导加载程序启用了写保护，但后来又通过 JTAG\n移除了读保护），可能会出现问题。此时，微控制器可能看似已解锁，但实际上会拒绝固件重新编程或调试操作。\n\n如果您怀疑存在此问题（因为您过去曾使用过内存保护功能），请尝试使用 scripts/STBootloader 文件夹中的 canboot.py\n脚本运行“读取解锁”和“写入解锁”命令。 如果您的内存保护功能不一致，这些命令可能会返回错误，即使它们实际上已经成功执行。\n\n例如，对于 ECU B：\n\n\n\n\n通过 CAN 重新编程失败#\n\n如果通过 CAN 重新编程失败，可能是由于外部 CAN 适配器主动使用错误帧破坏通信流量所致（因为它未执行所需的波特率更改）。 在通过 CAN\n进行重新编程之前，请确保已关闭和/或拔下所有外部 CAN 适配器。\n\n\n驱动程序问题#\n\n意法半导体的 DfuSe 工具可用于通过 USB 对 ECU A 进行编程（当 ECU A 处于 DFU 模式时）。如果 Windows 通过 USB 将\nECU A 识别为“DFU 在 FS 模式下”，但设备信息显示为“未知”或“不可用”，则可能需要单独安装 STM32 DFU 驱动程序，这些驱动程序位于\nDFuse 的安装文件夹中，例如：\n\n","routePath":"/docs/firmware/common_issues","lang":"","toc":[{"text":"USB 不稳定","id":"usb-不稳定","depth":2,"charIndex":47},{"text":"预期选项字节","id":"预期选项字节","depth":2,"charIndex":142},{"text":"调试失败","id":"调试失败","depth":2,"charIndex":457},{"text":"内存保护不一致","id":"内存保护不一致","depth":2,"charIndex":557},{"text":"通过 CAN 重新编程失败","id":"通过-can-重新编程失败","depth":2,"charIndex":900},{"text":"驱动程序问题","id":"驱动程序问题","depth":2,"charIndex":1024}],"domain":"","frontmatter":{},"version":""},{"id":4,"title":"自定义指南","content":"#\n\n本页面包含有关如何自定义 RAMN\n的信息，以及实施某些项目（例如添加自定义引导加载程序、添加消息认证等）的指导。如果您想了解默认固件的功能，请查看快速入门指南或用户指南。\n\n摘要：\n\n * 所有 ECU 共享同一份源代码，仅其配置有所不同（即 #define TARGET_ECUA、#define TARGET_ECUB、#define\n   TARGET_ECUC 或 #define TARGET_ECUD）。\n * ramn_config.h 保存当前配置，ramn_customize.c 为常用函数提供钩子（例如，在接收到 CAN 消息时调用的函数）。\n * 当您向网络中添加新的 CAN 标识符时，需要更新 CAN 滤波器（包括标准和扩展滤波器），或者完全禁用滤波器。\n * CAN 外设已配置为 CAN-FD 模式，但仅使用经典 CAN 报文。您可以按照本页面的说明，将默认流量更改为 CAN-FD。\n * 您总共有 256kB 的 RAM，以及 256kB 或 512kB 的 Flash。如果内存不足，您可以减小 CAN 和 USB\n   缓冲区的大小，启用编译器优化，或者移除未使用的功能（在 ramn_config.h 中）。\n * 如果您使用 STM32 代码生成（即，如果您修改了 RAMNV1.ioc），请务必小心，不要让它覆盖您自己的代码。\n\nRAMN 是一个基于 HAL 和 FreeRTOS、采用 STM32CubeIDE 开发的常规 STM32 项目，适用于 STM32L552 和\nSTM32L562 微控制器。如果您需要本页面未提供的信息，可以随时通过互联网搜索通用的 STM32、HAL 和 FreeRTOS 相关资源。\n\n内容：\n\n * 修改 RAMN 固件\n * 刷写 RAMN 固件\n * 调试 RAMN 固件\n * 配置固件 (ramn_config.h)\n * 对 CAN 流量的简单修改（标识符、周期等）\n   * 升级至 CAN-FD\n * 对 CAN 流量的高级修改（有效载荷格式等）\n * 修改 CAN 滤波器或波特率\n * 修改 UDS 接口\n * 添加新内容\n   * 示例：每秒发送一条 CAN 报文\n   * 示例：在接收到特定 CAN 报文时执行某些操作\n   * 示例：基于 RAMN 控制做出决策\n * 自定义 ECU A 的显示\n * 在闪存中保存数据\n * 修改.ioc 文件\n   * 系统与外设设置\n   * FreeRTOS 设置\n   * 时钟设置\n   * 链接器设置\n   * 其他工具\n * 优化性能\n   * 编译器优化\n   * FreeRTOS 运行时统计信息\n * 理解 RAMN 的内存\n * 理解 RAMN 的安全特性\n   * 加固\n   * 内存保护\n   * 唯一硬件种子\n   * 额外的安全功能（TrustZone 等）\n * 探索 RAMN 的安全性\n   * 在 Ghidra 中分析 RAMN 固件\n   * 为 RAMN 编写 ARM Shellcode\n   * 使用 OpenOCD 进行调试\n * 典型项目指导\n   * 为CTF（或类似活动）准备 RAMN\n   * 实现安全的 CAN 总线（SecOC 等）\n   * 实现自定义引导程序（OTA、安全启动等）\n   * 实现漏洞\n   * 创建新扩展\n     * UART\n     * I2C\n     * SPI\n     * 模数转换器（ADC）\n     * 定时器（PWM）\n     * GPIO 与中断\n * FreeRTOS 通用提示\n * 局限性\n\n\n修改 RAMN 固件#\n\nRAMN 固件是使用 GCC 工具链构建的。虽然您可以自由选择任何喜欢的 IDE，但建议您从意法半导体的网站上安装最新版本的 STM32CubeIDE。\n\n您可以从 GitHub 仓库下载 RAMN 的源代码（点击“Code”然后“Download ZIP”）。源代码位于 firmware/RAMNV1 文件夹中。\n\n安装 STM32CubeIDE 后，打开它，创建或打开一个工作区，然后依次选择“File” > “Import…” > “Existing Projects\ninto Workspace”，接着选择 firmware/RAMNV1 所在的路径。点击“Next”，然后使用默认设置导入项目，点击“Finish”。\n\n这样，RAMN 项目就会出现在您的工作区中。所有 ECU 的源代码是相同的：\n\n * ECU A 固件是通过设置 TARGET_ECUA 标志位构建的。\n * ECU B 固件是通过设置 TARGET_ECUB 标志位构建的。\n * ECU C 固件是通过设置 TARGET_ECUC 标志位构建的。\n * ECU D 固件是使用 TARGET_ECUD 标志构建的。\n\n您可以通过修改 ramn_config.h,并将 #define TARGET_ECUA 替换为您所需的目标，来更改默认的目标 ECU。\n\n当您修改源代码时，这些修改将应用于所有 ECU。要编写特定于单个 ECU 的代码，请在其周围使用 #ifdef 和 endif\n预处理器指令。例如，要仅将修改应用于 ECU A：\n\n\n\n或者，你也可以维护四份独立的源代码副本，使每个 ECU 拥有自己独立的源代码，从而降低意外修改的风险。\n\n要为在 ramn_config.h 中定义的默认目标 ECU\n构建固件，请选择“项目”>“构建项目”，或按下锤子图标。固件二进制文件（.elf、.bin、.hex）以及调试信息文件（.list、.map）将位于\nRAMNV1/Debug 文件夹中。\n\n实用快捷键：\n\n * 使用 Control+H 搜索字符串（例如，本页面中提到的变量和函数）。\n * 使用 Control+Tab 在源文件和头文件之间切换。\n * 按住 Control 并单击函数名以跳转到其定义。\n * 按 Alt+Left 返回。\n * 要查找变量或函数的使用位置，右键单击该变量或函数，然后选择 “引用” > “项目”。\n\n警告\n\n在更改目标 ECU 时，STM32CubeIDE 可能需要一些时间来更新引用，并且在搜索项目时可能会遇到问题。为避免此问题，在更改目标 ECU 后，应选择\n“项目” > “C/C++索引” > “重建”。\n\n要一次性为所有 ECU 构建固件，可以使用 scripts/build 文件夹中的构建脚本（请确保首先关闭 STM32CubeIDE）。\n您可能需要在构建脚本（.bat 或.sh 文件）中更新 STM32CUBEIDEPATH，以匹配您的安装路径 。\n\nBUILD_Clean_Debug.bat 将为所有四个 ECU 构建固件，并将新的固件文件放置在 scripts/firmware 文件夹中。\n\n警告\n\n默认 RAMN 已优化，以使用大部分可用内存。如果您的应用程序需要大量内存，可能会遇到以下情况：\n\n * 构建项目时出现“ 区域 XX 溢出 YY 字节 ”错误。\n * calloc 返回 NULL。\n * FreeRTOS 任务中的堆栈溢出。\n\n您可以通过减小 USB 和 CAN 缓冲区的大小，轻松为您的应用程序释放内存。请阅读 理解 RAMN 的安全特性部分，以了解如何为您的应用程序释放更多内存。\n\n注意\n\n默认情况下，RAMN 已配置为支持内存保护。如果您的应用程序需要严格的内存保护（例如，您希望将 RAMN 用于“夺旗”比赛，参赛者不得转储内存），请阅读 理解\nRAMN 的安全特性部分。\n\n如果内存保护不是问题（例如，您将 RAMN 用作研究或教育平台），您可以将 STM32L552CETX_FLASH.ld 的内容替换为\nSTM32L552CETX_FLASH_INSECURE.ld （位于 RAMNV1 文件夹中）的内容，从而为您的应用程序释放更多内存。\n\n\n刷新 RAMN 固件#\n\n有许多接口可用于刷写新的固件。其中最快且最易用的是 STM32 嵌入式引导加载程序接口（可通过 USB 使用 DFU 对 ECU A 进行重新编程，也可通过\nECU A 经由 CAN-FD 对 ECU B/C/D 进行重新编程）。\n\n位于 scripts/STbootloader/windows 中的脚本 ProgramECU_A.bat 和 ProgramECU_BCD.bat\n可用于刷新位于 scripts/firmware 文件夹中的固件.hex 文件（ECUA.hex、ECUB.hex、ECUC.hex 和 ECUD.hex)。\n\n有关更多详细信息，请参阅刷写脚本。\n\n\n调试 RAMN 固件#\n\n要调试 RAMN ECU 的源代码，您需要购买一个外部 JTAG 调试器，并将其连接到您想要调试的 ECU。详细信息请参阅 JTAG\n硬件接口部分（STM32CubeIDE 也可以为 ECU 刷写程序，因此您无需使用STM32CubeProgrammer）。\n\n首先，请确保您已在 ramn_config.h 中定义了您想要调试的目标 ECU。将调试器连接到该 ECU，然后在 STM32CubeIDE\n中点击绿色的虫子图标（或选择“运行”>“调试”）。如果这是您首次运行调试器，可能会出现提示窗口，此时应保持默认设置。\n\n如果调试失败（或不可靠），请尝试删除 RAMNV1 Debug.cfg 和 RAMNV1\nDebug.launch,以强制创建一个新的调试配置。然后，选择“运行”>“调试配置…”，切换到“调试器”选项卡，并尝试不同的设置（可尝试不同的“调试探针”设置\n，同时测试 SWD 和 JTAG）。此外，请确保在主选项卡中的 C/C++应用程序指向当前配置的.elf 文件（通常为\nDebug/RAMNV1.elf）。您可使用“搜索项目…”按钮来定位正确的二进制文件。\n\n如果可能，建议启用 RTOS 内核感知功能（启用“RTOS\n代理”，驱动程序：“FreeRTOS”，端口：“ARM_CM33_NTZ”），以获取更多调试信息；但如果遇到调试问题，则应将其关闭。\n\nSTM32CubeIDE 在调试过程中会自动通过 JTAG 重新刷新连接的 ECU。然而，它无法刷新其他 ECU。如果您的修改会影响所有 ECU（例如更改\nCAN 波特率），则需要使用刷写脚本，以确保所有 ECU 都能应用您的修改。\n\n\n配置固件（ramn_config.h）#\n\n您可以通过编辑 Core/Inc 文件夹中的 ramn_config.h 来配置固件。\n\n如前所述，该文件用于定义在 STM32CubeIDE 中用于调试或构建固件的目标 ECU。\n\n请阅读 ramn_config.h 中的注释，并根据您的需求调整设置。关键配置选项包括：\n\n * ENABLE_USB_DEBUG：通过 USB 启用额外的调试输出（例如，人类可读的 CAN 错误）。\n * LED_TEST_DURATION_MS：设置为 0 以在启动时跳过 ECU D 的 LED 测试。\n * WATCHDOG_ENABLE：启用看门狗定时器，以便在主周期性任务崩溃时重置 RAMN。\n * AUTO_RECOVER_BUSOFF：如果 ECU 进入总线关闭模式，则重置 CAN/CAN-FD 外设。\n * HANG_ON_ERRORS：在某些非关键错误发生时强制进入无限循环（而不是忽略这些错误）。\n\n您可能还需要调整超时值，例如 ISOTP_TX_TIMEOUT_MS 或 UDS_SESSION_TIMEOUT_MS,以匹配实际条件或使 ECU\n更易于交互。例如，UDS_SESSION_TIMEOUT_MS 被设置为 5000,这会强制 ECU 在扩展诊断会话期间超过 5 秒未收到请求时恢复到 UDS\n默认会话。如果您增大此值，用户将更容易进行 UDS 实验，但这将不再代表真实 ECU 的行为（真实 ECU 需要定期发送“测试器存在”请求）。\n\n\nCAN 流量的简单修改（标识符、周期等）#\n\nRAMN 通常使用两种类型的 CAN 报文：“命令”和“控制”。命令报文由外部 ECU/计算机发送，用于请求 ECU 将其执行器设置为特定值（例如，CARLA\n可利用此方式请求 ECU C 加速）。控制报文则报告所应用控制的实际值（例如，ECU C 实际施加的油门位置）。\n\n例如，如果 CARLA 希望车辆施加 100%的油门值，它可以使用油门命令报文向 ECU C 发送请求。ECU C 可能会根据该报文决定施加\n100%的油门。然而，如果 ECU C 检测到当前车速超过某一阈值或制动踏板被踩下，它可以选择忽略该命令，转而施加\n0%的油门。这种方法可用于实现各种闭环控制算法（例如，实现 PID 和 bang-bang 控制器）。\n\n您可以修改 ramn_vehicle_specific.h 以更新 RAMN 的 CAN 流量的基本属性。例如，如果您希望使用 ID 0x25 而不是 0x24\n来表示制动消息，请将 CAN_SIM_CONTROL_BRAKE_CANID 从 0x24 更改为 0x25。\n\n\n升级到 CAN-FD#\n\n您可以通过修改 ramn_vehicle_specific.h 从 CAN 升级到 CAN-FD：\n\n * 将 CAN_MAX_PAYLOAD_SIZE_DEFAULT 更改为 64（以启用 64 字节的有效载荷）。\n * 将 CAN_SIM_FORMAT_DEFAULT 更改为 FDCAN_FD_CAN。\n * 将 CAN_SIM_BRS_DEFAULT 更改为 FDCAN_BRS_ON（如果您希望启用比特率切换）。\n\n警告\n\n更改 CAN_MAX_PAYLOAD_SIZE_DEFAULT 可能会在编译时导致 RAM 溢出错误。请阅读了解 RAMN\n的内存部分，以了解如何为您的应用程序释放更多内存。\n\n警告\n\n当您将默认流量更新为 CAN-FD 时，将失去与大多数 slcan 工具的兼容性。建议使用外部 CAN-FD 适配器。在 Linux 上，您可以使用\nscripts/vcand 中的脚本，从 RAMN 的 slcan 接口生成一个虚拟的 CAN-FD 接口。\n\n\nCAN 流量的高级修改（有效载荷格式等）#\n\nramn_dbc.c 是一个用于维护传入 CAN/CAN-FD 消息最新值数据库的模块。这确保了所有 ECU 都能访问所有的 RAMN\n控制，即使某个控制属于其他 ECU。例如，如果你想从 ECU A 获取 ECU C 操纵杆的状态，只需读取 RAMN_DBC_Handle.joystick\n的值即可。\n\n * 函数 RAMN_ACTUATORS_ApplyControls 位于 ramn_actuators.c 中，负责确定要设置到传出周期性\n   CAN/CAN-FD 消息中的有效载荷。\n * 函数 RAMN_DBC_FormatDefaultPeriodicMessage 位于 ramn_dbc.c 中，通过添加计数器和 CRC32\n   校验和来格式化消息。\n * 函数 RAMN_DBC_Send 实际用于发送 CAN 消息。\n * 函数 RAMN_DBC_ProcessCANMessage 在 RAMN_DBC 模块中解析并记录传入的 CAN 消息。\n\n如果希望某个 ECU 停止发送消息，只需注释掉对 RAMN_DBC_Send 的调用即可。有关自定义示例，请参阅实现安全的 CAN 总线（SecOC 等）。\n\n注意\n\nECU A 还使用 RAMN_DBC_ProcessUSBBuffer 将从 CARLA 接收到的 USB 数据转换为 CAN 消息。\n\n\n修改 CAN 滤波器或波特率#\n\n如果您希望在流量规范中添加新的 CAN 消息（而不仅仅是修改现有消息），则必须确保新 CAN 标识符未被过滤。您可以通过以下方式实现：\n\n * 在 ramn_config.h 中注释掉 USE_HARDWARE_CAN_FILTERS。这将禁用硬件滤波器，从而略微增加 CPU 负载。\n * 或者，您也可以在 ramn_canfd.c 中的 recvStdCANIDList 和 recvExtCANIDList\n   中分别添加您的新标识符，以分别处理标准和扩展标识符。\n\n如果您希望修改默认的波特率，应按照修改 .ioc 文件一节中的说明，在 RAMNV1.ioc 文件中修改 CAN/CAN-FD\n外设设置。如果您不熟悉位定时，可参考位定时一节。此外，您也可以通过修改 ramn_canfd.c 中的 FDCAN_Config,在初始化外设之前调用\nRAMN_FDCAN_UpdateBaudrate，并传入您所需的新的波特率，从而覆盖默认的标称波特率。\n\n注意\n\n如果您只是临时更改波特率，则无需修改固件，只需使用 UDS（ 与 UDS 交互）和 USB 命令（ 与 USB 交互）即可。\n\n\n修改 UDS 接口#\n\n如果您希望自定义 UDS 接口（无论是修改现有服务还是添加新服务），则需要更新 ramn_uds.c 文件。您应根据需要修改用于物理寻址的\nRAMN_UDS_ProcessDiagPayload 和/或用于功能寻址的 RAMN_UDS_ProcessDiagPayloadFunctional\n。请注意，根据标准规范，功能寻址仅适用于单帧消息。\n\n如果需要在发送响应后执行您的代码（例如，因为 ECU 将复位或更改波特率，需先进行响应），请在处理函数中发送一个肯定响应，并在\nRAMN_UDS_PerformPostAnswerActions 中执行实际操作。\n\n\n添加新内容#\n\nramn_customize.c 是一个模块，旨在更轻松地向 RAMN 添加自定义内容。如果您希望在不改变 RAMN\n默认行为的前提下对其进行扩展，应使用此模块。在 ramn_customize.c 中提供了多种函数，允许您在不同任务中添加自己的代码。例如：\n\n * RAMN_CUSTOM_Update 由 RAMN 的主周期性任务每 10 毫秒调用一次（默认设置）。它与处理其他周期性操作的任务相同，例如发送 CAN\n   消息、更新屏幕或 LED。\n * RAMN_CUSTOM_CustomTaskX 函数由未使用的任务调用，与主周期性任务并行执行。它们可用于在主周期性任务的同时并行执行某些操作。\n * RAMN_CUSTOM_ProcessRxCANMessage 由 RAMN 的 CAN 接收任务在接收到新 CAN 消息时调用。\n * RAMN_CUSTOM_ProcessCDCLine 由 RAMN 的 USB 接收任务在通过 USB 串行 (CDC) 接收到新行时调用。\n * RAMN_CUSTOM_TIM6ISR 由一个周期性定时器调用（默认情况下，每秒一次）。这可用于执行某些需要精确计时的操作，且与 FreeRTOS 无关。\n * RAMN_CUSTOM_ReceiveUART 在接收到 UART 命令行时被调用。\n * RAMN_CUSTOM_ReceiveI2C 和 RAMN_CUSTOM_PrepareTransmitDataI2C 在接收到 I2C RX 或 TX\n   命令时被调用（RAMN ECU 处于 设备模式）。\n\n您还可以使用 TIM16 来访问一个高精度的自由运行定时器，该定时器未被其他模块使用（参见 ramn_customize.c 中的注释）。您可以修改 TIM6\n和 TIM16，而不会影响 RAMN 的功能。\n\n阅读 ramn_customize.c 以获取示例，例如如何发送 CAN 消息。\n\n警告\n\nSPI 函数（用于更新 ECU A 的屏幕）只能从同一任务中调用 ,默认情况下，该任务是调用 RAMN_CUSTOM_Update\n的主周期性任务。这是因为该任务会等待 SPI 模块发出传输完成的通知后再继续执行，但如果从其他任务调用，则该任务将无法收到通知。\n\n如果希望从其他任务使用 SPI，需要更新对 RAMN_SPI_Init 或 RAMN_SCREENMANAGER_Init 的调用，使 SPI\n模块改为向你的任务发送通知。\n\n\n示例：每秒发送一条 CAN 报文#\n\n为了让 ECU B 每秒发送一条标准 ID 为 0x123、负载为八个 0x77 的经典 CAN 报文，您可以在 RAMN_CUSTOM_Update 中，在\n“此处代码每 1 秒执行一次” 注释之后添加以下代码：\n\n\n\n\n示例：在接收到特定 CAN 报文时执行某些操作#\n\n为了让 ECU C 在接收到上述 CAN 报文时执行某些操作，您可以在 RAMN_CUSTOM_ProcessRxCANMessage 中添加以下代码：\n\n\n\n独立地，您必须确保 ECU C 不会过滤 CAN 消息。请在 ramn_config.h 中取消定义\nUSE_HARDWARE_CAN_FILTERS,或者将该标识符添加到 ramn_canfd.c 中的 recvStdCANIDList：\n\n\n\n\n示例：根据 RAMN 控件做出决策#\n\n您可以使用以下方式读取当前 RAMN 控件的值：\n\n * 如果 ECU 具有物理访问权限（例如，用于换挡操纵杆的 ECU C），则使用 ramn_sensors.h 中的变量。\n * 如果 ECU 没有物理访问权限（例如，用于换挡操纵杆的 ECU A、B 和 D），则使用 ramn_dbc.h 中的变量。\n\n例如，如果您希望与换挡操纵杆物理连接的 ECU C 仅在操纵杆释放时执行代码，您可以添加以下条件：\n\n\n\n如果希望将相同的条件应用于其他 ECU（ECU A、B 或 D），您可以添加以下条件：\n\n\n\n注意\n * 对于第一种情况，ECU 的决策依据是物理传感器 。即使用户通过发送 CAN 操纵杆消息来伪造 CAN 总线，ECU C 也不会做出反应（因为 ECU C\n   的决策基于物理传感器）。\n * 对于第二种情况，ECU 的决策依据是最新的相关 CAN 消息 。如果您尚未实施 CAN 总线保护措施，用户便可通过伪造操纵杆 CAN 消息来绕过控制。\n\n\n自定义 ECU A 的显示#\n\nramn_screen_manager.c 是一个用于处理 ECU A 显示的模块，允许用户通过按下操纵杆上的左右键在不同屏幕之间切换。\n\n如果需要修改可用屏幕以及启动后加载的默认屏幕，请修改 screens 和 DEFAULT_SCREEN 在 ramn_screen_manager.c 和\nramn_screen_manager.h 中的内容。\n\n如果您想添加一个新的自定义屏幕，需要在代码中创建一个包含函数指针（例如：Init、DeInit、Update 等）的 RAMNScreen_t\n结构。建议您创建一个新的模块（.c 和 .h 文件），并模仿 ramn_screen_saver.c 和 ramn_screen_saver.h\n的内容，这两个文件展示了一个能够读取输入并更新屏幕的简单屏幕示例。只需复制粘贴这些文件的内容，并将其中的“screensaver”和“screen_saver”\n字符串替换为您新屏幕的名称。然后，修改这些文件以实现您期望的行为，并将您的结构添加到 screens 数组中，该数组位于\nramn_screen_manager.c 文件中。\n\n如果要显示图像，可以使用 misc 文件夹中的 image_to_C.py 脚本，将图像文件转换为可添加到.c 文件中的源代码（RGB565 数组）。然后，使用\nRAMN_SPI_DrawImage 函数并传入您的图像以进行显示（建议在仅调用一次的 Init 函数中执行，而不是在周期性调用的 Update\n函数中执行）。ECU A 的显示屏尺寸为 240x240。“内部屏幕”的尺寸为 236x195（起始偏移量为 x=2，y=2）。\n\n您可以使用 RAMN_SPI_SetScroll 或 RAMN_SPI_ScrollUp 来滚动显示屏（包括图像）。根据您希望滚动的显示区域大小，您可能需要在\nInit 阶段调用 RAMN_SCREENUTILS_PrepareScrollScreen() ，并在 DeInit 阶段调用\nRAMN_SPI_SetScroll(SCREEN_HEADER_SIZE) 。尽管显示屏的实际显示区域为 240x240，但其显示缓冲区大小为\n240x320。这意味着，如果您希望滚动屏幕，需要绘制高度为 320 的屏幕画面（但每次仅显示其中的 240 行）。\n\n\n在闪存中保存数据#\n\n您可以使用 ramn_eeprom.c 在模拟的 EEPROM 中保存数据（使用 STM32 的闪存）。该模块允许对 16 位索引（“地址”）读写 32\n位数值。由于其中一些索引用于存储 DTC 和 VIN，因此您应使用高于 DTC_LAST_VALID_ADDRESS 的索引（或者通过搜索对\nRAMN_EEPROM_Write32 的引用来禁用使用这些索引的功能）。\n\nEEPROM 模拟层可能与 FreeRTOS 存在兼容性问题，因此在使用时务必始终检查错误，并在各种条件下进行测试。如果您在使用 ramn_eeprom.c\n模块时频繁遇到错误，请随时与我们联系，以便我们进行调查。\n\n如果需要的内存超过 EEPROM 模拟所能提供的容量，您可以使用 stm32l5xx_hal_flash.h\n中的函数（文件开头的注释说明了如何使用）。请注意，在从闪存执行代码时，对其写入存在显著的限制。\n\n\n修改.ioc 文件#\n\nRAMNV1.ioc 是 STM32CubeIDE 代码生成的配置文件。它定义了微控制器的引脚配置、中断、外设（CAN/CAN-FD、SPI 等）以及\nFreeRTOS 设置。\n\n您可以在 STM32CubeIDE 中编辑 RAMNV1.ioc,该工具提供了一个图形化界面，用于修改设置（例如，添加新的 GPIO\n引脚或调整外设的波特率）。尽管也可以直接在源代码中修改这些设置（例如，通过编辑 main.c 中的 hlpuart1.Init.baudrate =\n115200; ），但 STM32CubeIDE 能够自动检测无效配置，从而节省调试时间。\n\n在项目资源管理器中双击\nRAMNV1.ioc，即可打开默认的“引脚分配与配置”选项卡。如果保存时未自动提示，可选择“项目”>“生成代码”，以根据您的更改重新生成代码。\n\n\n系统与外设设置#\n\n大部分设置均可在 “引脚分配与配置” 选项卡中进行修改。\n\n您可以在 “连接” 类别中修改外设设置。例如，选择 “LPUART1” 以修改默认 UART 波特率。选择 “FDCAN1” 以修改默认的 CAN/CAN-FD\n设置。\n\nSTM32CubeIDE 在添加新外设时不会自动启用所需的中断。请务必检查 NVIC 部分是否已启用必要的中断。\n\n\n\n\nFreeRTOS 设置#\n\nFreeRTOS 设置位于 “中间件与软件包” > “FreeRTOS”\n菜单（“配置参数”）中。在此，您可以特别修改“最小堆栈大小”，以防止堆栈溢出问题；如果需要更多 FreeRTOS 堆内存，则可修改\nTOTAL_HEAP_SIZE。请注意，这些设置与 链接器设置中描述的主堆栈和堆大小不同。如果您不确定应修改哪一项，可尝试同时修改两者。\n\n在“配置参数”菜单中，您还可以更改“内存管理方案”，默认为“heap_4”。其他方案可能不支持 free() 函数，因此建议您不要更改此设置。\n\n如果您不需要 FreeRTOS\n运行时统计信息，也可以禁用“GENERATE_RUN_TIME_STATS”、“USE_TRACE_FACILITY”和“USE_STATS_FORMATTIN\nG”，以优化您的项目。如果这样做，还应在 ramn_config.h 中禁用 GENERATE_RUNTIME_STATS。\n\n打开 “任务与队列” 选项卡，以修改/添加/删除 FreeRTOS 任务。双击某个任务可修改其设置（其中最重要的设置是优先级和堆栈大小\n）。请注意，如果您重命名某个任务，STM32CubeIDE\n实际上会删除该任务内的代码并生成一个新任务，因此您应先复制其内容，然后在代码生成后将其粘贴到新任务中。\n\n\n时钟设置#\n\n如果您希望使用内部时钟而非外部晶振，请阅读 ramn_config.h 文件底部的注释。\n\n要修改 CPU 时钟（SYSCLK），请选择顶部菜单中的 “时钟配置” 选项卡，并修改 PLLCLK 的 N 和 R 参数。默认情况下，RAMN 仅使用\n80MHz，但您可以将其提升至 110MHz。在修改此时钟后，请务必同时调整 Q 值，以确保 PLLQ 仍保持 40MHz。\n\n由于定时器依赖于 SYSCLK，如果您使用了 TIM6 和 TIM16，也需要相应地修改其设置（默认 RAMN 并不需要这些定时器；它们仅为方便您而预先配置）。\n\n\n链接器设置#\n\n要增加主堆栈和主堆大小（这与 FreeRTOS 设置中描述的 FreeRTOS 堆和堆栈大小不同），请选择顶部菜单中的 “项目管理器”\n选项卡，并更新“最小堆大小”和“最小堆栈大小”。\n\n对于其他设置，您需要直接修改 STM32L552CETX_FLASH.ld。\n\n\n其他工具#\n\n您可以使用 “工具” 选项卡来使用其他 STM32CubeIDE 工具，例如将您的项目与另一个项目进行比较，或者在您进行更改后概览微控制器的功耗情况。\n\n警告\n\nSTM32CubeIDE 在您使用代码生成功能时可能会删除代码。如果您对自动生成的文件（主要是 main.c 和 main.h）进行修改，请务必将其放置在\nUSER CODE BEGIN ... 和 USER CODE END ...\n注释之间，否则这些修改将被删除。建议您在使用代码生成功能时使用版本控制系统并检查差异，以确保您的代码不会被意外删除。\n\n\n优化性能#\n\n您可以使用 FreeRTOS 和 STM32CubeIDE 工具来优化您的应用程序。\n\n\n编译器优化#\n\n您可以通过依次选择 “项目” > “属性”,然后 “C/C++ 构建” > “设置”,再选择 “MCU GCC 编译器” >\n“优化”,来启用编译器优化。在那里，您可以选择一个优化级别以启用优化，并根据需求选择优先考虑速度或大小。\n\n\nFreeRTOS 运行时统计信息#\n\n在 ECU A 上，您可以使用 slcan ‘X’命令（参见与 USB 交互）来显示 FreeRTOS 运行时统计信息。您也可以在调试时通过\nSTM32CubeIDE 查看相同的信息（选择 “窗口” > “显示视图” > “FreeRTOS” > “任务列表”)：\n\n\n\n您可以查看每个任务的 CPU 使用率和可用堆栈的下限 。 统计信息从启动时开始计算，这意味着“使用率”显示的是自启动以来的平均使用情况，而非峰值使用率。\n如果您想观察高负载下的统计信息，请重启并立即启动高负载处理任务。\n\n如果 CPU 使用率较高（例如由于复杂的软件算法），您可能需要提高 CPU 时钟速度（参见时钟设置)，或者对代码进行重构。\n\n“堆栈”显示任务溢出前剩余的内存量。如果该值接近零，您需要增加任务的堆栈大小（参见 FreeRTOS 设置)。\n\n您可以使用 “窗口” > “显示视图” > “静态堆栈分析器” 来更好地了解堆栈的使用情况。 （您可能需要先选择“文件” >\n“刷新”，然后在堆栈分析器窗口中单击刷新图标，才能看到正确的数值。） 请注意，某些视图以字（32 位）为单位显示大小，而另一些视图则以字节（8\n位）为单位显示大小。\n\n\n\n警告\n\n如果您使用了代码生成功能，可能需要在 STM32CubeIDE 中为 ulTotalRunTime（位于 tasks.c 的第 396 行）添加\nvolatile,以确保统计信息能够正确读取。如果在 STM32CubeIDE 中遇到运行时统计问题，请按照此处的步骤操作。\n\nFreeRTOS 统计信息是通过 TIM7 计算的。如果您需要更高的精度，可以修改 TIM7 的计数器周期值（例如，从 7999 改为 799），但这会增加\nCPU 负载。\n\n当您完成应用程序优化后，可以禁用运行时统计信息（请参阅 FreeRTOS 设置)。\n\n注意\n\nRAMNV1.ioc 是为 STM32L552 微控制器创建的。如果您拥有 STM32L562\n微控制器并希望使用其加密硬件外设，则必须手动将“STM32L552”的引用更新为“STM32L562”。\n\n\n理解 RAMN 的内存#\n\n请阅读 内存布局,尤其是当您需要内存保护时。\n\n如果内存不足且不需要内存保护，请尝试将 STM32L552CETX_FLASH.ld 的内容替换为\nSTM32L552CETX_FLASH_INSECURE.ld 的内容。同时，也请尝试启用 编译器优化。\n\n如果在 INSECURE_RAM 区域中出现内存不足的情况，请尝试在 ramn_config.h 中降低以下定义的值（某些定义在 ECU A 和 ECU\nB/C/D 中可能有所不同）：\n\n * USB_RX_BUFFER_SIZE\n * USB_TX_BUFFER_SIZE\n * CAN_RX_BUFFER_SIZE\n * CAN_TX_BUFFER_SIZE\n * USB_COMMAND_BUFFER_SIZE\n\n如果您在 RAM 区域中耗尽了内存，应尝试减小堆和栈的大小，如修改 .ioc\n文件一节所述。如果您不确定该减小哪个大小，可先从“最小堆大小”开始（在链接器设置中）。\n\n如果您使用默认的 STM32L552CETX_FLASH.ld 链接器脚本，可通过在其定义中添加 __attribute__ ((section\n(\".buffers\"))) ，将变量从 RAM 移动到 INSECURE_RAM。如果存在一个较大的变量，您认为其无需保护（例如，非关键的 FreeRTOS\n任务栈），可以将其移至 INSECURE_RAM，并将释放的空间用于您自己的应用程序。\n\n如果您想了解如何修改布局以实现内存漏洞，请参阅实现漏洞一节。\n\n\n理解 RAMN 的安全特性#\n\n\n加固#\n\n您可以在 ramn_config.h 中使用 HARDENING\n标志，以禁用那些容易危及设备安全的功能。启用此标志后，您将遇到各种编译错误，提示您还应启用或禁用哪些其他标志。请根据提示建议进行处理，或者删除 #error\n指令。\n\n如果您不需要某些剩余功能，可通过直接编辑源代码将其移除。值得注意的是，我们建议您检查可用的 UDS 服务，并编辑\nRAMN_UDS_ProcessDiagPayload 和 RAMN_UDS_ProcessDiagPayloadFunctional\n。请务必重新构建索引，以确保 STM32CubeIDE 能够正确高亮显示哪些函数仍然可用（选择 “项目” > “C/C++索引” > “重新构建”）。\n\n\n内存保护#\n\n您可以在 ramn_config.h 中使用 MEMORY_AUTOLOCK 标志来保护内存。当启用此标志时，STM32 RDP\n选项字节将在启动期间设置为临时启用内存保护。 在您移除保护之前，将无法再对固件进行调试，因此应在完成调试后再执行此操作。\n\n为确保内存保护已启用，您需要确认固件至少已被执行过一次（具体是否满足此条件取决于您用于编程固件的工具）。因此，建议您移除任何 JTAG 调试器，并对 RAMN\n进行一次断电重启。\n\n使用默认保护机制（RDP 级别 1）， 内存保护可随时解除，但内存会自动擦除 。您可以通过更新 ramn_config.h 中的 RDP_OPTIONBYTE\n来启用 RDP 级别 2，从而对设备进行永久锁定 ,但相应地您将失去重新刷写和调试的能力。\n\n要解除 ECU A 的保护，您可以使用 ‘D’ slcan 命令。默认情况下，此命令需要一个由 DFU_COMMAND_STRING\n定义的“密码”。然而，该“密码”仅用于防止意外的内存擦除（例如由于模糊测试）；通过 JTAG 仍然可以无需任何密码直接解除保护。\n\nECU A 的保护会由 ECUA_OptionBytes_Reset.bat 和 ProgramECU_A.bat 自动解除。如果您更改了密码，则需要相应地更新\nECUA_goToDFU.py 脚本。对于 ECU B/C/D，您可以使用 Unlock_BCD.bat 脚本来解除内存保护。\n\n此外，您也可以通过 STM32 引导加载程序接口来启用和禁用内存保护。STM32 引导加载程序能够独立地启用或禁用读写保护。对于 ECU\nA，您可以使用意法半导体提供的 DFU 工具（或 STM32CubeProgrammer）。对于 ECU B/C/D，您可以使用位于\nscripts/STBootloader 文件夹中的 canboot.py Python 脚本：\n\n\n\n如果您直接使用 STM32 引导加载程序接口，请务必确保内存保护设置一致，否则可能会遇到问题（请参阅内存保护不一致）。\n\n请阅读内存布局,以了解如何通过 MEMORY_AUTOLOCK 标志对内存进行（或无法进行）保护。请注意，SRAM1（INSECURE_RAM\n区域）无法被保护，除非您永久锁定设备（请参阅 RAM)。\n\n当 RDP 级别 1 内存保护处于激活状态时，预期的 JTAG 行为如下：\n\n * 用户可通过 JTAG 连接并移除内存保护（触发大规模内存擦除）。\n\n * 用户无法读取或写入 Flash（将返回错误）。\n\n * 用户无法读取或写入 SRAM2（“RAM”）（仅显示零值，不会返回错误）。\n\n * 用户可以读取或写入 SRAM1（“INSECURE_RAM”）。 但用户无法恢复执行 。\n\n * 用户可以执行任意代码，但该任意代码无法访问 SRAM2 或 Flash。\n\n\n唯一硬件种子#\n\n如果您需要为密钥派生函数提供种子，以生成每个 ECU 的唯一密钥，可以使用位于 HARDWARE_UNIQUE_ID_ADDRESS 处的 8 个字节。\n\n\n额外的安全功能（TrustZone 等）#\n\nSTM32L5 微控制器配备了 MPU，如果您需要启用内存保护功能，可以使用它。\n\n尽管这些功能默认处于禁用状态，但您仍可为您的应用程序启用 TrustZone 功能。有关 STM32L552 安全功能的更多信息，请参阅 STM32L552\n数据手册。\n\n如果您的 RAMN 配备了 STM32L562 微控制器，则还可使用加密引擎（例如用于 AES 和公钥操作）。有关详细信息，请参阅 STM32L562\n数据手册。\n\n\n探索 RAMN 的安全性#\n\n\n在 Ghidra 中分析 RAMN 固件#\n\n如果您希望在 Ghidra 中分析 RAMN 固件，应使用构建固件时在 RAMNV1/Debug 或 RAMNV1/Release 文件夹中生成的 .elf\n文件。RAMN 所使用的 STM32L552/STM32L562 微控制器基于 ARM Cortex M-33 内核，该内核仅支持 Thumb 指令。\n\n请注意，更改编译器优化设置通常会导致生成非常不同的二进制代码。\n\n与.hex 文件不同，.elf 文件包含调试符号，这大大简化了分析过程。如果需要移除调试符号，必须使用 arm\n工具链，而不是系统中可能已有的默认工具链。例如，应使用 arm-none-eabi-strip,而不能仅使用 strip。\n\n当您在 Ghidra 中加载.hex 文件时，可能会因为缺少内存映射信息而导致分析困难。固件的默认起始地址（Flash）为 0x08000000。您应打开“\n工具 ”>“ 内存映射 ”，并按照 STM32L552CETX_FLASH.ld 中定义的内容添加区域。此外，您还可以根据 STM32L5\n参考手册添加特殊寄存器（例如外设）的相关信息。请搜索“ 内存映射和寄存器边界地址 ”以及“ 外设寄存器边界\n”。您也可以找到在线资源来帮助您实现这一过程的自动化。\n\n\n为 RAMN 编写 ARM shellcode#\n\n您可以使用常见的 Shellcode 编写工具，编写可在 RAMN 上执行的 ARM Shellcode（二进制代码）。您必须将目标选择为“ARM\n(thumb)”（适用于 ARM Cortex M-33 的 16 位指令）。默认情况下未启用 TrustZone，也无需进行权限提升。默认情况下已启用 RAM\n执行功能，以便用户能够轻松测试 Shellcode。\n\n您可以使用 UDS 例程 0x209（参见例程控制 (0x31)）通过 CAN 测试有效载荷。诊断任务将跳转到您的有效载荷地址。此例程要求您首先执行安全访问\n(0x27) 中所述的简单安全访问方法，以防止在模糊测试过程中发生意外执行。由于 UDS 数据直接复制到内存中，因此您必须以小端格式提供指令（例如，在您的\nCAN 有效载荷中，nop 应显示为 00BF,而不是 BF00）。\n\n该函数不会自动返回，因此您应保存上下文并自行安全地返回，例如在末尾执行 bx lr（7047）。只有当您的代码成功返回时，UDS\n服务才会作出响应（响应是在有效载荷执行之后，而非之前）。\n\n例如，有效载荷 00BF7047 将执行一条 NOP 指令并返回。\n\n为 RAMN 编写 ARM shellcode 并不特别困难，但请注意，网络上的大多数资源都是针对 Linux 嵌入式系统，而非 FreeRTOS\n嵌入式系统。虽然大部分技术仍然适用，但在 RAMN 上无法通过系统调用“弹出一个 shell”，因为根本不存在\nshell。同样地，需要注意的是，大多数任务会处于休眠状态，等待通知后才继续执行。如果你利用某个任务并调用一个函数，而该函数却在等待本应属于另一个任务的通知，那\n么它将永远挂起，除非你先覆盖该通知处理程序，或者找到其他方式来触发通知。类似地，某个任务可能不会检查资源是否可用，因为它假定自己是唯一使用该资源的任务，因此你可\n能会无意中影响到其他任务。\n\n\n使用 OpenOCD 进行调试#\n\n你可以将 OpenOCD 调试器连接到 RAMN 的 ECU。有关连接方式，请参阅 JTAG 硬件接口。\n\n你应该使用 stm32l5x.cfg 配置文件（在 Linux 系统中，该文件通常位于 /usr/share/openocd 下的某个位置）。\n\n启动一个 openocd 服务器，并通过以下方式连接到它：\n\n\n\n然后，您可以执行调试命令，例如：\n\n\n\n\n典型项目指导#\n\n\n为CTF（或类似活动）准备 RAMN#\n\n您可以按照本页面的说明来创建 CTF 挑战。例如，您可以根据 CAN 流量的简单修改（标识符、周期等） 一节中的说明，修改 CAN\n标识符，并让参与者猜测您新定义的标识符。您可以在 CTF 解题报告一节中找到简单和高级 CTF 挑战的示例。\n\n如果您想将 RAMN 用于CTF或类似活动，需要确保用户无法轻易读取固件或执行任意代码。 如果您的 CTF 面向初学者，可以跳过本节中的说明 。\n\n为确保用户无法轻易转储固件，您应修改 ramn_config.h,以实现以下目标：\n\n * 启用 HARDENING,以移除潜在的危险功能（如用于读写内存的 UDS 服务等）。\n * 启用 MEMORY_AUTOLOCK,以便在启动时自动启用 STM32 内存保护（RDP），从而防止通过 JTAG 或引导加载程序模式进行内存转储。\n\n此外，建议开启编译器优化，以移除可能残留在内存中的未使用代码。当定义了 MEMORY_AUTOLOCK\n标志时，您将无法调试固件，因此应在开发完成后才启用该选项。\n\n请阅读理解 RAMN 的安全特性部分，以了解更多关于内存保护的信息。请记住，MEMORY_AUTOLOCK 仅会保护 Flash 和\nSRAM2（“RAM”）区域的内存。SRAM1（“INSECURE_RAM”）仍可通过调试接口进行读取。因此，您应确保没有敏感数据（标志等）存储在 SRAM1\n中。默认情况下，源代码不会将任何内容放入 SRAM1，除非您主动在那里声明变量（参见 RAM）。RAMN 仅将 SRAM1\n用于通信缓冲区（USB、SPI、CAN 等），因为这些缓冲区无论如何都会始终暴露在外。\n\n默认情况下，RAM 是可执行的。如果您禁止 RAM 代码执行，将无法通过 USB 移除内存保护（使用 slcan ‘D’命令），并且只能通过 JTAG 移除\nECU A 的保护。\n\n由于 ECU A 的功能最为复杂，因此最有可能存在未预料到的漏洞，这些漏洞最终可能比你实际设置的挑战更容易被利用。如果你希望为高级用户设计一场 CTF\n比赛，建议将最具难度的挑战部署在 ECU B/C/D 上。\n\n在启用 HARDENING 时，许多 USB 和 UDS\n服务仍处于活动状态，这可能会让参与者误以为这些服务是需要分析的目标。您应明确告知参与者哪些服务不在本次范围之内（以避免他们浪费时间）。\n\n完成 CTF 后，如果您启用了 MEMORY_AUTOLOCK,可以通过执行 scripts/STBootloader/windows 文件夹中的\nUnlock_BCD.bat 和 ECUA_OptionBytes_Reset.bat 来移除内存保护。 ECU A 需要使用有效的固件进行编程才能执行\nUnlock_BCD.bat,因此应最后擦除 ECU A。 然后，您可以执行 ProgramECU_A.bat 和\nProgramECU_BCD.bat（来自原始 Github 仓库）以恢复原始固件。\n\n\n实现安全的 CAN 总线（SecOC 等）#\n\n要在 CAN（或 CAN-FD）上实现您自己的消息认证或加密机制，请编辑以下 ramn_dbc.c 函数：\n\n * RAMN_DBC_FormatDefaultPeriodicMessage 以实现您的机制（例如，加密有效载荷、计算 MAC 而非 CRC32 等）。\n * RAMN_DBC_ProcessCANMessage 以实现相关消息处理（例如，解密有效载荷、验证 MAC 等）。\n\n如果您希望使用 CAN-FD 而非 CAN，请阅读升级到 CAN-FD 部分。要深入了解 ramn_dbc.c 模块，请阅读 CAN\n流量的高级修改（有效载荷格式等） 部分。\n\n要仅修改特定的 CAN/CAN-FD 报文（例如制动控制报文），而不是所有报文，请将 RAMN_DBC_Send 更新为调用您的函数，而非\nRAMN_DBC_FormatDefaultPeriodicMessage 。例如：\n\n\n\n对于加密操作，您可以使用众多嵌入式软件加密库之一（例如：Tiny AES 或 CMOX）。如果您的 RAMN 配备了 STM32L562\n微控制器，您还可以访问用于私钥和公钥操作的硬件加密引擎。\n\n在为所有 ECU 构建并刷写固件后，RAMN 应该能够照常运行，但会采用您更新后的流量规范。\n\n参考：\n\n * 唯一硬件种子：如果您需要用于密钥派生的唯一硬件种子。\n\n * 在闪存中保存数据：如果您需要存储永久性数据（例如计数器）。\n\n\n实现自定义引导程序（OTA、安全启动等）#\n\n首先，请阅读内存布局部分，以了解默认的内存布局。\n\n您应假设在从内部闪存执行代码时，无法向其写入数据。您可以选择以下任一方式：\n\n * 在双 bank 模式下使用 STM32，这样可以在一个 bank 中执行代码的同时向另一个 bank 写入代码。\n * 在单 bank 模式下使用 STM32，但将您的代码从 RAM 中执行。\n\n如果您想使用双存储区模式实现内部存储器的重新刷写，请务必确保您使用的微控制器具有 512KB 内存 （STM32 微控制器参考型号以 CET6\n结尾）。否则，您的微控制器仅配备一个 256kB 的闪存存储区。\n\n您可以通过使用 __attribute__((__section__(\".RamFunc\"))) 将函数放入 RAM 中。有关此类示例，请参阅\nramn_memory.c。如果您希望对闪存执行写操作，很可能还需要使用 __disable_irq(); 来禁用中断，因为默认情况下，中断服务例程位于闪存中。\n\nUDS 重新编程依赖于双 bank 模式，它可能会切换 bank 并覆盖内存的任何区域。因此，您可能需要禁用 UDS 重新编程（在 ramn_config.h\n中取消定义 ENABLE_UDS_REPROGRAMMING），或者更新 ramn_uds.c 中的 UDS 重新编程接口，以使其与您的引导程序兼容。\n\nRAMN 没有自定义引导程序，而是直接运行您刷入的固件。然而，STM32L5 微控制器已经内置了一个硬件引导程序。该引导程序通常仅在启动时 BOOT0\n引脚为高电平时才会执行。\n\n * ECU A 忽略物理 BOOT0 引脚的状态，并根据其 STM32 选项字节（nSWBOOT0 和 nBOOT0）来决定是否进入引导加载程序模式。\n * ECU B/C/D 则根据其物理 BOOT0 引脚的状态（由 ECU A 驱动）来决定是否进入引导加载程序模式。\n\n该 STM32 引导加载程序位于只读存储器中，无法进行修改。虽然您可以通过修改 STM32 引导加载程序的地址（NSBOOTADD1 选项字节，默认值为\n0x0BF90000）来完全替换它，但并不推荐这样做，因为这将导致您无法再使用 scripts/STBootloader\n文件夹中的脚本。同样地，您也可以通过修改 STM32 的 NSBOOTADD0 选项字节（默认值为 0x08000000）来更改应用程序启动地址（当 BOOT0\n为低电平时启动）。\n\n如果你的目标是为研究或教育目的实现一个概念验证（例如 OTA、安全启动等），我们建议你：\n\n * 忽略 STM32 的引导加载程序和选项字节，并假设 0x08000000 是代码执行“安全”开始的位置。\n * 将您的自定义引导加载程序编写至 0x08000000 处（您可以使用 RAMN 的原始源代码，或任何 STM32CubeIDE 模板项目）。\n * 将应用程序编写至 0x08000000 + 引导加载程序最大长度处（使用 RAMN 默认源代码的副本，并按照以下说明进行修改）。\n\n您可以通过修改 STM32L552CETX_FLASH.ld 中 FLASH (rx) : ORIGIN = 0x8000000, LENGTH = 248K\n行来调整应用程序所使用的内存布局。如果您修改了项目的起始地址，还需确保中断向量表指向新的起始地址。这需要通过修改 main.c 中 main()\n的最开始几行来实现：\n\n\n\n这些代码行用于确保即使前一阶段（之前的引导加载程序）修改了中断向量表，代码仍能正确启动。 如果您为引导程序创建一个新的 STM32CubeIDE\n项目，还需要添加以下几行代码，以将中断表向量指向您的引导程序起始地址（即使该地址默认为 0x08000000）。这是因为 STM32CubeIDE\n模板项目不会重置中断表向量，但该向量可能已被 STM32 嵌入式引导程序修改。\n\n一旦您完成引导程序的开发，如果确实需要，您可以禁用 STM32 嵌入式引导程序，例如通过将 NSBOOTADD0 和 NSBOOTADD1\n设置为您引导程序的地址，并启用（永久性）内存保护（参见内存保护）。有关更多详细信息，请参阅启动配置。\n\n\n实现漏洞#\n\n如果你想在 RAMN 上实现内存漏洞（例如用于安全培训），很可能需要让某些变量在内存中彼此相邻。确保变量相邻的简单方法是使用 C 语言中的结构体\n,但如果这些变量属于不同的模块，这种方法并不实用。\n\n请注意，使用 GCC 时，您无法采用某些可能在网上找到的建议（例如，使用 at 属性）。您可以通过使用 section\n属性，确保某些变量（即使它们属于不同的模块）在特定内存区域中彼此相邻。例如，如果您希望确保 variable1 和 variable2\n相邻放置，可以按如下方式定义它们：\n\n\n\n然后，您可以修改链接器脚本 STM32L552CETX_FLASH.ld,并使用 KEEP 指令，以使这些变量位于特定区域。例如，如果您希望 variable2\n位于 variable1 之前，在 .bss 区域的末尾，只需在 *(.bss*) 之后添加以下几行：\n\n\n\n或者，您也可以通过在 STM32L552CETX_FLASH.ld 中定义自定义区域，为这些变量创建新的区域：\n\n\n\n例如，如果您希望确保它们被放置在 RAM 的最末端，请在 HEAP 段的定义（以 ._user_heap_stack : 开头）之后立即添加上述定义。\n\n\n创建新扩展#\n\n有关扩展硬件的详细信息，请参阅扩展端口页面。\n\n设计扩展时最易使用的接口是 UART,但您也可以使用 I2C（主设备或从设备）、SPI（主设备或从设备）、基于定时器的接口（例如用于 WS2812B LED\n和伺服电机的 PWM 控制）、模数转换器（ADC）以及 GPIO（例如用于位操作或中断）。\n\nUART（LPUART1，速率为 115200bps）和 I2C（I2C2，设备模式，地址为 0x77）仅为方便您使用而预先配置；它们并未被主动使用。\nSPI（SPI2）已配置，并由 ECU A 和 D 主动用于控制显示屏和 LED。 如果您希望在 ECU A 和 D 上使用 SPI\n进行自定义扩展，则需要对通信进行复用，并且将无法以设备模式使用 SPI（除非您移除原有的扩展模块）。\n\nECU A 上配备了一个 SD 卡读卡器，可通过 SPI 模式访问 SD 卡。RAMN 并未主动使用该功能，但其本身是可用的。 PB10 引脚同时用于预配置的\nI2C SCL 引脚和 ECU A 上 SD 卡读卡器的 CS 引脚，因此除非您清楚自己的操作，否则应假设无法同时使用 SD 卡读卡器和 I2C。\n\n如果您计划使 RAMN 的总功耗超过 500 mA，则应更新 USB 描述符中的“MaxPower”字段（位于 usbd_composite.c 中）。\n\n警告\n\n在制作扩展板之前，我们强烈建议您打开 ioc 文件（参见修改 .ioc\n文件），并充分配置微控制器，以确保您所需的所有功能均在所用引脚上可用，并自动检查潜在的冲突。\n\nUART#\n\n您需要连接 TX 和 RX 引脚，以实现与扩展设备上的通信（如果仅单向通信，则只需连接其中一个引脚）。\n\n * 将 LPUART1_RX (PA3)连接到设备的 TX 引脚 （RAMN 将其用作 UART 输入）。\n * 将 LPUART1_TX (PA2)连接到设备的 RX 引脚 （RAMN 将其用作 UART 输出）。\n\n换句话说，您可能需要在 RAMN 与您的扩展设备之间交叉 RX 和 TX 引脚 。此外，您还可以选择使用 PA6 作为“CTS”，PB1 作为“RTS”。\n\n要在 RAMN 固件中启用 UART，您需要在 ramn_config.h 中定义 ENABLE_UART 标志。之后，您可以在\nramn_customize.c 中使用钩子来发送和接收 UART 数据（主要可以使用 RAMN_CUSTOM_ReceiveUART 以及\nRAMN_UART_SendFromTask 或 RAMN_UART_SendStringFromTask)。\n\n如果需要更改波特率或其他 UART 设置，请参阅修改 .ioc 文件部分。ECU A 还需要执行一些额外的步骤（详见 ramn_config.h)。\n\nI2C#\n\n你需要连接：\n\n * PB10（I2C2_SCL） 连接到扩展设备上 SCL 引脚。\n * PB11（I2C2_SDA） 连接到扩展设备上 SDA 引脚。\n\n默认情况下，RAMN 配置为 I2C 设备模式 。无需对 I2C 进行“交叉接线”，因此可直接将 SCL 连接到 SCL，SDA 连接到 SDA。如果希望将\nRAMN ECU 用作 I2C 主设备，只需更改 I2C2 外设配置（参见修改 .ioc 文件），连接保持不变。\n\n默认情况下会启用内部上拉电阻，如果您的扩展设备上已存在上拉电阻，您可能需要将其禁用。\n\n要在 RAMN 的固件中启用 I2C，请在 ramn_config.h 中启用 ENABLE_I2C 标志。之后，您可以在 ramn_customize.c\n中使用钩子（在接收数据时为 RAMN_CUSTOM_ReceiveI2C,在接收到传输请求时为\nRAMN_CUSTOM_PrepareTransmitDataI2C ）。\n\n如果您希望将 RAMN 用作主设备，可以直接使用 HAL 库（例如使用 HAL_I2C_Master_Transmit 和\nHAL_I2C_Master_Receive 等函数，并参考网上众多的 STM32 教程）。有关使用示例，请参阅 SPI 部分（I2C 与 SPI 类似）。\n\n注意\n\n如果要将 DMA 功能与 I2C 一起使用，还需要在 RAMNV1.ioc 文件中更新 DMA 配置（以配置 I2C DMA），并重新生成代码（请参阅 修改\n.ioc 文件）。\n\nSPI#\n\n您需要连接 SCK、MISO、MOSI 和 CS 引脚。如果不存在从设备到主设备的通信，则无需使用 MISO 引脚。\n\n默认情况下，RAMN 配置为 SPI 主模式 ,您应连接以下引脚：\n\n * PB13 (SPI2_SCK) 至您扩展设备上的 SCK 引脚。\n * PB14 (SPI2_MISO) 至您扩展设备上的 MISO 引脚。\n * PB15 (SPI2_MOSI) 至您扩展设备上的 MOSI 引脚。\n * PA8 (Other_nCS) 至您扩展设备上的 CS 引脚。\n\nPB2 (LCD_nCS) 用作 ECU A 和 ECU D 扩展的“片选”（CS）引脚。请勿将其用于您自己的扩展。\n\n无需将线路交叉连接 SPI（将 MISO 连接到 MISO，将 MOSI 连接到 MOSI）。默认情况下，PB14（MISO）具有一个启用的内部上拉电阻\n（以兼容 ECU A 扩展上的 SD 卡读卡器）。如果您的扩展已自带或不需要上拉电阻，则应将其禁用。\n\n如果要使用 SPI 访问 ECU A 显示屏上的 SD 卡读卡器，必须修改 RAMNV1.ioc 文件以禁用 I2C，并将 PB10\n配置为输出（请参阅修改.ioc 文件），然后将其用作 SD 卡的片选引脚。\n\n要在固件中启用 SPI，请在 ramn_config.h 中启用 ENABLE_SPI 标志。SPI 的 DMA 已经配置完毕。您可以参考网上众多 STM32\n教程，使用 HAL SPI 接口（例如 HAL_SPI_Transmit_DMA 等）。\n\n警告\n\nRAMN 的 SPI 功能通常通过启动传输并进入休眠状态，直到接收到传输完成的通知。 ramn_spi.c 假定在调用函数时 SPI\n外设已准备就绪，并且仅在传输完成后通知主周期性任务，因此您应仅从主周期性任务中调用 SPI 函数，例如在 RAMN_CUSTOM_Update\n中。或者，您也可以修改 SPI 模块以改变这一行为。\n\n如果您在主周期性任务中编写代码（例如在 ramn_customize.c 中的 RAMN_CUSTOM_Update 中），则当您的代码被调用时，SPI\n外设将始终处于就绪状态，并且您应当仅在外设再次就绪时才返回。\n\n例如，你可以通过以下伪代码发送和接收 SPI 消息：\n\n\n\n上述代码在等待时会占用 100%的 CPU，从而阻止低优先级任务的执行。因此，建议你使用等效的 DMA 函数（并在等待期间允许其他任务执行）。要调用 DMA\n函数并等待通知，你可以使用如下示例：\n\n\n\n然后，你需要确保在传输完成后，通过覆盖与你所调用函数相关联的回调函数，来通知并恢复任务的执行。\n\n\n\n如果遇到问题，请确保已启用 SPI 中断（参见修改.ioc 文件）。\n\n模数转换器（ADC）#\n\nPA6、PA7、PB0 和 PB1 可用作 ADC,且不会与其他接口发生冲突。如果需要更多 ADC，还可以禁用 UART 接口，这样 PA2 和 PA3\n将被释放出来，同样可配置为 ADC。\n\n默认情况下，RAMN 使用 DMA 定期从 ADC 读取数据，并自动将最新的 12 位值存储到一个由 16 位变量组成的数组中。\n\n如果这种行为正是您所需要的，只需将新的 ADC 引脚配置为 “ADC1_INx”,并在 .ioc 文件中更新 ADC1 设置以包含您的新 ADC（参见 修改\n.ioc 文件）。请务必更新所有相关字段，包括“转换次数”字段。然后，在 ramn_sensor.h 中更新 NUMBER_OF_ADC,以包含您的新\nADC。对于 ECU A，还应在 ramn_config.h 中定义 ENABLE_ADC 标志位。\n\n如果你需要另一种行为，应将你的 ADC 引脚配置为 “ADC2_Inx”（使用 2 而非 1），然后按照网上众多 STM32 教程中的说明，对 ADC2\n进行配置以满足你的需求。\n\n定时器（PWM）#\n\nPA6、PA7、PB0 和 PB1 未被分配功能，可配置为定时器（输入或输出）。它们通常可用于读取和写入 PWM 信号，\n但不同定时器的功能有所差异，因此你应确认这些引脚具备你所需的精确功能 。\n\nRAMN 默认情况下不需要 UART 和 I2C。如果你不使用 UART，也可以将 PA2 和 PA3 用作定时器引脚。如果你不使用 I2C，也可以将 PB10\n和 PB11 用作定时器引脚。对于不使用 SPI 的 ECU B 和 C，你还可以考虑将所有 SPI 引脚用作定时器引脚。\n\nGPIO 与中断#\n\nPA6、PA7、PB0 和 PB1 未分配功能，均可配置为 GPIO 或外部中断。\n\n通常，大多数 STM32 引脚可用作 GPIO 或外部中断。如果需要大量引脚，请考虑禁用未使用的接口并复用其引脚，具体说明请参见定时器（PWM）。\n\n\nFreeRTOS 通用提示#\n\n有关 FreeRTOS 如何用于实现 RAMN 功能的概述，请参阅 固件架构。以下是一些针对不熟悉 RTOS 用户的 FreeRTOS 使用技巧：\n\n * 与 Linux 等多任务操作系统不同，FreeRTOS\n   严格实施任务优先级。如果存在更高优先级的任务准备运行，低优先级任务将完全不会执行。如果您添加了一个高优先级任务，请确保它不会导致低优先级任务长时间得不到\n   CPU 时间（它不应主动等待某些事件）。同样，如果您添加了一个低优先级任务，请验证在 RAMN 高负载情况下该任务不会出现资源不足的情况。您可以使用\n   scripts/diagnostics 文件夹中的 UDS_LoadTest.py 脚本来测试此类问题。您还可以使用 vTaskPrioritySet()\n   动态调整优先级。\n * 使用 taskYIELD()（或\n   portYIELD_FROM_ISR())可立即允许高优先级任务执行。但是，如果存在已就绪的更高优先级任务，这将不会允许低优先级任务运行。\n * 大多数函数不能在中断服务例程（ISRs）中调用。可在 ISRs 中使用的函数通常名称以“FromISR”结尾。\n * ISRs 通常仅应用于复制数据并通知某个任务，由该任务执行实际处理。例如，如果您使用 RAMN_CUSTOM_TIM6ISR,它应仅用于通过\n   vTaskNotifyGiveFromISR() 通知另一个任务（请参阅 HAL_UART_TxCpltCallback 以获取示例）。\n * 使用队列和流缓冲区在任务之间或任务与 ISRs 之间交换数据：\n   * 队列存储固定长度的数据项，并支持多个发送者和接收者。\n   * 流缓冲区存储可变长度的数据项，但（默认情况下）仅支持一个发送方和一个接收方。\n * 使用信号量实现互斥量。FreeRTOS\n   互斥量实现了优先级继承：如果一个低优先级任务获取了被高优先级任务请求的互斥量，则该低优先级任务的优先级将临时提升为高优先级，直到其释放该互斥量。你不能在中\n   断服务例程中获取互斥量。\n * 队列、流缓冲区和信号量（以及其他同步原语）在使用前必须进行初始化，可通过静态或动态分配方式完成（例如：xStreamBufferCreateStatic(\n   )）。\n * 任务绝不能返回。如果你修改了 RAMN_CUSTOM_CustomTask 函数，请确保其中包含无限循环，或者以 vTaskDelete(NULL)\n   结束。\n * 使用 osDelay() 使任务进入睡眠状态，以便其他任务得以执行。如果你的任务执行时间可变，请使用 vTaskDelayUntil()\n   来计算相对于任务开始执行时刻的延迟时间（而非调用延迟函数时的时刻）。\n\n\n局限性#\n\nRAMN 中没有内置方法来判断特定已排队待发送的 CAN 消息是否成功发送。默认情况下，CAN 外设的自动重传功能是启用的，这意味着 ECU\n将持续重试发送，直到成功或进入总线关闭模式。\n\n如果您禁用自动重传功能，请考虑修改 RAMN_SendCANFunc()、 HAL_FDCAN_TxBufferCompleteCallback() 以及\nHAL_FDCAN_ErrorCallback(),以跟踪哪些报文已发送，哪些未发送。\n\n请注意，当自动重传功能被禁用时，观察到的行为是： 如果 ECU 在仲裁过程中失败，将不会重新尝试传输 （这是一种正常现象，并非真正的 CAN\n错误）。您可能还需要修改源代码以改变这一行为。","routePath":"/docs/firmware/customizing_guide","lang":"","toc":[{"text":"修改 RAMN 固件","id":"修改-ramn-固件","depth":2,"charIndex":1532},{"text":"刷新 RAMN 固件","id":"刷新-ramn-固件","depth":2,"charIndex":3319},{"text":"调试 RAMN 固件","id":"调试-ramn-固件","depth":2,"charIndex":3625},{"text":"配置固件（ramn_config.h）","id":"配置固件ramn_configh","depth":2,"charIndex":4348},{"text":"CAN 流量的简单修改（标识符、周期等）","id":"can-流量的简单修改标识符周期等","depth":2,"charIndex":5003},{"text":"升级到 CAN-FD","id":"升级到-can-fd","depth":3,"charIndex":5485},{"text":"CAN 流量的高级修改（有效载荷格式等）","id":"can-流量的高级修改有效载荷格式等","depth":2,"charIndex":5940},{"text":"修改 CAN 滤波器或波特率","id":"修改-can-滤波器或波特率","depth":2,"charIndex":6555},{"text":"修改 UDS 接口","id":"修改-uds-接口","depth":2,"charIndex":7073},{"text":"添加新内容","id":"添加新内容","depth":2,"charIndex":7368},{"text":"示例：每秒发送一条 CAN 报文","id":"示例每秒发送一条-can-报文","depth":3,"charIndex":8432},{"text":"示例：在接收到特定 CAN 报文时执行某些操作","id":"示例在接收到特定-can-报文时执行某些操作","depth":3,"charIndex":8563},{"text":"示例：根据 RAMN 控件做出决策","id":"示例根据-ramn-控件做出决策","depth":3,"charIndex":8794},{"text":"自定义 ECU A 的显示","id":"自定义-ecu-a-的显示","depth":2,"charIndex":9249},{"text":"在闪存中保存数据","id":"在闪存中保存数据","depth":2,"charIndex":10256},{"text":"修改.ioc 文件","id":"修改ioc-文件","depth":2,"charIndex":10668},{"text":"系统与外设设置","id":"系统与外设设置","depth":3,"charIndex":11045},{"text":"FreeRTOS 设置","id":"freertos-设置","depth":3,"charIndex":11232},{"text":"时钟设置","id":"时钟设置","depth":3,"charIndex":11805},{"text":"链接器设置","id":"链接器设置","depth":3,"charIndex":12082},{"text":"其他工具","id":"其他工具","depth":3,"charIndex":12225},{"text":"优化性能","id":"优化性能","depth":2,"charIndex":12492},{"text":"编译器优化","id":"编译器优化","depth":3,"charIndex":12544},{"text":"FreeRTOS 运行时统计信息","id":"freertos-运行时统计信息","depth":3,"charIndex":12670},{"text":"理解 RAMN 的内存","id":"理解-ramn-的内存","depth":2,"charIndex":13584},{"text":"理解 RAMN 的安全特性","id":"理解-ramn-的安全特性","depth":2,"charIndex":14251},{"text":"加固","id":"加固","depth":3,"charIndex":14268},{"text":"内存保护","id":"内存保护","depth":3,"charIndex":14593},{"text":"唯一硬件种子","id":"唯一硬件种子","depth":3,"charIndex":15812},{"text":"额外的安全功能（TrustZone 等）","id":"额外的安全功能trustzone-等","depth":3,"charIndex":15900},{"text":"探索 RAMN 的安全性","id":"探索-ramn-的安全性","depth":2,"charIndex":16135},{"text":"在 Ghidra 中分析 RAMN 固件","id":"在-ghidra-中分析-ramn-固件","depth":3,"charIndex":16151},{"text":"为 RAMN 编写 ARM shellcode","id":"为-ramn-编写-arm-shellcode","depth":3,"charIndex":16715},{"text":"使用 OpenOCD 进行调试","id":"使用-openocd-进行调试","depth":3,"charIndex":17555},{"text":"典型项目指导","id":"典型项目指导","depth":2,"charIndex":17754},{"text":"为CTF（或类似活动）准备 RAMN","id":"为ctf或类似活动准备-ramn","depth":3,"charIndex":17764},{"text":"实现安全的 CAN 总线（SecOC 等）","id":"实现安全的-can-总线secoc-等","depth":3,"charIndex":19036},{"text":"实现自定义引导程序（OTA、安全启动等）","id":"实现自定义引导程序ota安全启动等","depth":3,"charIndex":19679},{"text":"实现漏洞","id":"实现漏洞","depth":3,"charIndex":21466},{"text":"创建新扩展","id":"创建新扩展","depth":3,"charIndex":21995},{"text":"UART","id":"uart","depth":4,"charIndex":22669},{"text":"I2C","id":"i2c","depth":4,"charIndex":23188},{"text":"SPI","id":"spi","depth":4,"charIndex":23856},{"text":"模数转换器（ADC）","id":"模数转换器adc","depth":4,"charIndex":25024},{"text":"定时器（PWM）","id":"定时器pwm","depth":4,"charIndex":25498},{"text":"GPIO 与中断","id":"gpio-与中断","depth":4,"charIndex":25752},{"text":"FreeRTOS 通用提示","id":"freertos-通用提示","depth":2,"charIndex":25882},{"text":"局限性","id":"局限性","depth":2,"charIndex":27069}],"domain":"","frontmatter":{},"version":""},{"id":5,"title":"","content":"","routePath":"/docs/firmware/","lang":"","toc":[],"domain":"","frontmatter":{"overview":true},"version":""},{"id":6,"title":"内存布局","content":"#\n\nRAMN ECU 具有三个主要的内存区域：\n\n * FLASH（根据微控制器的不同，为 256kB 或 512kB），起始地址为 0x08000000。\n * INSECURE_RAM（192kB，对应于 SRAM1），起始地址为 0x20000000。\n * RAM（64kB，对应于 SRAM2），起始地址为 0x20030000。\n\n如果内存不足，请参阅 理解 RAMN 的内存。\n\n\n内存保护#\n\n可以临时保护 FLASH 和 RAM 免受 JTAG 内存访问的影响（例如，如果您想在 CTF 比赛中使用 RAMN\n并需要保护其内存，但又不想永久锁定您的设备）。 您可以使用 RDP 选项字节（级别 1），该字节可随时撤销，以允许 ECU 重新编程。\n当临时内存保护被移除时，固件会自动擦除。\n\n然而，在不永久禁用 JTAG（RDP 保护级别 2）的情况下，无法保护 INSECURE_RAM。\n\n如果要启用内存保护，请参阅内存保护 。\n\n注意\n\n如果您不打算使用任何内存保护功能，您可以（也应当）将 STM32L552CETX_FLASH.ld 的内容替换为\nSTM32L552CETX_FLASH_INSECURE.ld ，这样在编译时仅会定义一个较大的 256kB RAM 区域（被认为不安全）。\n\n\nFLASH#\n\nRAMN 的 ECU 利用了 STM32L5 的双存储区架构。FLASH 存储器的内存布局如下所示（如果微控制器仅有 256kB 内存，则仅存在左侧部分）。\n\nRAMN 车载电子控制单元的内存布局\n\nECU 固件每次仅使用两个闪存存储区中的一个。该存储区被分为两部分：\n\n * 固件区域，用于存放当前正在执行的代码。\n * EEPROM 模拟区域，用于存储诸如 VIN、DTC 及其他动态数据。\n\n当通过 UDS 对 ECU 进行重新编程时（ 而非通过其他接口 ），ECU 实际上会将新固件以及当前的 EEPROM 复制到非活动存储区。一旦复制完成，ECU\n将切换 SWAP_BANK 选项字节，以交换两个存储区，从而有效地更新 ECU 正在运行的固件。\n\n警告\n\n交换存储区可能会导致许多外部工具产生混淆，例如 STM32CubeIDE 或 STM32CubeProgrammer。在使用这些工具之前，您应确保未选中\nSWAP_BANK 选项字节。\n\n如果您不需要 EEPROM 模拟，并希望将整个闪存用于自己的应用程序，可以在 ramn_config.h 中禁用 ENABLE_EEPROM_EMULATION\n标志。然后，您可以修改 STM32L552CETX_FLASH.ld,并将 LENGTH = 248K 替换为 LENGTH = 256K。\n\n同样地，如果您不需要 UDS 重新编程，并且您的微控制器具有 512kB 闪存（微控制器型号以 CET6 结尾），您也可以在 ramn_config.h 中禁用\nENABLE_UDS_REPROGRAMMING 标志，并使用 LENGTH = 512K。此外，您还需要确保在 STM32CubeProgrammer\n中取消选中 SWAP_BANK 选项字节（参见预期选项字节 )。\n\n当您禁用 ENABLE_UDS_REPROGRAMMING 标志时，ECU 将不再接受 UDS 重新编程，但仍然可以通过 JTAG 或 STM32\n引导加载程序接口（位于 scripts/STbootloader 中）对 ECU 进行重新编程。\n\n\nRAM#\n\n\n区域#\n\nSTM32L5 微控制器具有两个 RAM 区域：SRAM1 和 SRAM2。 SRAM1 无法被保护 ，除非 JTAG\n被永久禁用，因此除非您愿意永久锁定设备，否则它始终是可读的。然而，SRAM2 可以被临时保护。\n\n因此，RAMN 定义了 RAM 和 INSECURE_RAM 区域。默认情况下，变量会被放置在 RAM 区域中，但该区域仅有\n64kB。为了避免该区域过快被填满，那些体积较大但不存储关键数据的变量会被放置在 INSECURE_RAM 区域。这通常适用于 USB、SPI 和 CAN\n缓冲区，因为这些缓冲区仅存储通过访问相应接口即可读取的数据。具体而言，可以通过在变量声明中添加 __attribute__ ((section\n(\".buffers\"))) 来实现这一点。\n\n警告\n\nINSECURE_RAM 设置了“NOLOAD”参数，这意味着您在声明时无法对其进行初始化（例如，如果您写入 __attribute__ ((section\n(\".buffers\"))) uint8_t example = 1 ，example 将不会保存 1，而是会保存启动时内存中的任意值）。您可以通过移除\n(NOLOAD) 来禁用此行为，具体操作是在 STM32L552CETX_FLASH.ld 中进行，但这样会导致生成非常大的 .bin 文件。\n\n\n堆与栈#\n\n由于 RAMN 依赖于 FreeRTOS，因此存在两个堆和多个栈：\n\n * STM32 主堆和栈 （._user_heap_stack, 定义在 STM32L552CETX_FLASH.ld 中）。\n * FreeRTOS 堆 （.bss 中的 ucHeap），用于动态分配任务。\n * FreeRTOS 栈 （Timer_Stack.0、Idle_stack.2，以及每个任务的独立栈 ,位于 .bss 中）。\n\n如果出现内存不足或栈溢出的情况，请务必确定哪些堆/栈可以缩小，哪些堆/栈需要扩大。\n\n\n内存分析#\n\n您可以通过构建项目并选择 “窗口” > “显示视图” > “构建分析器” 来观察 RAMN 的内存使用情况（可能需要先选择 “文件” >\n“刷新”,然后在构建分析器窗口中点击刷新图标以正确显示）。这将向您展示当前内存的使用百分比。\n\n\n\n您可以选择“内存详情”选项卡，以更好地了解哪些变量正在占用空间。如果您需要更多内存，在理解 RAMN 的内存部分中提供了可减小变量大小的建议。\n\n","routePath":"/docs/firmware/memory_layout","lang":"","toc":[{"text":"内存保护","id":"内存保护","depth":2,"charIndex":198},{"text":"FLASH","id":"flash","depth":2,"charIndex":560},{"text":"RAM","id":"ram","depth":2,"charIndex":1465},{"text":"区域","id":"区域","depth":3,"charIndex":1472},{"text":"堆与栈","id":"堆与栈","depth":3,"charIndex":2057},{"text":"内存分析","id":"内存分析","depth":2,"charIndex":2315}],"domain":"","frontmatter":{},"version":""},{"id":7,"title":"基本信息","content":"#\n\n\n什么是 RAMN ？#\n\n\n\nRAMN（抗干扰汽车微型网络）是一种信用卡大小的电子控制单元测试平台，用于安全地研究和探索汽车系统。\n\nRAMN 是一组 PCB（印刷电路板），可组合使用以模拟 ECU（电子控制单元）的 CAN 或 CAN-FD 网络。\n\n\n主要特性#\n\n\nECU 网络仿真#\n\nRAMN 可仿真由 4 个 ECU 组成的 CAN/CAN-FD 网络。默认情况下，网络流量规范仅采用经典 CAN 消息，并与 PASTA 的规范完全一致。\n\n\n\n\n交互#\n\nRAMN 可以使用 Arduino 样式引脚接口扩展板。您可以添加传感器和执行器，并与 ECU 进行物理交互。\n\n\n\n\n即插即用#\n\nRAMN 通过 USB 实现 slcan 协议。它被识别为标准的 CAN 至 USB 适配器。无需购买和连接其他工具，只需将 RAMN 插入 USB\n端口即可开始使用。\n\n\n\n\n扩展#\n\n您可以堆叠扩展板以添加新功能，例如可信平台模块（TPM）、外部存储器和 JTAG 调试器。\n\n\n\n\n驾驶#\n\nRAMN 可以与开源自动驾驶模拟器 CARLA 构成闭环连接。来自虚拟世界的数值，例如车速和油门控制，会在 CAN/CAN-FD 总线以及 ECU\n内部转化为物理形式。你可以亲自驾驶车辆，也可以让自动驾驶算法来完成这项任务。\n\n\n\n\n可编程#\n\n四个 ECU 均可通过 USB 使用微控制器的内置硬件引导加载程序进行重新编程：无需 JTAG 编程器。\n\n\n\n\n简易布局#\n\nRAMN 仅由设计具有高容差的印刷电路板组成。PCB 只有两层，SMD 元件位于同一侧。所有元件都可以手工焊接，这使得 RAMN 对电子初学者来说很容易上手。\n\n\n\n\n开源构建#\n\n所有 PCB 均采用开源 CAD 工具 KiCad 进行设计。微控制器的固件基于开源 RTOS freeRTOS 和开源库 STM32 HAL。\n\n\n\n\n使用示例#\n\n我们开源 RAMN，以促进汽车系统的教育和研究。RAMN 可用于：\n\n * 在提供电子和汽车系统培训时。\n * 在开发和评估汽车技术时。\n * 用于研究，尤其是在温度和制造公差至关重要的场景。\n * 适用于需要硬件的 CTF 和漏洞赏金计划。\n * 以及更多！\n\n\n\n\n教育#\n\nRAMN 尽可能采用多种流行技术，而不仅仅是 CAN/CAN-FD。扩展板配备了夹式探头，可用于观察重要信号，并支持对模拟电路、SPI、I2C、UART\n等进行研究。\n\n\n\n\n研究#\n\nRAMN\n的尺寸与信用卡相当，价格低廉，非常适合需要大量板卡的场景，例如评估制造公差对某项技术的影响，或者在测试环境中模拟可能导致设备损坏的条件。与常见的开发板不同，真实\n的 ECU 专为应对恶劣的工作环境而设计。RAMN 主要采用汽车级元件，可在-40 至 150\n摄氏度范围内正常工作。虽然微控制器并非汽车级器件，但其工作温度范围也能达到-40 至 125 摄氏度。RAMN 力求在开源性、成本和对真实 ECU\n网络的还原度之间取得平衡。扩展板则并非汽车级产品。CAN/CAN-FD 总线末端配备了一个接线端子，允许您添加其他节点。它可用于 ECU\n的开发与评估。不过存在一个限制：CAN/CAN-FD 总线已进行了终端匹配，因此无法连接到实际车辆中。\n\n\n联系#\n\n请参阅 RAMN Github 仓库的联系人部分。\n\n\n许可证#\n\nRAMN 是开源的，采用宽松许可协议。请查看许可证文件以获取更多信息。","routePath":"/docs/general","lang":"","toc":[{"text":"什么是 RAMN ？","id":"什么是-ramn-","depth":2,"charIndex":3},{"text":"主要特性","id":"主要特性","depth":2,"charIndex":131},{"text":"ECU 网络仿真","id":"ecu-网络仿真","depth":3,"charIndex":139},{"text":"交互","id":"交互","depth":3,"charIndex":233},{"text":"即插即用","id":"即插即用","depth":3,"charIndex":298},{"text":"扩展","id":"扩展","depth":3,"charIndex":394},{"text":"驾驶","id":"驾驶","depth":3,"charIndex":449},{"text":"可编程","id":"可编程","depth":3,"charIndex":571},{"text":"简易布局","id":"简易布局","depth":3,"charIndex":634},{"text":"开源构建","id":"开源构建","depth":3,"charIndex":725},{"text":"使用示例","id":"使用示例","depth":2,"charIndex":809},{"text":"教育","id":"教育","depth":3,"charIndex":951},{"text":"研究","id":"研究","depth":3,"charIndex":1044},{"text":"联系","id":"联系","depth":2,"charIndex":1380},{"text":"许可证","id":"许可证","depth":2,"charIndex":1413}],"domain":"","frontmatter":{"pageType":"doc"},"version":""},{"id":8,"title":"扩展端口","content":"#\n\nECU 扩展端口为一个 26 针插座：\n\n * RAMN 主 PCB 主要使用 M20-7831346 连接器（2.54mm 间距，两排各 13 针）。\n * ECU A 扩展（垂直连接）使用 Amphenol 68021-226HLF 连接器。\n * ECU B、C 和 D 扩展（水平连接）使用 SAMTEC SSQ-113-03-G-D\n   连接器（SSQ-113-23-L-D、SSQ-113-23-F-D、SSQ-113-23-T-D 也应兼容）。\n\n所有 ECU 共享一套通用的硬件外设配置，因此编程更加简便，且发生配置错误的可能性更低。例如，PA1 引脚始终被配置为\nADC。在底盘扩展中，该引脚连接到方向盘电位器；而在动力总成扩展中，则连接到制动电位器。每个扩展都配备了不同的传感器和电路，但 ECU\n仍然共享相同的外设配置。这也意味着二进制输入（如手刹）被当作 ADC 输入处理，而非简单的 GPIO 输入。\n\n\n设计自定义扩展#\n\n您可以使用 SAMTEC SSQ-113-03-G-D 连接器创建可与其他扩展堆叠的新扩展（参见“扩展”部分），但需避免产生冲突。为了快速上手，我们建议您从\nhardware/V1_revB/5_debugger 文件夹中复制调试器扩展，并使用 KiCAD 进行修改。该扩展采用了可堆叠的 SAMTEC\nSSQ-113-03-G-D 连接器，并已包含所有可能的信号——只需删除您不需要的部分即可。\n\n以下引脚由原始 RAMN 扩展主动使用：\n\n * **PA1：**ADC（ECU B、C、D）。\n * **PA4：**ADC（ECU B、C、D）。\n * PA5：ADC（ECU B、C、D）。\n * **PB2：**GPIO 输出，SPI2 通信的 CS 引脚（用于 ECU A 的显示屏，或 ECU D 的 LED 驱动器）。\n * PB12：GPIO 输出，ST7789 显示屏的 DC 引脚（ECU A）或 LED 驱动器的 LE 引脚（ECU D）。\n * **PB13：**SPI2 SCK（ECU A、D）。\n * PB14：SPI2 MISO（ECU A）——目前未使用，但保留以备将来使用。\n * **PB15：**SPI2 MOSI（ECU A、D）。\n\n以下引脚始终空闲，可用于创建与任何 RAMN ECU 兼容的新扩展。部分引脚已为您预配置，方便使用，但您也可以根据需要自由配置：\n\n * **PA2：**空闲，预配置为 LPUART1_TX。\n * **PA3：**空闲，预配置为 LPUART1_RX。\n * **PA6：**空闲。\n * **PA7：**空闲。\n * **PB0：**空闲。\n * **PB1：**空闲。\n * **PB10：**空闲，预配置为 I2C2_SCL。\n * **PB11：**空闲，预配置为 I2C2_SDA。\n * **PA8：**空闲，预配置为额外的 SPI 片选引脚。\n\n尽管 PB13、PB14 和 PB15 已被占用，但 SPI 协议支持复用，因此您也可以将它们用于扩展，但仅限于 SPI 通信。您只需为每个要连接的 SPI\n设备分配一个不CS PIN，并复用已定义的 SPI2 SCK（PB13）、**SPI2 MOSI（PB15）**和 **SPI2\nMISO（PB14）**引脚。请注意，对于 ECU A 和 D，您需要共享 SPI 带宽，但可以将原有扩展的带宽限制到最低水平。\n\n如果您在选择引脚时需要帮助，请阅读“创建新扩展”部分。有关引脚功能，请参阅 STML552 数据手册（表 21）。通常，您可以使用以下接口：\n\n * LPUART1（UART 接口）。\n * I2C2（I2C 接口，主设备或从设备）。\n * SPI2（SPI 接口。在 ECU A 和 D 上，必须与现有应用共享总线）。\n * OCTOSPI1（非普通 SPI，而是一种通常用于外部闪存的接口）。\n * ADC（模数转换器）\n * Timers/PWM（输入或输出）。\n * GPIO（输入或输出）。\n * External interrupts。\n\n警告\n\n尽管大多数接口可以同时使用，但仍存在一些冲突，因此请务必检查兼容性问题（参见创建新扩展）：\n\n * OCTOSPI1 不能与 I2C2 同时使用。\n * 对于 ECU A 和 D，SPI2 只能以主模式使用。\n * 如果希望在 ECU A 上使用（目前未使用的）SD 卡读卡器，则需要将 PB10 用作 SD 卡的 SPI 片选引脚。\n\n如果可用引脚不足，可以考虑制作仅兼容单一 ECU 的扩展板（例如，您可以制作一个重新分配 PA1、PA2 和 PA5 的扩展板，但该扩展板仅与 ECU A\n兼容，且您需要为 ECU A 采用不同的外设配置）。\n\n警告\n\n请避免从 3V3 引脚汲取超过几毫安的电流，因为该引脚直接连接到 ECU 的电源，而 ECU 的电源容量有限。相反，应从 5V 引脚获取电源，该引脚直接连接到\nUSB 5V 线路。\n\n\n引脚排列#\n\n扩展端口的引脚排列如下所示。\n\nECU 扩展端口连接\n\n所有 ECU 的引脚排列相同，但根据其在电路板上的位置，引脚方向有所不同。请参考以下 KiCAD 截图，以确保引脚方向正确。\n\nECU A 扩展端口布局\n\nECU B 扩展端口布局\n\nECU C 扩展端口布局\n\nECU D 扩展端口布局","routePath":"/docs/hardware/expansions","lang":"","toc":[{"text":"设计自定义扩展","id":"设计自定义扩展","depth":2,"charIndex":419},{"text":"引脚排列","id":"引脚排列","depth":2,"charIndex":2111}],"domain":"","frontmatter":{},"version":""},{"id":9,"title":"固件刷写","content":"#\n\nRAMN 共有四个 ECU，每个 ECU 需要不同的固件文件（ECUA.hex、ECUB.hex、ECUC.hex 和 ECUD.hex）。RAMN 所采用的\nSTM32 微控制器内置了 USB/CAN 启动加载程序，因此您无需特殊工具即可为全新（未编程）的板卡进行固件刷写。具体操作说明请参阅“刷写脚本”部分。\n\n\n接口#\n\n固件文件可通过以下三种接口之一进行刷写：\n\n * STM32 内置启动加载程序接口（USB）：RAMN ECU 所使用的 STM32L5\n   微控制器具备两种启动模式：应用模式和启动加载程序模式。在启动加载程序模式下，微控制器可通过 USB 和 CAN-FD 接受多种刷写命令。该接口对所有\n   ECU 均可通过 USB 访问，即使是在全新的（未编程的）RAMN 板卡上也是如此。\n * 硬件接口（JTAG）：此接口适用于所有 STM32 微控制器。它可以与诸如 ST-LINK/V2 之类的 JTAG\n   调试器配合使用，也可用于尚未编程的全新电路板。\n * UDS 接口（USB、CAN）：该接口仅在具备有效固件且拥有两个存储器分区的 ECU 上可用（微控制器型号后缀为“CET6”）。\n\nUDS 接口的具体使用方法详见 UDS 用户指南。其他接口的说明请参阅本页面。\n\n\n重要知识#\n\n * ECU A 负责控制 ECU B、C 和 D 的电源及启动模式。必须首先对 ECU A 进行刷写，否则 ECU B、C 和 D 将无法供电。\n * ECU B 配备了一个方向盘电位计，该电位计可能是“线性”或“算法型”，具体取决于部件的可用性。如果方向盘居中时 LCD 屏幕未显示“STEER\n   0%”，则表示您必须用“ECUB_LINEAR.hex”替换“ECUB.hex”（只需删除 ECUB.hex，并将 ECUB_LINEAR.hex\n   重命名为 ECUB.hex）。\n * 当您通过 UDS 接口对 ECU\n   进行重新编程时，新固件实际上会被写入到不同的存储器分区，并且微控制器的选项字节会被设置为使该存储器分区成为新的应用固件（存储器分区切换）。某些工具，包括\n   ST 官方工具，可能无法识别这种存储器切换，从而导致错误。如果出现这种情况，请通过 UDS 对 ECU 进行重新刷写，以恢复到另一个“默认”存储器分区 [\n   1 ]。\n * ECU A 与 ECU B、C 和 D 的选项字节不同。如果您不小心使用了 ECU A 的固件文件对 ECU B、C 或 D\n   进行刷写，它们将不再接受进入引导加载程序模式 [ 2 ]。\n * 您可以按照“控制功能测试”中的说明，验证您的电路板是否完全正常工作。\n * 如果遇到问题，请务必检查预期的选项字节（故障排除），并排查常见问题（参见“USB 不稳定”）。\n\n\nSTM32 嵌入式引导加载程序接口#\n\n\n工作原理#\n\n设计#\n\nSTMicroelectronics 的 AN2606 文档详细说明了 STM32 微控制器的启动方式。RAMN 使用的是 STM32L5\n微控制器。默认情况下，STM32L5 在启动时如果 BOOT0 引脚为高电平，则会进入引导加载程序模式。这种行为可以通过编程 STM32L5\n的选项字节来覆盖，从而使用存储器中写入的值，而非 BOOT0 引脚的状态。\n\nECU A 的 BOOT0 引脚在硬件上被设置为高电平。因此，全新未编程的板子将始终以引导加载程序模式启动，并通过 USB\n监听引导加载程序命令，包括内存刷写命令（即 AN3156 中详细描述的 DFU 命令）。\n\nECU A 的固件配置为设置其自身的选项字节，以便在后续所有启动中忽略 BOOT0 引脚。因此，只要 ECU A 至少执行过一次有效固件，无论其 BOOT0\n引脚的状态如何，都将进入应用程序模式启动。\n\nECU A 的设置可通过特定的 USB 或 UDS 命令重置，相关命令已列在命令列表中。当执行该命令时，ECU A\n会恢复其选项字节并自行复位，强制进入引导加载程序模式。\n\nECU B、C 和 D 的 BOOT0 引脚及电源由 ECU A 控制。ECU B、C 和 D 始终根据 BOOT0 引脚的状态进行启动。因此，ECU A\n可以隔离特定的 ECU，并强制其进入引导加载程序模式，从而允许用户通过 CAN-FD 发送 STM32 引导加载程序命令（参见 AN5405）。\n\n刷写流程#\n\n您只需通过 USB 连接即可为所有 ECU 进行刷写。刷写流程如下：\n\n 1. 将 ECU A 的选项字节复位，以强制 ECU A 进入引导加载程序模式（新板可跳过此步骤）。\n 2. 使用 DFU 工具通过 USB 为 ECU A 刷写固件。\n 3. 使用 ECU A 借助“canboot.py”Python 工具为 ECU B、C 和 D 刷写固件。该工具可将 USB 命令转换为 CAN-FD\n    命令。\n\n\n刷写脚本#\n\nGithub 仓库中包含多种用于刷写 RAMN 的 ECU 的脚本。您首先需要在 Linux 或 Windows 系统上准备好您的环境。\n\nWindows 环境#\n\n 1. 安装 STM32CubeProgrammer。这需要您在意法半导体注册一个免费账户。如果后续遇到问题，可尝试安装位于“Program\n    Files/STMicroelectronics/STM32Cube/STM32CubeProgrammer/Drivers”中的驱动程序（说明请见此处\n    ）。\n\n 2. 安装适用于 Windows 的最新 Python 版本。请务必勾选“将 Python 添加到环境变量”。\n\n 3. 将 RAMN 仓库下载到您的计算机上（选择“代码”>“下载 ZIP 文件”）。\n\n 4. 在 RAMN/scripts 文件夹中打开命令提示符（您可以通过文件资源管理器打开 RAMN/scripts\n    文件夹，然后在顶部地址栏输入“cmd”来实现），并输入：\n    \n    \n\n 5. （如需）编辑 scripts/STbootloader/windows/ProgramECU_A.bat 脚本，并将 STM32PROG_PATH\n    修改为与您的安装路径相匹配。\n\nLinux 环境#\n\n 1. 安装 dfu-util：\n    \n    \n\n 2. 克隆 RAMN 的仓库：\n    \n    \n\n 3. 安装 requirements.txt 中的模块：\n    \n    \n\n警告\n\n在较新的发行版中，您可能会遇到 error: externally-managed-environment 的错误。您可以执行以下命令以防止该错误再次发生：\n\n\n\n您可以在此处找到更多详细信息。\n\n请注意，如果您使用虚拟机，RAMN 串口和 RAMN DFU 端口将被视为不同；您需要将两者都转发到您的虚拟机。\n\n脚本#\n\nSTM32 嵌入式引导加载程序接口需要更改 CAN 波特率。如果存在，您必须断开可能干扰它的外部 CAN 工具。请确保您使用的是 USB\n数据线，而不是仅用于供电的 USB 数据线。然后，请按照以下说明操作：\n\n 1. 打开文件夹 scripts/STbootloader/windows 或 scripts/STbootloader/linux。\n 2. 如果板子未处于 DFU 模式（例如，并非全新板子），请运行 ECUA_OptionBytes_Reset.bat（在 Linux 上为\n    ECUA_OptionBytes_Reset.sh）。\n 3. 运行 ProgramECU_A.bat（在 Linux 上为 ProgramECU_A.sh）以烧录 ECU A。此过程大约需要 5 秒钟。\n 4. 运行 ProgramECU_BCD.bat（在 Linux 上为 ProgramECU_BCD.sh）以烧录 ECU B、C 和 D。此过程大约需要\n    30 秒钟。\n\n警告\n\n截至 2024 年，意法半导体提供的 DFU 工具在某些计算机上表现不佳。您可能需要连续多次运行脚本，直到成功为止。尝试更换计算机上的不同 USB 端口或使用\nUSB 集线器可能会有所帮助。程序成功时应以绿色显示“Start operation achieved successfully”。如果遇到过多问题，可尝试改用\nLinux 下的 dfu-util 工具。若编程失败，请勿手动更新 Option Bytes。\n\n\nJTAG 硬件接口#\n\n您还可以使用 ST-LINK/V2 工具对 ECU 进行重新编程和调试。理论上，您应该能够使用其他兼容 STM32 的硬件或软件对 ECU\n进行重新编程和调试；不过，我们尚未对此进行过测试。\n\n通过 JTAG 接口，您一次只能为一个 ECU 刷写固件，因此需要针对每个 ECU 重复固件刷写步骤。务必确保先对 ECU A 进行编程，否则可能导致其他\nECU 无法正常供电。\n\n\n准备您的环境#\n\n 1. 获取一个 ST-LINK/V2。请注意市面上存在一些克隆产品，这些产品可能不受 ST 官方支持。\n\n 2. 获取一个 RAMN 调试器扩展模块，或者准备跳线，以便手动连接到 RAMN ECU。\n\n 3. 安装STM32CubeProgrammer。\n\n\n连接您的调试器#\n\n如果您拥有一款带有 JTAG 接口的 RAMN 调试器扩展板，只需将其插入您希望重新编程的 ECU 的扩展端口即可。扩展板的正确方向应确保其不会覆盖主 RAMN\n板（插入扩展板后，您仍应能够看到 ECU 微控制器）。\n\n如果您没有 RAMN 调试器扩展板，请使用跳线将 ST-LINK/V2 的引脚连接到您希望重新编程的 ECU 的扩展端口：\n\n * 将 ST-LINK/V2 的第 1 和第 2 引脚（VCC）连接至扩展端口的第 1 引脚（3V3_ECU）。\n * （可选）将 ST-LINK/V2 的引脚 3（TRST）连接至扩展端口的引脚 26（SYS_JTRST）。\n * 将 ST-LINK/V2 的引脚 4（GND）连接至扩展端口的引脚 4（GND）。\n * 将 ST-LINK/V2 的引脚 5（TDI）连接至扩展端口的引脚 23（SYS_JTDI）。\n * 将 ST-LINK/V2 的引脚 7（TMS_SWDIO）连接至扩展端口的引脚 22（SYS_JTMS-SWDIO）。\n * 将 ST-LINK/V2 的引脚 9（TCK_SWCLK）连接至扩展端口的引脚 24（SYS_JTCK-SWCLK）。\n * 将 ST-LINK/V2 的引脚 13（TDO_SWO）连接至扩展端口的引脚 25（SYS_JTDO-SWO）。\n * 将 ST-LINK/V2 的引脚 15（NRST）连接至扩展端口的引脚 21（nRST）。\n\n有关连接的详细信息，请参阅 ST-LINK/V2 手册及扩展端口的引脚分配图。\n\n\n使用STM32CubeProgrammer#\n\n连接#\n\n在STM32CubeProgrammer中启动，从右上角菜单中选择“ST-LINK”，然后点击“连接”。您可能会首先收到调试器固件更新的提示。如果连接失败，请尝\n试使用与下方截图中相同的设置。此外，还可以先将“共享：启用”设置为启用状态，然后再点击串口下拉框旁边的刷新（🔁）按钮。\n\n\n\n（可选）验证选项字节#\n\n如果您不确定 ECU 的状态，尤其是因为曾与 UDS 重新编程或内存保护功能进行过交互，建议您验证选项字节的状态。在左侧窗格中选择“OB”图标，并确认以下内容：\n\n * 读出保护 > RDP 显示为“AA”。\n * 用户配置 > SWAP_BANK 未被勾选。\n * （针对 ECU A）用户配置 > nSWBOOT0 未勾选，nBOOT0 已勾选。\n * （针对 ECU B、C 和 D）用户配置 > nSWBOOT0 已勾选（此处 nBOOT0 无关紧要）。\n\n有关正确配置的截图，请参阅故障排除部分。如果这些选项字节中有任何一项不正确，请予以修正并点击“应用”按钮。此命令失败的情况并不少见，因此您可能需要多次重试。请务\n必谨慎操作“RDP”选项字节，因为如果应用了非“AA”的值，可能会导致您的 ECU 永久锁定。\n\n重新刷写#\n\n * 单击左侧窗格中的“擦除与编程图标”（从顶部数第二个图标）。\n * （可选）单击“全芯片擦除”（窗口右上角），以完全擦除内存（包括内部 EEPROM，其中包含 VIN 和 DTC）。\n * 单击“浏览”，选择固件文件（适用于您 ECU 的.hex 文件），勾选“验证编程”和“编程后运行”，然后单击“开始编程”。\n * 等待刷写过程完成。\n\n对您想要重新编程的每个 ECU 重复上述步骤。\n\n脚注\n\n[ 1 ]：#\n\nRAMN 自定义的 UDS 常规控制 0x0211 可用于强制进行内存分区交换，但请务必在清楚自身操作的情况下再使用。\n\n[ 2 ]：#\n\n您可以通过 JTAG 调试器修复选项字节。您可以使用 UDS 常规控制 0x0210 来重置 BOOT0 选项字节。此 UDS 命令会强制 ECU A\n进入引导加载程序模式，因此您需要对其进行重新编程。","routePath":"/docs/hardware/flashing","lang":"","toc":[{"text":"接口","id":"接口","depth":2,"charIndex":161},{"text":"重要知识","id":"重要知识","depth":2,"charIndex":558},{"text":"STM32 嵌入式引导加载程序接口","id":"stm32-嵌入式引导加载程序接口","depth":2,"charIndex":1190},{"text":"工作原理","id":"工作原理","depth":3,"charIndex":1211},{"text":"设计","id":"设计","depth":4,"charIndex":1218},{"text":"刷写流程","id":"刷写流程","depth":4,"charIndex":1852},{"text":"刷写脚本","id":"刷写脚本","depth":3,"charIndex":2069},{"text":"Windows 环境","id":"windows-环境","depth":4,"charIndex":2146},{"text":"Linux 环境","id":"linux-环境","depth":4,"charIndex":2623},{"text":"脚本","id":"脚本","depth":4,"charIndex":2892},{"text":"JTAG 硬件接口","id":"jtag-硬件接口","depth":2,"charIndex":3557},{"text":"准备您的环境","id":"准备您的环境","depth":3,"charIndex":3758},{"text":"连接您的调试器","id":"连接您的调试器","depth":3,"charIndex":3898},{"text":"使用STM32CubeProgrammer","id":"使用stm32cubeprogrammer","depth":3,"charIndex":4570},{"text":"连接","id":"连接","depth":4,"charIndex":4594},{"text":"（可选）验证选项字节","id":"可选验证选项字节","depth":4,"charIndex":4744},{"text":"重新刷写","id":"重新刷写","depth":4,"charIndex":5120}],"domain":"","frontmatter":{},"version":""},{"id":10,"title":"","content":"本页面提供了关于 RAMN 硬件的详细信息。如果您需要帮助设计自己的硬件扩展，请查看“创建新扩展”部分。\n\n * 概述\n   * CAD软件\n   * 设计\n   * 硬件设计规范\n * 扩展端口\n   * 设计自定义扩展\n   * 引脚排列\n * PCB 订购\n   * 参数\n   * 订购数量少于五（5）件\n   * 附加组件\n   * 生产说明\n   * 替代组件\n * 固件刷写\n   * 接口\n   * 重要知识\n   * STM32 嵌入式引导加载程序接口\n   * JTAG 硬件接口\n * 质量检查\n   * 流程\n   * 故障排除\n * 原理图详情\n   * ECUs\n   * CAN/CAN-FD 总线\n   * USB\n   * 屏幕（网关/信息娱乐）\n   * 底盘\n   * 动力总成\n   * 车身\n   * 调试器","routePath":"/docs/hardware/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":11,"title":"PCB 订购","content":"#\n\n提醒\n\n目前我虽然翻译了全部文档，但由于我不是硬件/电子领域人员，许多PCB的知识我是不懂的。订购时许多术语和选项完全不懂，而且代工厂 制板+组装\n价格高昂，所以我未成功制作。\n\n这里的订购是在国外平台 PCBway\n进行的，这个平台是国内公司“捷多邦”旗下的，主要面向海外市场，但它也可在官网给国内用户制板。国内类似平台还有“嘉立创”、“华秋”。\n\n下单页面大同小异，不过有的代工厂缺少RAMN的许多材料。\n\n正在开发中的 RAMN 硬件版本（在主分支上）旨在便于制造和降低成本。原始的 RAMN 版本已存档，并可在 misc\n文件夹中找到。此存档版本使用了一些难以从交钥匙制造服务中获取的部件，以及对 RAMN 用户而言成本效益不高的部件。\n\n * 如果您的目标是廉价且轻松地制作 RAMN，请使用本页面上的信息。\n * 如果你的目标是获取完全相同的原始硬件（例如用于学术研究），请下载 RAMN_V1_reference_PCB.zip 并将其发送至 PCB 组装打样服务。\n\n警告\n\n本页面仅提供便利。我们无法保证您的订单质量。\n\n\n\n设计文件已足够完整，你可以通过任何 PCB 打样服务自行制造和/或组装你的 RAMN 及其扩展模块。\n\n为方便起见，可通过 PCBWay 进行两次“返单”，以获得属于你自己的 RAMN：\n\n 1. 主板。\n 2. 扩展模块（不包括可选的调试器扩展）。\n\n主板本身即可用于多种应用，但若要更改模拟车辆状态，例如在 CARLA 中驾驶汽车，则需要购买扩展模块。\n\n在 PCBWay，您有两种采购选项：\n\n * PCB + 组装：您将收到已焊接好元器件的 PCB（见下图）。\n * 仅 PCB：您需自行订购 BOM 中的元器件并进行焊接（价格更低的选项）。\n\n来自PCBway的主板\n\n来自PCBway的扩展面板\n\n上述订单中使用的物料清单经过定制，以匹配 PCBWay 可提供的元器件，并且移除了部分元件（标记为 DNP），以降低成本（例如测试点）。\n\n警告\n\nPCBWay 的重新订购使用了 STM32L562CET6 微控制器。这些微控制器配备了硬件加密引擎，因此可能受到进出口限制。如果这些限制适用于您，应申请将\nSTM32L562CET6 替换为 STM32L552CET6，后者是同一款微控制器，但不带加密引擎（参见微控制器选型）。RAMN 的固件并未使用该加密引擎。\n\n\n参数#\n\n您应保留大部分默认参数：\n\n * FR4 材料\n * 2 层\n * 1.6 毫米厚度\n * 1 盎司（35 微米）铜\n\n您应能选择任意表面处理工艺，但我们建议避免使用含铅的方案。“无铅热风整平”通常是不含铅的最经济方案，但可能会随时间出现变色。我们通常采用“沉金（ENIG）”，尚\n未亲自尝试过其他表面处理工艺。\n\n“阻焊层”对应于电路板的颜色，“丝印”则对应于文字和线条的颜色。您可以自由选择任何颜色，但需确保有足够的对比度以便阅读文字（例如，不要选择白色阻焊层搭配白色丝印\n）。\n\n在使用 PCBWay 时，我们建议您为阻焊层选择以下颜色之一：绿色、红色、黄色、蓝色、紫色或哑光绿色。如果您选择了黑色、白色或哑光黑色阻焊层，PCBWay\n可能会提醒您，RAMN 的阻焊层约束条件无法满足（微控制器引脚与 USB 连接器引脚之间的阻焊层间距为 0.20mm，但 PCBWay 要求至少为\n0.22mm）。如果您仍希望使用这些颜色，通常可以要求 PCBWay 忽略该问题，或者由他们自行移除存在问题的阻焊层。不过，这样做会略微增加焊接问题发生的概率。\n\n注意\n\n为避免制造问题，建议您按照订单详情中的元件方向部分内容进行复制。\n\n\n订购数量少于五（5）件#\n\nPCBWay 订购系统可能会显示必须订购 5 个或更多 RAMN；然而，只有（裸）PCB 才需要至少订购 5 个。您可以仅订购 1\n块组装好的主板和/或扩展面板。如果您只需 1 个 RAMN，可以在 PCB 数量中设置为“5”，在组装数量中设置为“1”，如下面截图所示。\n\n\n\n您订购的板卡数量越多，单价就越便宜。如果您订购 5 套已组装的 RAMN 设备，预计每套完整 RAMN 设备的成本约为 210 美元（假设采用绿色阻焊层和\nENIG 表面处理，且不含可选的调试器扩展模块）。然而，如果您仅订购一套，成本则会升至 430 美元。而如果您订购 100 套，成本则降至约 140 美元。\n\n\n附加组件#\n\n以下组件未包含在 PCBWay 订单中，因为它们并非绝对必需。如果您需要这些组件，请考虑向 PCBWay 提出申请，或自行单独订购：\n\n * 1 根 Micro Type B USB 数据线：任意品牌均可，但请避免仅支持供电的线缆。\n * 1 个接线端子（用于外部 CAN/CAN-FD 工具）：菲尼克斯电气 1770966。\n * 测试探针：Vero Technologies 20-313143（根据实际需求准备相应数量）。\n * 1 个方向盘电位器旋钮：Davies Molding 1231-M。\n * 4 个六角垫片：Keystone 24313（公头）和 Keystone 24390（母头）（共 8 个）。\n\n只有接线端子需要焊接。请注意，原 RAMN 中使用的 Davies Molding 1300-F 旋钮与 PCBWay 当前订单不兼容。\n\n\n生产说明#\n\n\n元件方向#\n\n您可以通过上述图片或原理图详情页面来确定每个元件的正确方向。\n\n警告\n\n尽管丝印标记可指示每个元件的正确方向，但以下两个元件容易被代工厂焊反，因此需要格外注意：\n\n * SW1（Shift 操纵杆）：凹槽应位于丝印文字“SHIFT”的另一侧（在上方图片中几乎难以辨认）。\n * SW3（照明开关）：旋钮上的缺口应位于针脚排一侧（见上图）。该开关共有四种可能的位置；如果图片中显示缺口与针脚排平行，则缺口应位于手刹开关的另一侧。\n\n以下是根据晶圆厂以往问题作出的澄清：\n\n * D8 在 4 身板 PCB 上的方向如 PCB 丝印右下角图形所示（所有 LED 的方向相同：K 向上，A 向下）。D8\n   底部附近的圆点仅为装饰，并不表示阴极。\n * Y1、Y2、Y3、Y4 没有方向性（尽管它们的封装形状不寻常，但实际上是无源晶体）。\n\n\nBOM 元件参考#\n\n扩展板（从 1_screens 到\n5_debugger）使用不重叠的元件参考，可以轻松地拼版在一起。主电路板（0_ramn）上的元件参考与扩展板存在重叠，因此某些制造厂可能会因此拒绝拼版。\n\n\n过往问题的注意事项#\n\nECU A 的屏幕（BOM 中的 external-1）较为脆弱，需要小心 handling 和包装。\n\n我们过去曾遇到过电位器（RV1 和 RV2）焊接不良导致的生产问题。同样地，我们也曾出现过一次罕见的\nSW2（OS102011MA1QN1）缺陷，这很可能也是由于焊接不良所致。此外，我们还收到一份报告，指出底盘扩展板上的 SW3 被错误方向焊接。\n\n因此，这些组件在焊接和质量检查过程中需要特别关注。\n\n\n替代组件#\n\n组件的可用性和成本可能会有所不同。\n\n * RK09D1110C0R 可能不易获得。RK09K1110B26 和 RK09K1110A2S 是可接受的替代方案，但可能需要进行小幅调整，以防止旋钮撞击\n   PCB 的边缘。此外，这可能导致旋钮更容易脱落。\n * SSQ-113-23-G-D 可以替换为 SSQ-113-23-L-D、SSQ-113-23-F-D 或 SSQ-113-23-T-D。它们也可以被\n   4UCON TECHNOLOGY 18507 替换，但后者的引脚较软，更容易发生弯曲。\n * LED 可以替换为 SML-D12P8WT86、SML-D12D1WT86 和 SML-D12V1WT86（具体取决于颜色）。如果您使用其他\n   LED，请确保其标称电流相近。","routePath":"/docs/hardware/ordering","lang":"","toc":[{"text":"参数","id":"参数","depth":2,"charIndex":1014},{"text":"订购数量少于五（5）件","id":"订购数量少于五5件","depth":2,"charIndex":1535},{"text":"附加组件","id":"附加组件","depth":2,"charIndex":1847},{"text":"生产说明","id":"生产说明","depth":2,"charIndex":2237},{"text":"元件方向","id":"元件方向","depth":3,"charIndex":2245},{"text":"BOM 元件参考","id":"bom-元件参考","depth":3,"charIndex":2622},{"text":"过往问题的注意事项","id":"过往问题的注意事项","depth":3,"charIndex":2731},{"text":"替代组件","id":"替代组件","depth":2,"charIndex":2949}],"domain":"","frontmatter":{},"version":""},{"id":12,"title":"概述","content":"#\n\n\nCAD 软件#\n\nPCB 采用 KiCAD 进行设计，KiCAD 是一款用于 PCB 设计的开源工具。设计文件可在 Github 仓库的 hardware/V1_revB\n文件夹中找到：\n\n * 0_ramn 包含 RAMN 主 PCB 的设计数据。\n * 1_screens 至 5_debuggers 包含 RAMN 扩展模块的设计数据。\n\nKiCAD 中 RAMN 的 PCB CAD 视图\n\nKiCAD 中 RAMN 的 3D 视图\n\n\n设计#\n\nRAMN 的主控板是一块信用卡尺寸的 PCB，配备 4 个 ECU、一个 CAN FD 总线和一个 USB 接口。\n\nRAMN 的主控板\n\nRAMN 的主控板可通过扩展板进行功能扩展，以添加诸如传感器和执行器等功能。\n\n使用 4 个扩展模块简单配置 RAMN：SCREENS（网关)、CHASSIS、POWERTRAIN、BODY。\n\n\nECU（电子控制单元）#\n\nRAMN 上共有 4 个 ECU（ECU A、ECU B、ECU C 和 ECU D），它们均采用相同的设计：\n\n * 独立供应电源\n * 一个微控制器\n * 一个 CAN FD 收发器\n * 一个扩展端口\n\nECU A 还配备了一个 USB 接口。该 USB 端口是整个电路板的主要 5V 电源，同时也用于对所有 ECU 进行重新编程。ECU A 拥有 6 个\nGPIO 引脚，用于控制：\n\n * ECU B、ECU C 和 ECU D 的电源\n * ECU B、ECU C 和 ECU D 的引导模式（BOOT0 引脚）\n\nECU D 配备了一个额外的分流电阻以及夹式探头，以方便进行测量。\n\n\nCAN/CAN FD 总线#\n\nRAMN 配备了一条 CAN FD 总线，用于连接这 4 个 ECU，并且总线两端均采用 120 欧姆分压终端。\n\n默认情况下，RAMN 仅使用经典 CAN 报文，并可与经典 CAN 控制器配合使用。\n\nCAN FD 总线还配备了分流电阻和夹式探头，以方便进行测量。\n\nCAN FD 总线可通过端子排从外部访问。\n\n\n框图#\n\nRAMN 主板的简单框图。\n\nRAMN 的框图，显示了 ECU 之间的连接\n\n\n硬件设计规范#\n\n\n指南#\n\nRAMN 致力于推动汽车系统领域的教育与研究。为了贴近汽车电子的实际应用，我们在 ECU 网络板中采用了 AEC-Qxxx 等级\n0（或同等水平）的元器件。为使电路板尺寸更小且成本更低，省略了许多保护措施（例如 ESD\n防护、上拉/下拉电阻等），因此该电路板无法达到安全关键系统所要求的可靠性水平。\n\nRAMN PCB 正面在焊接元器件之前的实物图\n\nRAMN PCB 背面尺寸图，元件焊接前\n\n所有电路板均采用双层设计，所有元件均位于同一侧。这些电路板具有较大的制造公差（例如较大的走线宽度和间距），并且我们仅选用外部引脚可见的元件，除非确实没有可行的替\n代方案。所有这些因素确保了 PCB 能够以低成本进行制造和组装。此外，该电路板也便于希望自行制作和焊接的爱好者使用。\n\nRAMN 的 PCB 设计公差\n\n\n阻抗匹配#\n\n由于 RAMN 中涉及的频率相对较低，因此适当的阻抗匹配并非高优先级事项。不过，在可能的情况下仍遵循了良好的设计规范。\n\nCAN/CAN-FD 总线#\n\n尽管 CAN/CAN-FD 总线的质量受到紧凑布局、大量连接以及仅使用两层布线的限制，但我们仍努力将 CAN-FD 总线的差分阻抗保持在 120\n欧姆。具体而言，我们采用了 0.45 毫米的走线宽度和 0.2 毫米的间距，根据 EEWeb 的边缘耦合微带线阻抗计算工具，这种配置应在标准 35\n微米铜厚、1.6 毫米 FR-4 板材上实现约 120 欧姆的差分阻抗。\n\nCAN-FD 总线布局\n\nUSB#\n\n对于 USB 线路，未尝试阻抗匹配。相反，我们遵循 FTDI 关于 USB 硬件设计的建议：\n\n * D+和 D-等长\n * D+和 D-下方设置接地层\n * 等等\n\nUSB 连接的布局","routePath":"/docs/hardware/overview","lang":"","toc":[{"text":"CAD 软件","id":"cad-软件","depth":2,"charIndex":3},{"text":"设计","id":"设计","depth":2,"charIndex":226},{"text":"ECU（电子控制单元）","id":"ecu电子控制单元","depth":3,"charIndex":400},{"text":"CAN/CAN FD 总线","id":"cancan-fd-总线","depth":3,"charIndex":714},{"text":"框图","id":"框图","depth":3,"charIndex":889},{"text":"硬件设计规范","id":"硬件设计规范","depth":2,"charIndex":934},{"text":"指南","id":"指南","depth":3,"charIndex":944},{"text":"阻抗匹配","id":"阻抗匹配","depth":3,"charIndex":1306},{"text":"CAN/CAN-FD 总线","id":"cancan-fd-总线-1","depth":4,"charIndex":-1},{"text":"USB","id":"usb","depth":4,"charIndex":1588}],"domain":"","frontmatter":{},"version":""},{"id":13,"title":"质量检查","content":"#\n\n本页面描述了验证电路板是否正确烧录并正常工作的步骤。如果您在以下任何步骤中遇到问题，请参阅故障排除部分。\n\n开始之前，请确保您已按照刷写脚本的说明，使用最新固件对电路板进行了烧录。\n\n\n流程#\n\n\n步骤 1：组装并验证启动后的 LED 状态#\n\n请确保电路板按照下图所示进行组装。将所有执行器置于图示位置（中立位置）。拔下 USB 电缆，然后再重新插入以给电路板供电。请确认所有 LED 灯（位于 B\n方框内）会亮起约三秒钟，随后全部熄灭。\n\n\n\n\n步骤 2：验证屏幕上的数据#\n\n可通过 ECU A\n的屏幕检查每个执行器的状态。请确认屏幕底部显示的数据与下图一致。屏幕颜色随机，每次上电时可能有所不同。“STEER”显示转向电位计的状态（位于 E 方框内），L\n代表左转，R 代表右转。当处于中立位置时，其数值应在“L 5%”和“R 5%”之间。\n\n\n\n\n步骤 3：验证 CAN 总线流量#\n\n将 H 方框中的 SHIFT 操纵杆向右推动，然后松开。请确认 B 方框中的 LED D2\n现在开始闪烁。同时，请确认屏幕显示的数据与下图类似。主屏幕应充满字母和数字。\n\n\n\n\n步骤 4：测试手刹#\n\n将手刹（位于 C 方框内）向上移动。确认屏幕底部现在显示“SB”。\n\n\n步骤 5：测试前照灯#\n\n将大灯开关（位于 D 方框内）从最左位置移至最右位置。在切换开关位置时，屏幕底部应依次显示“CL”、“LB”，然后是“HB”。\n\n\n步骤 6：测试底盘#\n\n将底盘电位器（位于 E 方框内）移至最左位置，并确认此时“STEER”显示为“L100%”。将其移至最右位置，并确认显示为“R100%”。\n\n\n步骤 7：测试刹车和油门#\n\n将制动器和加速器电位器（位于 F&G 方框内）全部调至最高位置。确认屏幕现在显示制动“BRAK”和“ACCL”的数值为“98%”（或高于 95%的值）。\n\n\n步骤 8：测试发动机钥匙#\n\n将发动机钥匙（位于 A 方框内）从左侧拨至中间，再拨至中央位置。确认屏幕右下角的文字依次从“OFF”变为“ACC”，再变为“IGN”。\n\n\n步骤 9：测试 SHIFT 摇杆#\n\nSHIFT 操纵杆有 5 个位置（不包括松开状态）：左按、右按、上按、下按和中心按。\n\n分别保持这些位置，并确认屏幕底部依次显示“LT”、“RT”、“UP”、“DW”和“MD”。（使用左右键时，您将在不同屏幕之间切换。如果您进入了一个没有底部文字的\n屏幕，请尝试切换到其他屏幕。）\n\n\n故障排除#\n\n如果转向电位器居中时未显示 0%，则可能是刷入了错误的固件（参见固件刷写）。您可以通过使用替代固件（很可能是线性替代对数）为 ECU B 重新刷写来解决此问题。\n\n如果执行器能够响应，但显示的数值有误（例如，当您向下按 SHIFT 操纵杆时，屏幕却显示“UP”），则您的电路板可能需要校准。请联系我们以获取帮助。\n\n请确保移除外部 CAN 适配器（如有）。\n\n如果您在上述任一步骤中失败，可能是由于电路板固件刷写不当所致。请按照刷写脚本的说明重新刷写电路板。如果可能，还请验证选项字节（参见章节（可选）验证选项字节）。正\n确刷写后，电路板应显示为一个串行设备（Windows 下的 COM 端口，Linux 下的/dev/ttyACMx），而不会显示为“DFU in FS\n模式”设备或仅供电的设备。\n\n如果您确定主板已正确刷新，那么可能是连接不良（可通过目视检查识别）或元件故障（建议尝试重新焊接或更换）。如有需要，请随时联系我们寻求帮助。","routePath":"/docs/hardware/qualitycheck","lang":"","toc":[{"text":"流程","id":"流程","depth":2,"charIndex":95},{"text":"步骤 1：组装并验证启动后的 LED 状态","id":"步骤-1组装并验证启动后的-led-状态","depth":3,"charIndex":101},{"text":"步骤 2：验证屏幕上的数据","id":"步骤-2验证屏幕上的数据","depth":3,"charIndex":227},{"text":"步骤 3：验证 CAN 总线流量","id":"步骤-3验证-can-总线流量","depth":3,"charIndex":381},{"text":"步骤 4：测试手刹","id":"步骤-4测试手刹","depth":3,"charIndex":489},{"text":"步骤 5：测试前照灯","id":"步骤-5测试前照灯","depth":3,"charIndex":537},{"text":"步骤 6：测试底盘","id":"步骤-6测试底盘","depth":3,"charIndex":616},{"text":"步骤 7：测试刹车和油门","id":"步骤-7测试刹车和油门","depth":3,"charIndex":700},{"text":"步骤 8：测试发动机钥匙","id":"步骤-8测试发动机钥匙","depth":3,"charIndex":794},{"text":"步骤 9：测试 SHIFT 摇杆","id":"步骤-9测试-shift-摇杆","depth":3,"charIndex":879},{"text":"故障排除","id":"故障排除","depth":2,"charIndex":1041}],"domain":"","frontmatter":{},"version":""},{"id":14,"title":"车身","content":"#\n\nBODY 扩展是与 ECU D 相关联的扩展，通常用于实现汽车 BODY 领域中的两个简单功能：\n\n * 发动机钥匙\n * 车灯\n\n\n\n\n\n\n发动机钥匙#\n\n发动机钥匙具有三个位置，分别对应：\n\n * 发动机关闭\n * 附件\n * 点火\n\n该发动机钥匙由 NKK 开关的 SK14EG13 模拟实现。SK14EG13 是一种 SP3T 开关（单刀三掷）。因此，其原理图相当简单：\n\n发动机钥匙电路示意图\n\n钥匙的旋转会从分压器中选择一个点（位置 1 -> 0V，位置 2 -> 1.65V，位置 3 -> 3.3V），该电压由 ECU 上的 ADC\n进行测量。由于预计用户会操作该钥匙，因此使用了 TVS 二极管进行 ESD 防护。\n\n\n灯光#\n\n灯光由 8 个 LED（D1~D8）模拟，这些 LED 位于靠近丝印标记的位置，其图案类似于仪表盘上的符号：\n\n * 左转向指示灯（D1 - 输出 6）\n * 右转向指示灯（D2 - 输出 7）\n * 尾灯（D3 - 输出 3）\n * 近光灯（D4 - 输出 4）\n * 远光灯（D5 - 输出 5）\n * 电池警告（D6 - 输出 0）\n * 检查发动机（D7 - 输出 1）\n * 驻车制动（D8 - 输出 2）\n\n灯光电路原理图\n\nLED 由 STP08CP05 集成电路驱动。STP08CP05 是一种由简单移位寄存器电路控制的 LED 驱动器。实际应用中，STP08CP05 由 ECU\nD 的 SPI 输出控制，并与其他 SPI 设备进行多路复用。通过外部探针可轻松访问 SPI 信号。\n\n通信电压为 3.3V，但 LED 由 5V 电源供电。R15 用于设定电流（约 10mA）。\n\n输出使能（OE）引脚被拉低，因此 STP08CP05 从上电时即处于激活状态，这可能会导致上电时出现轻微闪烁。与 ECU 失去一个 GPIO\n相比，这种行为更为可取。\n\nLED 采用 0603 封装。这种封装类型的 LED 有多种颜色可供选择。\n\n注意\n\n尽管 LED 有多种不同的颜色可供选择，但不同颜色的 LED 通常需要不同的电流才能达到相同的亮度（即使它们来自同一系列）。在选用不同颜色的 LED\n时，请务必检查推荐电流，并确保各电流值足够接近。\n\n\n引脚排列#\n\nBODY 扩展接口的引脚排列","routePath":"/docs/hardware/schematics/body","lang":"","toc":[{"text":"发动机钥匙","id":"发动机钥匙","depth":2,"charIndex":73},{"text":"灯光","id":"灯光","depth":2,"charIndex":321},{"text":"引脚排列","id":"引脚排列","depth":2,"charIndex":955}],"domain":"","frontmatter":{},"version":""},{"id":15,"title":"CAN/CAN-FD 总线","content":"#\n\n简化后，CAN 总线的布局可近似表示为下图所示。\n\nCAN/CAN-FD 总线简化布局\n\n注意\n\n有关 CAN/CAN-FD 总线阻抗匹配的信息，请参阅阻抗匹配章节。\n\nCAN-FD 总线两端均采用 120 欧姆的分压终端电阻进行端接。\n\nCAN/CAN-FD 总线两端使用的终端电阻","routePath":"/docs/hardware/schematics/canbus","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":16,"title":"底盘","content":"#\n\nCHASSIS 扩展用于模拟通常出现在汽车底盘域中的一些功能：\n\n * 方向盘\n * 驻车制动\n\n尽管传统上不属于底盘域，但照明开关也位于底盘域中。\n\n\n\n\n\n\n方向盘#\n\n方向盘由一个旋转电位器模拟实现。TVS 二极管用于静电放电（ESD）防护，同时一个电容器也用来防止 ECU 输入端的抖动。\n\n方向盘电路原理图\n\n\n驻车制动#\n\n驻车制动由一个上拉滑动开关模拟实现。TVS 二极管用于静电放电（ESD）防护。\n\n驻车制动电路原理图\n\n\n照明开关#\n\n照明开关由 NKK 公司 NR01 系列旋转开关模拟实现。采用 TVS 二极管进行 ESD 防护。通过旋转开关选择分压器上的一个点，该点的电压由 ECU 上的\nADC 进行测量。\n\n照明开关电路原理图\n\n\n引脚排列#\n\n机箱扩展接口的引脚排列","routePath":"/docs/hardware/schematics/chassis","lang":"","toc":[{"text":"方向盘","id":"方向盘","depth":2,"charIndex":83},{"text":"驻车制动","id":"驻车制动","depth":2,"charIndex":163},{"text":"照明开关","id":"照明开关","depth":2,"charIndex":223},{"text":"引脚排列","id":"引脚排列","depth":2,"charIndex":333}],"domain":"","frontmatter":{},"version":""},{"id":17,"title":"调试器","content":"#\n\nDEBUGGER 扩展用于轻松探测扩展引脚插座的每个输出，同时也能方便地将 JTAG 调试器连接到 ECU。\n\n\n\n\n\n\nJTAG 调试器#\n\n调试器扩展上配备了一个标准的 20 针 JTAG 连接器。这使得用户能够连接诸如 ST-LINK V2 之类的调试器，从而轻松地为 ECU 开发和调试新的固件。\n\nJTAG 电路原理图\n\n\n引脚排列#\n\nDEBUGGER 扩展接口的引脚排列","routePath":"/docs/hardware/schematics/debugger","lang":"","toc":[{"text":"JTAG 调试器","id":"jtag-调试器","depth":2,"charIndex":63},{"text":"引脚排列","id":"引脚排列","depth":2,"charIndex":169}],"domain":"","frontmatter":{},"version":""},{"id":18,"title":"CAN-FD 收发器","content":"#\n\n所有 ECU 均采用相同的 CAN-FD 物理层（PHY）设计，该设计基于一款简单的 CAN-FD 收发器 IC，并辅以旁路电容。该收发器从 5V\n电源线（VDD）获取供电，但通信时使用 3.3V 电压（Vio）。\n\nECU 所使用的 CAN-FD 物理层\n\n大多数 CAN 收发器 IC 采用相同的封装和布局，因此可以互换使用。我们使用以下任一组件构建了原型：\n\n * ATA6561-GAQW-N（BETA）。该产品适用于汽车应用（AEC-Q100 认证），但其比特率限制为 5 Mbps。\n * MCP2558FD-H/SN（V1）。其最大比特率为 8 Mbps，但目前尚未通过 AEC-Q100 认证（？）。\n\n我们首选 MCP2558FD-H/SN，因为它具有更高的最大比特率。\n\n该 PHY 芯片配备了一个“STBY”（待机）或“S”（静默）引脚，用于禁用收发器：\n\n * 当 STBY/S 引脚为高电平时，收发器被禁用，ECU 将无法在 CAN-FD 总线上进行通信。\n * 当 STBY/S 为低电平时，收发器被启用，ECU 即可在 CAN-FD 总线上进行通信。\n\nSTBY/S 引脚内置上拉电阻，这意味着必须主动将 STBY/S 引脚置为低电平才能使能通信。在典型设计中，建议将 STBY/S 保持上拉状态，以确保未编程的\nECU 不会干扰 CAN-FD 总线。然而，由于 RAMN 利用 CAN-FD 总线从（未编程的）出厂状态对 ECU 进行编程，因此 STBY/S\n引脚需通过外部下拉，以允许硬件内置的引导程序通过 CAN-FD 进行通信。\n\n注意\n\n当 ECU 未使用时，建议将其编程为禁用其 CAN-FD 收发器。","routePath":"/docs/hardware/schematics/ecus/canphy","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":19,"title":"","content":"RAMN 主板上有 4 个 ECU，它们均采用相同的设计和引脚分配，具体细节如下：\n\n * 电源\n * 微控制器\n   * 微控制器选型\n   * 外围电路\n     * 时钟\n     * 启动选择电阻\n * CAN-FD 收发器\n\nECU C 的带注释特写图","routePath":"/docs/hardware/schematics/ecus/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":20,"title":"微控制器","content":"#\n\n\n微控制器选型#\n\n与最新 RAMN 固件兼容的微控制器包括：\n\n * STM32L562CET6（512kB 闪存，带硬件加密）。\n * STM32L552CET6（512kB 闪存，无硬件加密）。\n * STM32L552CCT6（256kB 闪存，无硬件加密）。\n\n由于 STM32L552CCT6 仅配备 256kB 闪存，因此不支持 UDS 重编程，但支持其他重编程接口。上述所有微控制器均采用同一固件；RAMN\n会自动检测可用的闪存容量，并且不使用硬件加密。\n\n**RAMN 的固件已不再支持 STM32L4 系列微控制器，但 PCB 仍与其兼容。**用于 RAMN BETA 版本的 STM32L4\n系列旧版源代码可根据要求提供，但该版本已不再维护，功能也极为有限。\n\n**RAMN 目前“官方”并不兼容 STM32U5 系列微控制器。**如果您希望使用 STM32U5 微控制器，唯一需要的改动是更新 PCB，在 PB11\n引脚上增加电容（该引脚在 STM32U5 系列中变为“VCAP”）。源代码大部分是兼容的，但许多用于 STM32L5 的代码生成特性在 STM32U5\n上无法使用，因此需要进行一定的移植工作。**二进制文件并不兼容（您无法将 STM32L5 的固件刷入 STM32U5 设备）。**如果您需要有关如何使用\nSTM32U5 微控制器的指导，请随时与我们联系。\n\n注意\n\n对于 STM32L 微控制器，零件编号的最后四个字母用于指定：\n\n * 引脚数量（C -> 48 引脚）\n * 闪存容量（C -> 256 KB，E -> 512 KB）\n * 封装（T -> LQFP）\n * 温度范围（3 -> -40 至 125 摄氏度，6 -> -40 至 85 摄氏度）\n\nRAMN 的 PCB 要求微控制器采用 LQFP48 封装。\n\n\n外围电路#\n\n** 围绕 ECU 微控制器的电路\n\n在可能的情况下，我们尽量遵循意法半导体的硬件设计指南。微控制器的 VDD 引脚分别连接到独立的 100nF 去耦电容，以及一个共用的 10uF 电容。RST\n引脚也连接了一个 100nF 电容。为了节省空间，VDDA 引脚未连接外部去耦电容和铁氧体磁珠。同样地，VBAT 也没有配备去耦电容。\n\n\n时钟#\n\n微控制器的时钟源选用 NX3225GD 晶体。NX3225GD 系列属于汽车级产品，已列入 STM32 兼容晶体清单，并且也被部分 Nucleo\n设计所采用。NX3225GD 晶体广泛提供 8MHz 和 10MHz 两种版本。RAMN 可与这两种晶体搭配使用，但由于内部 PLL 电路的限制，8MHz\n晶体无法使 STM32L5 系列达到 110MHz 的最大系统时钟频率。因此，建议优先选择 10MHz 晶体。\n\nNX3225GD 晶体的负载电容为 8pF，相较于同类产品而言较低。假设杂散电容为 3pF，则外接两个 10pF 电容以近似实现 8pF 的负载（3 +\n10/2 = 8）。\n\n尽管并非理想状态，但该布局遵循了最佳实践，将晶体尽量靠近微控制器放置，并对时钟线进行了屏蔽，以避免与其他信号产生干扰。\n\n每个 ECU 上的时钟电路\n\n\n启动选择电阻#\n\n存在启动选择电阻，因为 RAMN 曾与 STM32L4 和 STM32L5 兼容，而这两者具有不同的启动序列。\n\n在 STM32L4 和 STM32L5 系列中，默认使用 BOOT0 引脚来指定微控制器应以何种模式启动。电阻 R8 和 R9 可用于选择 ECU A 的\nBOOT0 引脚状态。这些电阻中每次只能安装其中一个。\n\nECU A 的启动模式选择电阻\n\nSTM32L4（模式 6）与 STM32L5（模式 12）的引导模式有所不同。\n\nSTM32L4 在闪存未编程时将启动嵌入式引导加载程序。这意味着新出厂的板卡无论 BOOT0 引脚处于何种状态，均可直接通过 USB 进行编程。因此，我们使用\nR9 将 BOOT0 引脚拉低，而 R8 则不安装。首次连接时，ECU A 将以 DFU 模式启动，并准备好通过 USB 进行编程。一旦 ECU A\n完成编程，并且由于 BOOT0 被拉低，该板卡将在下次重启时直接运行已编程的固件。\n\nSTM32L5 即使在闪存未编程的情况下，也不会启动嵌入式引导加载程序。为了确保新板卡能够通过 USB 进行编程，我们需要使用 R8 将 BOOT0\n引脚拉高，强制 ECU 进入 DFU 引导加载程序模式。R9 则保持未安装状态。这意味着 ECU A 将始终以 STM32\n引导加载程序模式启动，直到选项字节被覆盖为新的值，从而触发另一次启动流程。\n\nECU A 的 BOOT0 引脚可通过 USB 接口旁的测试焊盘从外部访问。然而，一旦成功刷入有效固件，ECU A 将忽略 BOOT0 引脚的状态。\n\nECU A Boot0 测试焊盘\n\nECU B、C 和 D 的 BOOT0 引脚由 ECU A 控制。ECU A 应在激活各 ECU 的电源之前，确保正确设置每个 ECU 的 BOOT0 引脚。","routePath":"/docs/hardware/schematics/ecus/microcontroller","lang":"","toc":[{"text":"微控制器选型","id":"微控制器选型","depth":2,"charIndex":3},{"text":"外围电路","id":"外围电路","depth":2,"charIndex":789},{"text":"时钟","id":"时钟","depth":3,"charIndex":964},{"text":"启动选择电阻","id":"启动选择电阻","depth":3,"charIndex":1343}],"domain":"","frontmatter":{},"version":""},{"id":21,"title":"电源","content":"#\n\n所有 ECU 均拥有独立的电源，但这些电源均采用这一通用设计。\n\nECU 所使用的电源\n\n该电源模块将 USB 的 5V 电源转换为 3.3V 电源线，用于为 ECU 的 STM32L5 微控制器供电。\n\n该操作通过安森美半导体的 LDO 器件 NCV8163 实现。NCV8163 在输入和输出端仅需 1uF 电容即可工作。此外，它还配备了一个 ENABLE\n引脚，可用于单独控制 ECU 的电源开关。\n\nNCV8163 是一款专为汽车应用设计的超低噪声稳压器，非常适合用于研究 ECU 的侧信道分析。尽管其最大输出电流设计为 250\nmA，但由于封装尺寸较小（TSOP-5）以及 RAMN 布局的原因，不太可能承受大电流带来的功率损耗。因此，NCV8163 仅用于为 ECU 的微控制器供电。\n\n警告\n\n尽管每台 ECU 的扩展引脚排针上都提供了 3.3V 电源线，但并不建议从中抽取过多电流。当扩展板需要 3.3V 电源时，我们通常会额外增加一个专门为此设计的\nNCV8163，以确保多块扩展板叠加使用时不会导致过热问题。\n\n在我们的评估测试中，即使在 CPU 全速运行且多个外设激活的情况下，我们也未观察到温度异常升高的现象。NCV8163\n具备过流、输出短路及过热保护功能。根据数据手册的建议，我们额外增加了一个外部肖特基二极管，以保护 NCV8163 免受反向电流的影响。\n\n注意\n\n除 ECU A 外，所有电源的 ENABLE 引脚均被拉低（即电源关闭）。ECU A 必须主动启用 ECU B、C、D 的电源。如果 ECU A\n未正确编程，ECU B、C、D 将一直处于断电状态。","routePath":"/docs/hardware/schematics/ecus/powersupply","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":22,"title":"原理图详情","content":"#\n\n\nRAMN 主板：#\n\n * ECUs\n * CAN/CAN-FD 总线\n * USB\n\n\n扩展：#\n\n * 屏幕（网关/信息娱乐）\n * 底盘\n * 动力总成\n * 车身\n * 调试器","routePath":"/docs/hardware/schematics/","lang":"","toc":[{"text":"RAMN 主板：","id":"ramn-主板","depth":2,"charIndex":3},{"text":"扩展：","id":"扩展","depth":2,"charIndex":48}],"domain":"","frontmatter":{},"version":""},{"id":23,"title":"动力总成","content":"#\n\nPOWERTRAIN 扩展用于模拟汽车动力总成领域中通常存在的一些功能：\n\n * 加速器\n * 制动器\n * 换挡杆\n\n\n\n\n\n\n加速器#\n\n加速器由一个滑动电位器模拟实现。采用 TVS 二极管进行 ESD 防护，同时使用电容保护 ECU 输入端免受抖动干扰。\n\n加速器电路原理图\n\n\n制动器#\n\n制动器同样由一个滑动电位器模拟实现，其电路与加速器相同。采用 TVS 二极管进行 ESD 防护，同时使用电容保护 ECU 输入端免受抖动干扰。\n\n制动电路原理图\n\n\n换挡杆#\n\n换挡杆由一个具有中央按压功能的四方向操纵杆模拟实现。所选元件为阿尔卑斯阿尔派公司的 SKRHADE010。\n\n我们最初选择了同样来自阿尔卑斯阿尔派公司的 SKQUCAA010，该元件操作更为简便，但该型号已接近 EOL，未来可能难以采购。\n\n操纵杆的运动从分压器中选择一个点，该点电压由 ECU 上的 ADC 进行测量。此外，还使用了 TVS 二极管进行 ESD 防护。\n\n换挡杆电路原理图\n\n\n引脚排列#\n\n动力总成扩展模块连接器引脚定义","routePath":"/docs/hardware/schematics/powertrain","lang":"","toc":[{"text":"加速器","id":"加速器","depth":2,"charIndex":67},{"text":"制动器","id":"制动器","depth":2,"charIndex":145},{"text":"换挡杆","id":"换挡杆","depth":2,"charIndex":234},{"text":"引脚排列","id":"引脚排列","depth":2,"charIndex":438}],"domain":"","frontmatter":{},"version":""},{"id":24,"title":"屏幕（网关/信息娱乐）","content":"#\n\nSCREENS 扩展用于为 ECU 添加屏幕。虽然它可以应用于任何 ECU，但默认情况下，我们将其用于 ECU A（网关 ECU）。\n\n\n\n\n\n此扩展配备了多种引脚插座，可连接 Adafruit 的屏幕。我们首选的是 Adafruit 4313 240x240 TFT\n彩色屏幕，因为它在尺寸、可读性和成本之间取得了良好的平衡。\n\n我们选择这些屏幕的主要原因是它们能够以 5V 供电，同时使用 3.3V 逻辑进行控制，无需外部元件。\n\n警告\n\n我们仅针对 J5 引脚插座的屏幕进行了测试。其他屏幕无法保证正常工作。\n\n\n兼容屏幕#\n\n\nJ5#\n\n * Adafruit 4383\n * Adafruit 4313\n * Adafruit 4311\n * Adafruit 3533\n\n\n\n\nJ2（未测试）#\n\n * Adafruit 1431\n * Adafruit 1673\n\n\nJ3（未测试）#\n\n * Adafruit 4086\n * Adafruit 4197\n * Adafruit 4098\n * Adafruit 4196\n * Adafruit 3625\n\n\nJ4（未测试）#\n\n * Adafruit 326\n * Adafruit 938\n\n\n引脚排列#\n\nSCREENS 扩展连接器的引脚排列","routePath":"/docs/hardware/schematics/screens","lang":"","toc":[{"text":"兼容屏幕","id":"兼容屏幕","depth":2,"charIndex":262},{"text":"J5","id":"j5","depth":3,"charIndex":270},{"text":"J2（未测试）","id":"j2未测试","depth":3,"charIndex":347},{"text":"J3（未测试）","id":"j3未测试","depth":3,"charIndex":393},{"text":"J4（未测试）","id":"j4未测试","depth":3,"charIndex":490},{"text":"引脚排列","id":"引脚排列","depth":2,"charIndex":534}],"domain":"","frontmatter":{},"version":""},{"id":25,"title":"USB","content":"#\n\nUSB 用于两个目的：\n\n * 为所有 ECU 及扩展设备提供 5V 电源。\n * ECU A 与 USB 主机之间的通信。\n\n设计一款符合 USB-IF 认证标准的设备需要遵循诸多指南。由于 RAMN 并非 intended to be used as a “proper” USB\ndevice（例如键盘、鼠标等），因此我们并未尝试满足 USB-IF 的全部要求。具体而言，这意味着电路板上没有配备“VBUS 滤波器”（如铁氧体磁珠等）。\n\nUSB 连接电路仅在 SHIELD 和 GROUND 之间配置了一个 RC 滤波器。可以使用分流电阻进行简单的功率分析。此外，也可以用聚合物保险丝替代分流电阻。\n\nUSB 连接电路\n\n警告\n\n除非您用保险丝替代分流电阻，否则 RAMN 假定 USB 主机已针对其负载故障（短路等）进行了保护。除了一个简单的 RC 滤波器外，并无特别的 ESD\n防护措施。","routePath":"/docs/hardware/schematics/usb","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":26,"title":"CTF 训练","content":"#\n\n\n简介#\n\n默认情况下，RAMN ECU 实现了一些小型 CTF 挑战，可用于练习汽车领域的夺旗（CTF）赛事。\n\n标志以明文形式存在于固件文件和源代码中；目标是开发正确的命令或脚本，在不查看源代码或二进制文件的情况下提取标志。标志的格式为 flag{xxx} 。\n\n\n挑战#\n\n\nUSB#\n\n * 非常简单 ：通过 USB 发送命令“^”即可访问一个标志。\n * 简单 （需要脚本）：通过发送命令“&”及一个五位数字密码（例如“&12345”）可访问另一个标志。\n\n\nCAN#\n\n传输#\n\n * 非常简单 ：如果你发送任何 ID 为 0x456 的消息，将广播一个带有 CAN ID 0x770 的标志。\n * 非常简单 ：如果你发送一个 ID 为 0x457、有效载荷为“GIVEFLAG”的 CAN 消息，就会广播一个 CAN ID 为 0x771 的标志。\n * 非常简单 ：如果你发送一个带有特定 ID 的远程帧，就会广播一个 CAN ID 为 0x772 的标志。\n * 中级 ：如果你发送一个特定的 CAN 消息，并通过以下函数进行检查，就会广播一个 CAN ID 为 0x773 的标志：\n\n\n\n接收#\n\n发送一个 ID 为 0x458、有效载荷为空的消息，以启用以下标志的周期性传输。\n\n * 简单 ：有一个标志位，通过 CAN ID 为 0x6F0 逐位广播。\n * 中级 ：有一个标志位，通过 CAN ID 为 0x6F1 逐位广播。\n * 困难 ：有一个标志位，通过 CAN ID 为 0x6F2 逐位广播（标志长度为 19 个字符）。\n\n注意\n\n提示 ：标志始终以 ASCII 字符串“flag”开头。\n\n\nUDS#\n\n * 非常简单 ：ECU D 在 ID 为 0x0001 处保存了一个标志，可通过标识符读取服务进行读取。\n * 简单 ：ECU D 持有一个可在 ID 0x0002 处读取的标志，但您需要先进行身份验证。\n * 简单 （需要脚本）：ECU D 持有另一个可通过标识符数据读取服务读取的标志。\n * 简单 ：ECU D 持有一个标志，可通过地址 0x01234567 处的按地址读取内存操作访问，大小为 17 (0x11)。\n * 中级 （需要脚本）：ECU D 具有一个自定义的 UDS 服务，其 ID 为 0x40，你能创建一个有效的请求吗？\n\n\n漏洞利用（进阶）#\n\n有两个 UDS 例程实现了易受攻击的密码检查，且它们需要采用略有不同的利用方法。你能利用这些例程来恢复之前的所有标志吗？\n\n目标并不是恢复密码或绕过检查，而是劫持执行流程以转储内存（通过 USB、CAN 等）。有关如何开始的指导，请参阅为 RAMN 编写 ARM\nshellcode。你可以自行编译源代码以生成.elf 和.map 文件。虽然 JTAG\n调试器并非绝对必要，但它会使漏洞利用更加容易。在完成安全访问后，你需要使用例程控制服务（参见与 UDS 交互 ）。如果你已经熟悉 ARM\n漏洞利用，还可以为自己增加一些未强制执行的额外限制（例如禁止在 RAM 中执行任何代码）。\n\n例程控制 0x20A\n\n\n\n例程控制 0x20B\n\n警告\n\n我们不会在每次更新后定期检查此题是否可解，但很可能仍然是可解的。\n\n","routePath":"/docs/minictf","lang":"","toc":[{"text":"简介","id":"简介","depth":2,"charIndex":3},{"text":"挑战","id":"挑战","depth":2,"charIndex":137},{"text":"USB","id":"usb","depth":3,"charIndex":143},{"text":"CAN","id":"can","depth":3,"charIndex":237},{"text":"传输","id":"传输","depth":4,"charIndex":243},{"text":"接收","id":"接收","depth":4,"charIndex":508},{"text":"UDS","id":"uds","depth":3,"charIndex":719},{"text":"漏洞利用（进阶）","id":"漏洞利用进阶","depth":3,"charIndex":1001}],"domain":"","frontmatter":{},"version":""},{"id":27,"title":"快速入门指南","content":"#\n\n\n了解主板#\n\n要开始使用 RAMN，您需要带有四个 ECU 的主板。\n\n您可以通过丝印标识来识别主板上的各个 ECU：\n\n * ECU A 位于左上角，紧邻 USB 连接器。\n * ECU B 位于 ECU A 的下方。\n * ECU C 位于 ECU B 的右侧。\n * ECU D 位于 ECU A 的右侧。\n\n\n\n\n添加扩展#\n\n为了与 ECU 进行物理接口连接，您可以为每个 ECU 添加扩展。这些扩展应按照以下动画所示的方式进行连接。\n\n注意\n\n如果您不打算使用这些控制装置（例如，您只想尝试 UDS 命令），则无需安装扩展模块。\n\n\n\n您可以通过查看丝印来识别每个控制装置的作用：\n\n * ECU A 配备了一个显示屏，可在其上显示 CAN 总线的相关信息。\n * ECU B 配备了一个旋转电位器用于模拟方向盘，一个两位开关用于模拟驻车制动器，以及一个四位置旋转开关用于模拟灯光控制。\n * ECU C\n   配备了一个滑动电位器用于模拟油门踏板，另一个滑动电位器用于模拟制动踏板，以及一个操纵杆用于模拟换挡杆。该操纵杆可通过上下按压来请求换挡，左右拨动来控制转向\n   灯，中间按下则可模拟鸣笛操作。\n * ECU D 配备了一个发动机钥匙和八个 LED 指示灯。发动机钥匙有三个位置：OFF（关闭）、ACC（附件）和 IGN（点火）。\n\n\n控制功能测试#\n\n在继续操作之前，您应先验证开发板是否正常工作。将开发板连接到电脑的 USB 端口，或连接到能够提供超过 300mA 电流的 USB 电源。每个控制的状态应显示在\nECU A 屏幕的底部。移动每个控制，并确认其状态在屏幕上得到更新（必要时 LED 指示灯也会相应变化）。如果未出现上述情况，您可能需要重新刷写开发板固件（参见\n固件刷写 )。ECU D 扩展板上的 LED 模拟了一个简单的仪表盘，可以帮助您验证每个控制是否正常工作。默认情况下，只要电源接通，CAN\n总线始终处于激活状态，因此您可以将控制置于任何您偏好的状态（例如，发动机钥匙置于 OFF 位置）。\n\n您可以通过按下 ECU C 上“SHIFT”操纵杆的 LEFT 或 RIGHT 来切换 ECU A 的不同屏幕。在某些屏幕上，您还可以通过按下 UP、DOWN\n或 CENTER 进一步进行交互。\n\n * LED D1 是左转向指示灯。当您向左按下 ECU C 的操纵杆时，它应开始闪烁。\n * LED D2 是右转向指示灯。如果您在 ECU C 上向右按下操纵杆，该指示灯应开始闪烁。\n * LED D3、D4 和 D5 分别代表示廓灯、近光灯和远光灯。当您打开 ECU B 上的灯光控制开关时，这些指示灯应按顺序依次点亮。\n * LED D6 是“电池”指示灯。默认情况下，当发动机钥匙处于“ACC”或“IGN”位置时，该指示灯会亮起。\n * LED D7\n   是“检查发动机”指示灯。默认情况下，当使用自动驾驶算法且方向盘电位计未归中时，该指示灯会亮起。它用于提示当前已忽略自动驾驶算法的指令，转而采用方向盘电位计\n   的当前位置。\n * LED D8 是“驻车制动”指示灯。当驻车制动处于激活状态时，该指示灯会亮起。与真实车辆不同的是，当踩下制动踏板时，该指示灯也会亮起。\n\n注意\n\n尽管在真实车辆中，“电池”和“发动机检查”指示灯会让人感到担忧，但这并不意味着您的 RAMN 板出现了故障。\n\n警告\n\n如果在您将方向盘回正时，屏幕上未显示“转向\n0%”，则表明您为配备线性电位器的板子安装了对数型固件，反之亦然。这种情况下，该板仍可正常使用，但如果您希望在模拟器中驾驶车辆，可能需要更新 ECU B\n的固件。\n\n在粗暴操作过程中，点烟器开关和转向电位器的盖子可能会脱落，请务必注意不要丢失。同时也要小心屏幕，它相当脆弱。\n\n\n选择您的 CAN 适配器与工具#\n\n要与 RAMN 的 CAN 总线进行交互，您有两种适配器可供选择：\n\n 1. 使用您自己的适配器，例如公开可用的 CAN 适配器（如 CANtact），以及 savvyCAN 等软件。\n 2. 使用 RAMN 内置适配器（RAMN 本身通过 USB 充当“slcan”适配器，因此如果您的软件兼容 slcan，则无需连接任何硬件）。\n\n此外，还有两种（软件）工具可供选择：\n\n 1. 使用您自己的工具，例如 SavvyCAN、BUSMaster、scapy-automotive，或您自己编写的 python-can 脚本。\n 2. 使用 Linux 命令行工具（即 can-utils）。\n\n如果您想使用自己的适配器，只需将适配器的“CANH”和“CANL”线缆连接到 RAMN CAN\n总线接线端子上，该接线端子位于电路板右上角。接线端子的每个引脚由一个较大的圆形孔和一个较小的矩形孔组成。您应将要连接的线缆插入圆形孔中，内部弹簧会将其锁定到位。\n如需移除线缆，可将工具（例如精密螺丝刀）插入矩形孔中并拉动线缆即可。该接线端子共有三个引脚，对应的信号已在丝印旁进行了标注：\n\n * 最上面的引脚为 GND（地）。\n * 中间的引脚为 CANL（CAN 低电平）。\n * 最下面的引脚为 CANH（CAN 高电平）。\n\n您只需将 RAMN 的 CANH 和 CANL 引脚连接到您的 CAN 适配器的 CANH 和 CANL\n引脚即可。完成连接后，您就可以使用自己喜爱的工具集了。只要 RAMN 板通电，CAN 总线就会始终保持激活状态。\n\n本文件的其余部分将重点介绍内置 RAMN 适配器和内置 Linux 工具。\n\n\n使用内置工具#\n\n要在 RAMN 上开始进行 CAN 总线分析，我们建议您准备一个带有 can-utils 的 Linux 环境（虚拟或原生）。\n\n\n准备配备 can-utils 的 Linux 机器#\n\nWindows#\n\n在 Windows 系统上，我们建议您安装 VirtualBox 并使用 Linux 发行版镜像。汽车爱好者的一个常见选择是 Kali Linux [ 1 ]。\n\n * 下载并安装 VirtualBox。\n * 下载 Kali Linux 预构建的虚拟机 。\n * 使用 7zip 解压 7z 镜像。\n * 双击 vbox 文件，使用 VirtualBox 打开。如果遇到 USB 问题，请打开“设置”>“USB”，尝试选择 USB 2.0 或 USB\n   3.0（虚拟机必须处于关机状态）。\n * 使用用户名 kali（密码 kali）登录。\n\n从这里开始，您应该能够按照以下 Linux 说明进行操作。\n\n脚注\n\n[ 1 ]：#\n\n如果您无法（或不愿）在虚拟机中运行 Linux 以使用 can-utils 工具，我们建议您学习并使用跨平台的 python-can\n库，它可在所有（Python）平台上运行，包括 Windows。\n\nLinux#\n\n * 打开终端窗口（例如，右键单击桌面并选择“在此处打开终端”）。\n * 输入以下命令以安装 can-utils：\n\n\n\n\nUSB 连接#\n\n使用 USB 数据线将开发板连接到您的计算机。在 Windows 系统中，它应显示为“USB 串行设备”（或复合设备），并分配一个 COM 端口号（例如\nCOM1）。如果未出现这种情况，您可能需要安装 STM32 虚拟 COM 端口驱动程序 。\n\n一旦 Windows 识别到该板卡，您必须将 USB 端口转发至 Virtual Box。选择“设备”>“USB”，然后单击“丰田汽车公司\nRAMN”。您也可以打开“设备”>“USB”>“USB 设置…”，然后单击“+”图标以添加 RAMN，这样 Virtual Box 就会始终自动转发该 USB\n端口。\n\n在 Linux 系统中，RAMN 应出现在 dmesg 命令的末尾，并被分配一个设备文件（通常为/dev/ttyACM0）。如果遇到问题，请参阅USB 不稳定。\n\n\n启动 slcand#\n\n默认情况下，RAMN 充当 slcan 适配器。您可以使用 slcand 命令将 RAMN 作为原生 Linux CAN 接口启动。\n\n\n\n请将 /dev/ttyACM0 替换为您计算机所分配的设备文件。\n\n执行此命令后，您应该能够使用 ifconfig 看到 CAN 接口显示为“can0”：\n\n\n\n\n使用 Cansniffer 观察 CAN 流量#\n\n要观察每个标识符的最新 CAN 消息并突出显示位变化，可以使用以下命令：\n\n\n\n每条消息的前两个字节表示板上某项的状态。尝试移动控制部件，并观察这些值如何变化。接下来的两个字节表示消息计数器，最后四个字节表示前四个字节的 CRC32\n校验值。\n\n\n转储 CAN 流量#\n\n如果您想查看所有 CAN 帧，而不是每个标识符的最新帧，可以使用 candump 命令。\n\n\n\n此命令将转储所有 CAN 帧，可能会导致信息过载。您可以使用过滤器仅显示特定的 CAN ID。要添加过滤器，请在 CAN 接口名称后加上\n,<filter>:<mask> 。例如，若仅需显示 ID 为 0x150 的帧，请使用以下命令：\n\n\n\n此命令应仅显示 ID 为 0x150 的 CAN 帧。移动 ECU B 扩展上的照明控制开关，并观察第一个字节的变化情况。这将帮助您理解 ECU B 如何通过\nCAN 总线传输该开关的状态。\n\n\n发送 CAN 帧#\n\n您可以使用 cansend 命令来发送 CAN 消息。请确保将 ECU B 上的照明控制开关拨至最左侧位置，以关闭车身 ECU 扩展上的照明 LED（D3 至\nD5 LED）。然后，您可以发送以下消息来“欺骗”照明控制：\n\n\n\n您应该能够通过终端短暂地控制车身扩展上 LED 的状态。但只能短暂控制，因为 ECU B 仍在持续发送 CAN 帧，覆盖您的 CAN 消息。实际上，您可能会在\nECU A 上看到一条错误信息，提示 CAN 总线出现异常，这是因为两个 ECU 正在发送具有相同 ID 的 CAN 帧。要解决这个问题，您需要阻止 ECU B\n发送 CAN 消息。一个快速的方法是使用 UDS。\n\n\n发送 UDS 命令#\n\nUDS 是一组标准诊断命令，可通过 ISO-TP 传输层发送。您可以使用 isotpsend、isotprecv 和 isotpdump\n命令轻松地与这些层进行交互。\n\n输入以下命令以转储包含 UDS 命令的 CAN 消息：\n\n\n\n此命令将转储 ID 范围从 0x7e0 到 0x7eF 的消息，这些 ID 对应于 RAMN 的 UDS 层所使用的\nID。目前应该不会显示任何内容，因为尚未发送任何 UDS 消息。\n\n打开另一个终端，并输入以下命令：\n\n\n\n此命令将转储并解析针对 ECU B 的 UDS 命令，该 ECU 在 ID 为 0x7e1 处接收命令，并在 ID 为 0x7e9\n处作出响应。目前，此命令也应暂无任何输出。\n\n再打开一个终端，并输入以下命令：\n\n\n\n此命令将接收并显示您发送至 ECU B 的 UDS 命令的响应。\n\n最后，打开第四个终端，并输入以下命令以向 ECU B 发送您的第一个 UDS 命令：\n\n\n\n此命令将向 ECU B 发送一个 2 字节的命令“3E 00”，对应于“测试器存在”命令。这是一个可选命令，用于告知 ECU\n当前正在进行诊断，并且它应等待您的后续指令。您应在“isotprecv”终端上看到 ECU B 已回复“7E\n00”，这表示命令已被接受。您可以在“isotpdump”终端上查看对应的交互过程，其中红色表示请求，蓝色表示响应。如果您查看“candump”终端，将看到相应\n的 CAN 报文。请注意，这些报文实际上是 3 字节长：这是因为第一个字节用于指定 UDS 有效载荷的长度，而此处的有效载荷长度为 2 字节。\n\n你可以使用 UDS 来发送和接收大容量负载。例如，使用“按标识符读取数据”服务（0x22）向 ECU 查询其编译时间（参数 0xF184）：\n\n\n\n你应该能在“isotprecv”终端中看到已接收到一个较大的响应，该响应应由你的“isotpdump”终端进行解析。在“candump”终端中，你可以观察到已经\n交换了许多 CAN 报文。这对应于 ISO-TP 层，该层允许通过仅包含小于 8 字节的 CAN 帧来传输大消息。isotpdump、isotpsend 和\nisotprecv 使这一层对你而言是透明的。\n\n最后，你可以使用 RAMN 自定义例程控制（UDS 服务 0x31）来请求 ECU B 停止发送 CAN 报文（例程 0x0200）。\n\n\n\n移动照明开关，观察 ECU D 的 LED 指示灯不再发生变化。现在，您可以通过以下命令控制照明开关，而无需 ECU B 的干扰。\n\n\n\n恭喜您，您已成为 CAN 总线专家。请参阅完整的用户指南 ,以了解更多内容。","routePath":"/docs/quickstart","lang":"","toc":[{"text":"了解主板","id":"了解主板","depth":2,"charIndex":3},{"text":"添加扩展","id":"添加扩展","depth":2,"charIndex":164},{"text":"控制功能测试","id":"控制功能测试","depth":2,"charIndex":582},{"text":"选择您的 CAN 适配器与工具","id":"选择您的-can-适配器与工具","depth":2,"charIndex":1593},{"text":"使用内置工具","id":"使用内置工具","depth":2,"charIndex":2323},{"text":"准备配备 can-utils 的 Linux 机器","id":"准备配备-can-utils-的-linux-机器","depth":3,"charIndex":2398},{"text":"Windows","id":"windows","depth":4,"charIndex":2426},{"text":"Linux","id":"linux","depth":4,"charIndex":2856},{"text":"USB 连接","id":"usb-连接","depth":3,"charIndex":2926},{"text":"启动 slcand","id":"启动-slcand","depth":3,"charIndex":3297},{"text":"使用 Cansniffer 观察 CAN 流量","id":"使用-cansniffer-观察-can-流量","depth":3,"charIndex":3461},{"text":"转储 CAN 流量","id":"转储-can-流量","depth":3,"charIndex":3611},{"text":"发送 CAN 帧","id":"发送-can-帧","depth":3,"charIndex":3891},{"text":"发送 UDS 命令","id":"发送-uds-命令","depth":3,"charIndex":4205}],"domain":"","frontmatter":{},"version":""},{"id":28,"title":"构建","content":"#\n\nbuild 文件夹中的脚本用于同时编译所有 ECU 的固件。\n\n有关这些脚本的详细信息，请参阅 仓库中的 README.md。","routePath":"/docs/scripts/build","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":29,"title":"CARLA","content":"#\n\nCARLA 是一款基于虚幻引擎的自动驾驶模拟器。本页面介绍了如何安装 CARLA 并将其与 RAMN 配合使用。尽管我们仅在 Windows\n系统上测试了相关脚本，但稍作调整后也应在 Linux 系统上可用。请注意，该模拟器要求您配备性能足够强大的 GPU。\n\n\n\n\n安装 CARLA#\n\n警告\n\nCARLA 是一个独立于 RAMN 的项目，因此有关 CARLA 的问题请参考其官方文档。\n\n请按照以下步骤在 Windows 上安装 CARLA：\n\n * 从其 Github 仓库下载并解压 CARLA 的最新版本。我们测试的最新版本是 Release 0.9.15。\n\n * 通过启动 CarlaUE4.exe（或 CarlaUnreal.exe）来检查模拟器是否正常运行，该文件通常位于 WindowsNoEditor\n   文件夹中。这可能需要您通过 Microsoft 的 SmartScreen 对应用程序进行批准。如果打开了 3D\n   视图，您可以关闭模拟器并进入下一步。如果出现错误消息，请安装最新版本的 Windows DirectX。\n\n * 从 Python 软件基金会的网页安装最新版本的 Python 3.8（较新的 CARLA 版本才可使用 3.12 等后续 Python 版本）。\n   请勾选“将 python.exe 添加到 PATH”选项 。我们测试的最新版本是 3.8.10。如果您不确定应该下载哪个文件，可以尝试选择\n   “Windows 安装程序（64 位）”。\n\n * 通过打开命令提示符（按 Windows+R 并输入“cmd”）并执行以下命令来安装 CARLA 的 pythonAPI：\n   \n   \n   \n   如果您也想运行自动驾驶示例，请执行以下命令：\n   \n   pip3 install shapely networkx\n\n * 尝试 CARLA 的 manual_control.py 和 automatic_control.py 示例。首先，执行 CarlaUE4.exe（或\n   CarlaUnreal.exe），并保持窗口打开；这就是您的 CARLA 服务器。然后，在 PythonAPI/examples 中打开一个命令提示符（在\n   Windows 资源管理器中打开该文件夹，并在地址栏输入“cmd”），并尝试第一个示例：\n   \n   \n   \n   您应该能够使用键盘上的 WASD 键手动控制车辆。如果遇到问题，请参阅下面的说明。\n   \n   您还可以通过以下方式验证自动驾驶算法是否正常工作：\n   \n   \n   \n   您应该能够看到自动驾驶算法正在运行。\n\n注意\n\n如果您在使用最新版 CARLA 时遇到问题，请尝试使用以下选项运行：\n\n\n\n如果这样仍无法解决问题，请尝试下载较早版本的 CARLA。RAMN 脚本应与 0.9.12 版本兼容。如果选择这样做，您还需要安装对应版本的 CARLA\nPython API，例如通过以下命令：\n\n\n\n注意\n\n近期发布的 CARLA 版本可能无法通过 pip 获取其 Python API。如果您使用的是最新版 CARLA，应直接从\nPythonAPI/carla/dist 文件夹安装其 Python API，例如通过以下命令：\n\n\n\n至此，您应该已经拥有一个可正常运行的环境来体验 CARLA。如果在此步骤之前遇到任何问题，则表明您的 CARLA 安装存在问题，而非 RAMN 的问题。请参考\nCARLA 的快速入门指南以获取支持。\n\n如果您需要，可以按照此处说明下载额外的资源（地图等）。此外，您还可以按照此页面的说明修改 CARLA 的默认设置（天气等）。\n\n\n配置您的 RAMN 环境#\n\n * 如果您尚未完成，首先需要安装 RAMN 的脚本：\n   \n   1. 在您的计算机上下载 RAMN 代码库 （选择“代码”>“下载 ZIP”）。\n   \n   2. 在 RAMN/scripts 文件夹中打开命令提示符（您可以通过在 Windows\n      资源管理器中打开该文件夹，并在地址栏中输入“cmd”来实现），然后执行：\n      \n      \n\n * 打开 RAMN/script/settings/CARLA_PATH.txt 并将其内容替换为计算机上 CARLAUE4.exe（或\n   CarlaUnreal.exe) 所在文件夹的路径。\n\n * （可选）使用您首选的设置（分辨率等）修改 0_CARLA_SERVER_start.bat。有关 CARLA 选项的更多信息，请参阅 CARLA 的文档\n   。通过 -quality-level=Epic（最佳画质）或 -quality-level=Low（最佳性能）指定图形质量。通过 -windowed\n   -ResX=N -ResY=N 指定服务器的分辨率。\n\n * （可选）修改 CarlaSettings.ini 以编辑默认设置（天气等）\n\n * （可选）修改 1_CARLA_SERVER_config.bat 以提供快捷方式，根据需要执行 CARLA 的 config.py（例如，用于加载特定地图\n   ）。\n\n\n为 CARLA 执行 RAMN 脚本#\n\n首先，启动一个 CARLA 服务器：\n\n * 执行 0_CARLA_SERVER_start.bat。\n * （可选）执行 1_CARLA_SERVER_config.bat 以更新服务器的配置。\n\n每个会话只需启动一台服务器即可。只要窗口保持活动状态，您便可以执行以下脚本。例如，您可以执行基本的 RAMN 示例：\n\n * 执行 2_CARLA_RAMN_manual_serial.bat 以将 RAMN 连接到 CARLA，并使用 RAMN 的控制装置手动驾驶车辆。\n * 执行 3_CARLA_RAMN_auto_serial.bat 以将 RAMN 连接到 CARLA 的自动驾驶算法。\n\n如果出现错误，请确认您的 RAMN 串口未被其他应用程序占用。\n\n当您使用自动驾驶算法时，控制指令将由 RAMN 决定。如果物理控制装置处于中立位置（例如，刹车和油门电位器位于底部位置），则将应用来自 CARLA\n自动驾驶算法的指令。否则，将应用物理控制装置的指令。\n\n在使用自动驾驶算法时，如果方向盘未居中，“检查发动机”指示灯将亮起，提示您当前 RAMN 正在忽略 CARLA\n对方向盘的指令，并改用模拟控制。如果在您将方向盘回正后指示灯仍未熄灭，可能是因为需要使用不同的固件重新刷新板卡（参见固件刷写）。\n\n您也可以通过 CAN 适配器（内置或外置）而非 USB 串口连接 CARLA 与 RAMN。具体操作如下：\n\n * 修改脚本设置以指定您的 CAN 接口（参见配置 RAMN 的脚本 ）\n * 执行 4_CARLA_RAMN_manual_CAN.bat 以将 RAMN 连接到 CARLA，并手动驾驶车辆。\n * 执行 5_CARLA_RAMN_auto_CAN.bat 以将 RAMN 与 CARLA 连接，并加载自动驾驶算法。\n\nCAN 脚本的功能较少，性能通常也比串行脚本差，因此除非有特定的使用场景，否则应避免使用它们。\n\n警告\n\n在使用 CARLA 脚本时，RAMN 的串口将无法供其他应用程序使用。如果您希望与 CAN 总线进行交互，建议您连接一个外部 CAN 适配器。在 Linux\n系统上，您可以使用 vcand 脚本来复用串口，并在 CARLA 脚本运行时仍能监控 CAN 总线。\n\n\n自动驾驶算法的工作原理#\n\nRAMN 的 CAN 消息被分为“命令”和“控制”两类：\n\n * “命令”CAN 消息对应于自动驾驶算法发出的“控制请求”或“目标”。\n * “控制”CAN 消息对应于 ECU 实际施加的“控制动作”。\n\n如果自动驾驶算法处于关闭状态，许多命令消息将不会出现，因此你会观察到较少的 CAN 消息。\n\n默认情况下，ECU 会监听命令 CAN 消息，并立即将其作为控制 CAN 消息执行，除非相关控制未处于中立位置（即刹车和油门为\n0%，方向盘位于中间位置）。例如，如果一条命令 CAN 消息指示“刹车 50%”，而物理电位器显示为 0%，那么控制 CAN 消息将显示“刹车\n50%”。然而，如果一条命令 CAN 消息指示“刹车 0%”，但物理电位器显示“刹车 100%”，则控制 CAN 消息将显示“刹车 100%”。\n\nECU 还可以被重新编程以实现控制回路，例如比例-积分-微分控制器（PID）。RAMN 的 GitHub 仓库中提供了一个 PID 控制的示例 。","routePath":"/docs/scripts/carla","lang":"","toc":[{"text":"安装 CARLA","id":"安装-carla","depth":2,"charIndex":136},{"text":"配置您的 RAMN 环境","id":"配置您的-ramn-环境","depth":2,"charIndex":1557},{"text":"为 CARLA 执行 RAMN 脚本","id":"为-carla-执行-ramn-脚本","depth":2,"charIndex":2179},{"text":"自动驾驶算法的工作原理","id":"自动驾驶算法的工作原理","depth":3,"charIndex":3159}],"domain":"","frontmatter":{},"version":""},{"id":30,"title":"诊断","content":"#\n\ndiagnostics 文件夹中的脚本用于演示 RAMN ECU 的诊断功能使用方法。\n\n有关这些脚本的详细信息，请参阅 仓库中的 README.md。","routePath":"/docs/scripts/diagnostics","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":31,"title":"配置 RAMN 的脚本","content":"#\n\n请按照 刷写脚本 中的步骤安装 RAMN 的脚本。\n\n您可以在以下设置中进行修改：scripts/settings/windows.ini（使用 Windows 时）和\nscripts/settings/linux.ini（使用 Linux 时）：\n\n * PORT 指定脚本使用的串口名称（例如 COM1 或 /dev/ttyACM0）。您可以使用“AUTODETECT”让脚本自动查找 RAMN 端口。\n * ECUx_FIRMWARE_PATH 指定用于重新编程或验证 ECU 固件的固件文件。\n * VERBOSE 指定脚本的详细程度（0 表示仅输出错误，4 表示输出所有内容，包括调试信息）。\n * TIMEOUT 指定从串口读取数据的超时值。\n * CAN_NAME 指定依赖 CAN 而非串口的脚本的 通道名称。\n * CAN_TYPE 指定上述 接口类型的名称。\n * CAN_REFRESH_RATE 指定脚本更新 CAN 总线的频率（适用于使用 CAN 的脚本）。\n * VCAND_HARDWARE_PORT 是 vcand 脚本使用的默认硬件端口。","routePath":"/docs/scripts/install","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":32,"title":"vcand","content":"#\n\n\nCAN FD 支持#\n\nvcand 脚本可在 Linux（仅限 Linux）上用于：\n\n * 直接通过 socketcan 使用 RAMN 的 CAN FD 功能（即作为与 slcand 兼容的 CAN FD 替代方案）。\n * 对 RAMN 的串行接口进行多路复用，使其能够同时被不同应用程序打开。\n\n要使用它，首先执行 0_SetupVCAN.sh：\n\n\n\n这将启动一个名为“vcan0”的虚拟 CAN 接口，该接口应可通过 ifconfig 显示出来。\n\n\n\n如果您只想利用 vcand 的 CAN FD slcan 支持，可以从这一步开始运行 RAMN_VCAND.py：\n\n\n\n您可以通过编辑 scripts/settings/linux.ini 中的 VCAND_HARDWARE_PORT（默认：自动检测）或使用-r 选项来选择\nRAMN 使用的串口。之后，您应该能够在 vcan0 上看到 RAMN 的 CAN 流量，例如通过以下命令：\n\n\n\n\n\n与 slcand 不同，此脚本将支持 CAN FD 帧。\n\n\n串行多路复用（2 个端口）#\n\n如果您希望在 Linux 将 RAMN 的串行端口用作 CAN 接口时仍能保持其可访问性，可以使用此脚本的多路复用功能。打开一个新的终端并执行：\n\n\n\n\n\n这将创建一对虚拟串行设备，在本例中为 /dev/pts/3 和 /dev/pts/4。\n\n注意\n\n如果您不想打开多个终端，也可以将此脚本在后台执行：\n\n\n\n如果未看到任何输出，请尝试改用以下命令来启动终端：\n\n\n\n您必须将您创建的第一个设备作为参数提供给 RAMN_VCAND.py，这样您便可以像使用非复用模式下的 RAMN 一样使用第二个设备 。\n\n通过-p1 参数执行脚本，以提供第一个设备的路径：\n\n\n\n从这一步开始，您可以使用 vcan0 接口，同时仍然能够访问 RAMN 的串口。但是，您不应再使用 RAMN\n的硬件串口（例如/dev/ttyACM0），而应改用第二个设备 （本例中为/dev/pts/4）。\n\n例如，您可以在访问/dev/pts/4 上的串行终端的同时，观察 vcan0 上的 CAN 流量：\n\n\n\n\n\n这将使您即使在使用 CARLA 脚本和诊断脚本时，也能够观察 CAN 流量。为此，您需要将 scripts/settings/linux.ini 中的 PORT\n设置为第二个 pts（本例中为/dev/pts/4）。\n\n\n串行多路复用（3 个端口）#\n\n如果您希望使用第三个端口（以便在同时运行 CARLA 脚本和诊断脚本时观察 CAN 总线），可以执行 1_SpawnTTY.sh\n来生成一对新的设备。然后，将每对设备中的第一个设备作为 -p1 和 -p2\n参数提供。之后，您便可以将每对设备中的第二个设备用作串行终端。请注意，所有数据会在两个端口中镜像传输。\n\n执行以下命令以生成一对新的虚拟设备：\n\n\n\n\n\n然后，将每对设备中的第一个设备作为 -p1 和 -p2 参数提供：\n\n\n\n警告\n\n请确保不要将属于同一对的两个设备分别用作 -p1 和 -p2（例如：-p1 /dev/pts/3 -p2 /dev/pts/4 或 -p1\n/dev/pts/10 -p2 /dev/pts/11 ），因为这会导致形成反馈循环，进而使设备溢出。\n\n之后，您应该能够从第二个设备访问这些端口，在本示例中即 /dev/pts/4 和 /dev/pts/11。例如，您可以在两个不同的终端中输入：\n\n\n\n和\n\n\n\n\n\n从这一点来看，你应该能够通过三个不同的接口与相同的流量进行交互。","routePath":"/docs/scripts/vcand","lang":"","toc":[{"text":"CAN FD 支持","id":"can-fd-支持","depth":2,"charIndex":3},{"text":"串行多路复用（2 个端口）","id":"串行多路复用2-个端口","depth":2,"charIndex":466},{"text":"串行多路复用（3 个端口）","id":"串行多路复用3-个端口","depth":2,"charIndex":1038}],"domain":"","frontmatter":{},"version":""},{"id":33,"title":"","content":"翻译\n\n如果有翻译问题反馈，或技术交流，请添加右上角微信号。\n\n本文档由AI辅助翻译，个人校对。\n\n官方\n\n官方原版英文文档：Documentation of RAMN: Resistant Automotive Miniature Network","routePath":"/docs/translation","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":34,"title":"与 CAN 交互","content":"#\n\n\n简介#\n\n控制器局域网（CAN） 是车辆中最常见的通信协议。它仅使用两根线，所有 ECU 共用 ：CAN 高线（CANH）和 CAN 低线（CANL）。CAN\n仅支持广播，没有内置的安全机制：任何 ECU 都可以发送任意消息，且连接到同一 CAN 总线的所有 ECU 都会接收到相同的消息。CAN\n帧本质上是一串由零和一组成的比特流，具有固定的标称波特率（现代车辆中通常为 500 kbps）。\n\n一个 CAN 帧包含：\n\n * 一个仲裁标识符 （通常称为 CAN ID 或简称 ID），其长度可以是 11 位（ 标准标识符 )或 29 位（ 扩展标识符 )。\n * 位标志：RTR（远程传输请求）和 IDE（标识符类型）。\n * 有效载荷数据大小（数据长度代码，DLC），范围为 0 到 8 字节。\n * 实际有效载荷数据 。\n\nECU 通常被分配仲裁标识符，用于定期广播数据，且周期各不相同。例如，在 RAMN 中，ID 0x24（每 10 毫秒发送一次）表示制动踏板状态，而 ID\n0x1B8（每 100 毫秒发送一次）则表示发动机钥匙状态。\n\n较低的 ID 具有较高优先级：如果两个 ECU 同时尝试发送数据，发送高 ID 的 ECU\n将让出总线，并等待下一次机会。这确保了最重要的消息总是优先发送。如果某条消息的 ID 较低，可以推断其重要性较高。\n\n除了周期性 CAN 消息外，ECU 还可能接收和发送非周期性消息，例如诊断消息。ECU 可实现由标准文档定义的诊断接口：\n\n * 统一诊断服务（UDS）\n * 关键字协议 2000（KWP2000）\n * 通用测量与标定协议（XCP）\n\n由于 CAN 帧只能容纳 8 字节或更小的少量有效载荷，因此使用 CAN 传输大型数据（如 ECU 固件文件）存在挑战。XCP\n协议正是基于这一限制而设计的；然而，UDS 和 KWP2000 则依赖于一个名为 ISO-TP（ISO 15765-2） 的中间传输层 。ISO-TP\n层将大型有效载荷（原始版本最大可达 4095 字节，最新版本则可达 4294967295 字节）分割成多个 CAN\n帧，并添加了流量控制机制，以确保接收方能够正确重组这些数据。\n\n近年来，为实现更高带宽，CAN 协议也出现了一些新的演进：\n\n * 具有灵活数据速率的控制器局域网（CAN FD）\n * CAN XL\n\n事实上，RAMN 的 ECU 使用了 CAN FD，但默认情况下仅采用经典 CAN 帧，以保持与不兼容 CAN FD 的常用工具的兼容性。\n\n请参阅 （略微）高级 CAN 概念部分，了解您可能会遇到但并非严格必需继续本指南的其他 CAN 概念。\n\n\n连接到 CAN#\n\n要连接到 CAN 总线，只需将 CAN 接收器的 CANH 和 CANL 线缆分别连接到 CAN 总线的 CANH 和 CANL\n线缆即可。在实际车辆中，这通常会通过位于仪表盘下方的车载诊断（OBD-II）数据链路连接器来实现。\n在真实车辆上进行实验确实存在风险：你可能并不希望冒着损坏一辆未来多年仍打算在公共道路上行驶的车辆的风险。 RAMN 旨在用一个嵌入小型化架构中的简单四 ECU\n网络来替代真实车辆，以促进汽车系统的教育与研究。\n\nRAMN 内置了一个 USB 转 CAN 适配器。 将 RAMN 连接到你的电脑，相当于将 USB 转 CAN 适配器连接到车辆的 OBD-II\n端口，但无需承担任何风险。\n\nCAN 仅支持广播传输：所有 ECU 始终看到相同的流量。无论你在 CAN 上接收到什么，其他每个 ECU 看到的都完全一致；ECU 通常会使用 CAN\n过滤器，仅处理它们所需的报文。\n\n借助 CAN，你可以：\n\n * 随时连接或断开 CAN 总线（热插拔）。\n * 无需采用 ARP 欺骗等中间人技术，即可观察 ECU 之间的 CAN 流量。\n\n\n在计算机上观察 CAN 流量#\n\n计算机通常没有内置的 CAN 接口，因此需要一个专用接口才能连接到 CAN 总线。\n\n市面上有许多 USB 转 CAN 适配器可供选择。如果您拥有此类适配器，可以将其连接到 RAMN 的接线端子，并按照随附的指南开始您的实验。\n\n本指南的其余部分将假定您使用 RAMN 内置的 USB 转 CAN 适配器。RAMN\n实现了“slcan”协议，也称为“LAWICEL”或“串行”协议，该协议受到许多 CAN 分析软件工具的支持。\n\n当您将 RAMN 用作 USB 转 CAN 适配器时，需要将接口类型指定为“slcan”，并将 RAMN 的串口作为通道（通常为 COMx 或\n/dev/ttyACMx）。\n\n\n简单示例#\n\nPython-CAN（Windows、Linux）#\n\n请确保您的计算机上已安装 Python（参见分析环境）。将您的开发板连接到计算机，打开 Windows 的设备管理器，并在“端口（COM 和\nLPT）”中查找新出现的设备。RAMN 通常会被分配一个 COM 端口号，例如“COM1”。\n\n在 Linux 系统上，您可以通过执行命令 dmesg 并查看最后几行来找到设备名称（通常为 /dev/ttyACM0）（如果您使用的是虚拟机，请确保已将\nUSB 设备转发到该虚拟机）。\n\n打开命令窗口（在 Windows 上可打开 PowerShell 或按 Windows+R），并执行以下命令，以观察每个 CAN ID 的最新 CAN 帧：\n\n\n\n\n\n这可能需要您使用命令 python -m pip install \"python-can[viewer]\" 安装 Python 模块。按 Q\n键退出。从这里开始，您应该能够直接在 RAMN 中使用 python-can 脚本 。如果遇到问题，请参阅 USB 不稳定。\n\nSavvyCAN（Windows、Linux）#\n\n如果您不习惯使用命令行，可以尝试使用带有图形界面的替代工具 SavvyCAN。只需下载最新的 SavvyCAN 二进制文件并进行安装。（在 Linux 上，下载\n.AppImage 文件，并通过输入 chmod +x file.AppImage 命令使其可执行，然后通过输入 ./file.AppImage 来运行）\n\n * 打开应用程序，然后在顶部栏中点击“连接 -> 打开连接窗口”。\n * 选择“添加新设备连接”。\n * 选择 LAWICEL/ SLCAN 串口。\n * 输入正确的串口（例如：/dev/ttyACM0 或 COM1）。\n * 使用默认的串口速率。\n * 输入正确的 CAN 总线速率（默认为 500000）。\n * 点击“创建新连接”。\n * （可选：点击“保存总线设置”）\n\n\n\n务必选择正确的 CAN 总线速率（切勿与串口速率混淆）。之后您可以关闭窗口，并应能够观察到 CAN 消息。\n\n\n\n有关如何使用该软件，请参阅 SavvyCAN 文档 。\n\n\n与 Linux 的接口#\n\n在本指南的剩余部分，我们将重点介绍 Linux 和常被汽车爱好者使用的 can-utils 软件包 。Linux 将 CAN\n作为标准接口支持，这意味着您可以像使用任何其他 Linux 接口一样使用它。\n\n\n将 slcan 转换为 socketCAN#\n\n您可以通过输入 dmesg 并查找最近添加的设备来确定 RAMN 的\nslcan（串口）被赋予了哪个名称，该设备应以“/dev/ttyACM”开头。如果您未看到任何设备，请确保您的 RAMN 已通过 USB 连接，并且 USB\n设备已转发到您的虚拟机（如适用）。\n\n某些工具，例如 wireshark，可能不直接支持 slcan，但可能支持 socketCAN 等接口。对于这些工具，您可以执行以下命令，将 slcan\n接口（例如 /dev/ttyACM0）转换为 socketCAN 接口（例如 can0）：\n\n\n\n执行此命令后，您应该能够通过 ifconfig 命令看到一个新的“can0”接口。这将使您能够使用 can-utils\n软件包中的工具，这些工具在下一节中有详细说明。在某些环境中，您可能会遇到上述命令的问题。如果出现这种情况，请尝试为 CAN\n接口指定一个不同的名称，例如，在所有后续命令中使用“slcan0”代替“can0”。\n\n\n\n在 Linux 系统中，同一时间只能有一个程序打开串行设备，但多个程序可以同时打开 CAN 接口。这意味着，如果你直接使用 slcan，每次只能执行一条 CAN\n命令；而如果使用 socketCAN，则可以并行执行多条命令。通常情况下，如果某个工具同时支持 socketCAN 和 slcan，你应该优先选择\nsocketCAN。\n\n注意\n\n当通过 slcan 使用串口时，系统可能会要求你输入两个波特率/比特率：一个是串口的波特率，另一个是 CAN\n总线的波特率。串口的波特率并不重要，因为它只是虚拟的；然而，CAN 总线的波特率却至关重要，必须正确设置（默认为 500000 bps）。\n\n警告\n\n在启动 slcand 之前，请确保没有其他程序正在使用 RAMN 的串口。一旦你运行 slcand，该串口将一直处于占用状态，其他程序（例如\nTeraTerm）将无法访问它。你可以通过以下命令关闭 slcand 并释放串口：\n\n\n\n\nCAN 波特率#\n\n您可以使用 -s 选项更改 slcan 适配器的 CAN 波特率，该选项接受一个整数，对应于以下波特率：\n\n * 0 - 10000 bps\n * 1 - 2000 bps\n * 2 - 5000 bps\n * 3 - 100000 bps\n * 4 - 125000 bps\n * 5 - 250000 bps\n * 6 - 500000 bps（RAMN 默认值）\n * 7 - 800000 bps\n * 8 - 1000000 bps\n\n例如， sudo slcand -o -c -s8 /dev/ttyACM0 将以 1000000 bps 的 CAN 波特率打开 RAMN。\n请注意，这仅适用于适配器（ECU A），而不适用于其他 ECU，因此默认情况下这里应仅显示 CAN 错误。 如果您想使用不同于默认 500000 bps\n的波特率，您必须重新刷新所有 ECU，或者使用 UDS 链接控制服务（参见与 UDS 交互）。\n\n\nRAMN 的 vcand 脚本#\n\nslcand 命令存在两个缺点：\n\n * 它不支持 CAN FD。\n * 它会独占 RAMN 的串口，从而阻止您发送串行命令。\n\n您可以使用 RAMN 的 vcand 脚本来创建虚拟的额外串行接口，并将串行接口转换为 CAN FD socketCAN 接口。\n\n有关使用方法，请参阅 vcand。\n\n请注意，截至 2024 年，这些脚本是用 Python 实现的，并未针对低 CPU 占用率进行优化。\n\n\n在 Linux 上试验 CAN#\n\n\nCansniffer#\n\ncansniffer 可能是你在新网络上首先想要尝试的命令。它允许你观察每个 CAN 标识符的最新帧\n\n你可以使用以下命令启动它：\n\n\n\n\n\n要退出，请按“q”键后按回车键，或按“Control+C”。\n\n如果您希望以二进制格式查看 CAN 消息，可以使用-B（或-b）选项：\n\n\n\n\n\n一旦启动 cansniffer，您仍然可以输入命令，这些命令列于 cansniffer 的帮助页面中（直接在 cansniffer 窗口中输入命令并按\nENTER 键）。\n\n在现代汽车网络中，你很可能会被大量信息淹没，因为即使车辆处于空闲状态，也应存在许多带有多个字节变化的 CAN 报文。这是因为 CAN\n报文可能实现了复杂的算法，并包含诸如报文计数器、循环冗余校验（CRC）和消息认证码（MAC）等易变字段。\n\n一个用于过滤易变字段的实用命令是“#”（井号）命令，它允许 cansniffer 停止高亮显示那些已经观察到的字节变化。这样，在后续操作中（例如移动 RAMN\n控件时），新的变化会更加明显。\n\n尝试连续多次输入“#”命令，期间不要触碰任何控制装置。你应该会发现，被彩色高亮显示的位数逐渐减少。接下来，移动 RAMN 板上的制动控制装置，并观察\ncansniffer：由 ECU B 发送的制动消息的 2 字节有效载荷应会被高亮显示，便于你快速识别。此外，当你在 0%到\n100%之间踩动制动踏板时，还应注意到另一条 CAN 消息中的某个位也在翻转；该位对应于 ECU D 的制动 LED\n状态（如果未出现此现象，请确认手刹处于底部位置）。由于各 ECU 之间存在交互作用，你不能假定单一控制仅影响一条 CAN 消息，因此识别 CAN\n消息的具体用途可能会比较棘手。\n\n注意\n * 对于模拟控制装置，即使没有移动控制部件，你也可能会发现最后几位一直在变化。这是由传感器的模拟噪声引起的。\n * 整数可以用大端模式或小端模式表示。RAMN 采用的是 ARM 微控制器，其使用小端模式。这意味着在 cansniffer\n   上，有效载荷可能会以“错误的顺序”显示：例如，一个值为 0x0FFF 的数据可能会显示为 0xF0FF。\n\n如果您想从 cansniffer 中过滤掉某些报文，可以使用“-”命令（例如，“-024”用于隐藏 0x024\n报文）。您也可以使用“n”命令来过滤所有报文，然后通过“+”命令添加特定报文以进行观察（例如，“+024”仅显示 0x024\n报文）。再次使用“a”命令即可显示所有报文。\n\n\nCandump#\n\n尽管 cansniffer 是一个用于概览 CAN 总线流量的优秀工具，但它仅显示每个标识符的最新帧。若要按出现顺序观察所有 CAN 帧，可以改用\ncandump。\n\n\n\n按 Control+C 退出。您可以使用 -tz 选项添加时间戳，使用 -a 选项添加 ASCII 输出。\n\n\n\n并非所有消息都具有相同的周期，因此你会更频繁地观察到某些消息，而其他消息则较少。candump 的主要用例有两个：\n\n * 要记录 CAN 流量，例如为了稍后离线分析（比如，如果你必须与他人共享你的 RAMN 板）。\n * 用于分析特定 CAN 消息的流向。\n\n要将 CAN 流量记录到文件中，可以使用-l 选项：\n\n\n\n这会将 CAN 流量记录到一个自动生成名称的文件中。如果你希望指定文件名，可以改用-f <文件名>（此功能可能仅在较新版本中可用）。\n\n在实际网络中，你可能会观察到大量的帧，导致 candump 的输出过多而难以处理。通常情况下，你会希望先使用 cansniffer\n识别出感兴趣的标识符，然后再通过 candump 结合过滤器对这些标识符进行进一步分析。有关过滤器的更多信息，请参阅 CAN 过滤器 章节。\n\n您可以在 candump 中通过在接口名称后添加 ,<value>:<mask> ，并以十六进制形式指定值来应用过滤器。例如：\n\n\n\n您应该在 RAMN 上观察到，尽管 candump 的输出非常庞大，但上述命令的输出却并非如此。您可以为 candump 添加多个过滤器，例如，要观察 ID 为\n0x1BB 和 ID 为 0x1D3 的消息，可以使用以下命令：\n\n\n\n这有助于识别 CAN\n报文之间的关系，例如：将制动踏板置于零位，同时将手刹置于底部位置。这样应确保制动指示灯处于关闭状态。当您拨动手刹开关时，您应该会看到制动指示灯亮起。在\ncansniffer 中，您可以看到两个 CAN ID（0x1BB 和 0x1D3）的有效载荷随之发生变化。由于指示灯和开关分别位于不同的 ECU\n上，您可以推断其中一条 CAN 报文可能指示了制动指示灯的状态，而另一条则指示了开关的状态，但您无法确定哪条对应哪个状态，因为在 cansniffer\n中它们似乎同时发生变化。\n\n如果你在拨动开关的同时使用上述命令，会发现 0x1D3 的值会在 0x1BB 之前发生变化，由此可以推断出 0x1D3 代表开关的值，而 0x1BB 则代表\nLED 的状态（该状态会因接收到 0x1D3 消息而改变）。\n\n\n\n\nCansend#\n\nCansend 允许你通过指定 CAN ID 和有效载荷（以十六进制表示）来发送 CAN 消息。\n\n例如，要发送一个 CAN ID 为 0x123 且有效载荷为单字节 0xFF 的消息，可以使用以下命令：\n\n\n\n利用 cansend，你可以验证这样一个假设：0x1BB 代表 LED 状态，而 0x1D3 代表手刹开关状态。首先，在手刹处于 ON\n位置（顶部位置）时记录来自 1BB 的消息，然后将手刹拨至 OFF 位置（底部位置）。请确保制动踏板处于 0%位置，且不会对刹车 LED 产生干扰。\n\n你可以使用 cansend 重放一条 CAN 消息（在本示例中，负载为 07008A756501D87F）：\n\n\n\n通过发送这条消息，你是在告诉所有 ECU“刹车指示灯已亮”，但仅凭这一点并不会使指示灯真正点亮。然而，如果你在手刹处于开启状态时记录了一条 CAN ID 为\n0x1D3 的消息，并在手刹关闭时再次发送该消息，你应该会观察到刹车指示灯会短暂地亮起：\n\n\n\n这是因为该消息显示“手刹开关已开启”，这本身会导致 ECU D 点亮刹车 LED 指示灯。然而，这种点亮只是暂时的，因为 ECU B 仍在持续发送消息（告知各\nECU 手刹开关处于关闭状态），从而立即覆盖你所发送的任何数值。\n\n你可以使用简单的 bash 脚本自动化某些传输任务，例如，如果你想连续发送一条消息 100 次：\n\n\n\n或者，如果你想以相同的消息向 CAN 总线持续发送 2 秒钟：\n\n\n\n警告\n\n如果你发送的 CAN 消息通常由另一个 ECU 正常传输，而该 ECU 仍在主动发送数据，你可能会产生 CAN 错误。如果错误次数过多，可能会导致 ECU\n被迫与 CAN 总线断开连接（参见 错误帧与总线关闭 ）。默认情况下，只有通过电源复位才能使 ECU 重新连接，但你可以配置 RAMN 的 ECU\n使其自动重新连接。\n\n您还可以使用 cansend 发送设置了 RTR 位标志的消息，其参数为 <can id>#R<dlc> 。RAMN 的 ECU B、C 和 D\n将分别使用其硬件序列号响应 ID 为 0x701、0x702 和 0x703 的 CAN RTR 帧。\n\n您可以在 candump 中显示这些消息，方法如下：\n\n\n\n此外，在另一个终端中，你可以发送 RTR 帧：\n\n\n\n这应该会产生以下结果：\n\n\n\n\nCanplayer#\n\n您可以使用 canplayer“重放文件”（即发送日志文件中捕获的所有 CAN 消息），这些文件是由 candump\n生成的。您需要指定两个接口作为参数：一个是用于读取文件中消息的接口，另一个是用于发送相同消息的接口。通常情况下，您会希望使用相同的接口：\n\n\n\n如果遇到错误，请尝试执行 sudo ifconfig can0 txqueuelen 10000 。\n\n在这里，我们指定 can0=can0，因为我们希望从接口 can0（在文件中）读取消息，并在 can0（实际硬件）上进行重放。\n\n当您需要重复特定的 CAN 消息序列时，Canplayer 非常有用，例如重复一个被分割成多个 CAN 消息的 UDS 命令。此外，当您希望将某个 ECU\n与它通常连接的 CAN 总线隔离时，Canplayer 也非常实用。许多 ECU 在未检测到正常 CAN 通信时会进入睡眠状态，因此通过 canplayer\n以无限循环方式运行（使用“-l i”选项）可以避免这种情况：\n\n\n\n现代 ECU 可能无法很好地应对 canplayer，因为它们具备消息认证机制，可防止 ECU 接受重放的消息。\n\n\nWireshark（Linux）#\n\n如果你熟悉 Wireshark，可以直接启动它，并直接观察你的 socketCAN 接口（例如，你可以直接打开 can0）。你应该能够应用常规的\nWireshark 过滤器，并且 Wireshark 应该能够解析复杂的 CAN 流量，比如 UDS 命令。\n\n\n\n\n（略微）高级 CAN 概念#\n\n\nCAN 总线终端电阻#\n\n为了实现阻抗匹配 ,CAN 要求在 CANH 和 CANL 线路的每一端各连接一个 120 欧姆的电阻（这些线路对所有 ECU 都是共用的）。RAMN\n上已经内置了这些电阻，因此如果你使用外部工具，请确保该工具没有自带终端电阻（通常可以通过移除跳线或拨动开关来实现）。\n\n\n显性位与隐性位#\n\nCAN 仅需两根线：CANH 和 CANL，所有 ECU 共用。要传输“零”位，CAN 收发器会在 CANH 和 CANL 之间产生 2V 的电压差（ 显性位\n）。要传输“一”位，CAN 收发器则不作任何操作（ 隐性位 ），此时 CANH 和 CANL 之间的电压差为 0V。\n\n如果两个收发器同时尝试发送不同的位，则该位的值将取显性位的值，即0。\n\n\n标志位及其他 CAN 总线字段#\n\nCAN ID 和有效载荷是 CAN 帧中最重要的字段，但还存在其他字段：\n\n * 帧起始位（SOF）是每个 CAN 帧的第一个位，用于同步接收器。\n * 远程传输请求位（RTR）是一个用于请求发送特定 CAN ID 的位，但在实际应用中并未使用。\n * 标识符扩展位（IDE）用于指定标识符的长度是 11 位还是 29 位。\n * 数据长度代码（DLC）字段用于指定有效载荷的大小。该字段为 4 位，因此取值范围为 0 到 15，但只有 CAN FD 支持超过 8 字节的有效载荷。\n * 循环冗余校验（CRC）位用于验证帧的完整性。\n * 确认位由接收方用于指示 CAN 帧已正确接收。\n * 帧结束（EOF）字段和帧间间隔（IFS）字段是在确认之后的一段静默期。\n\n这些字段周围有时会存在分隔符和保留位。\n\n\n位填充#\n\nCAN 帧以比特流形式传输，具有标称比特率。为确保 CAN 总线上观察到足够多的电压跳变，以实现时钟同步，CAN 采用了位填充机制：\n\n * 如果帧中出现连续五个0，则必须在第五个比特后插入一个1。\n * 如果帧中出现连续五个1，则必须在第五个比特后插入一个0。\n\n例如，如果 CAN 控制器要发送标识符 0x3E0（二进制为 0001111100000），则该标识符的比特流将为 000111110000001。\n\n位填充和去填充是在硬件中完成的，因此除非您使用逻辑分析仪观察 CAN 电压，否则您将无法察觉到位填充的存在。位填充不适用于 CRC 之后的字段。\n\n\n错误帧与总线关闭#\n\n如果 CAN 帧出现异常（例如位填充错误、CRC 错误等），总线上的 ECU 会检测到该问题。\n\nECU 的默认行为是假设“我正确，而 CAN 总线有错”，并为所有节点破坏当前的 CAN 帧（“错误主动”状态）。具体来说，当 ECU\n检测到错误时，它会立即通过发送一个错误帧来通知其他节点，该错误帧由六个连续的显性位（零）组成。由于这些位是显性的，它们必然会覆盖正在进行的任何传输；同时，六个连\n续的零违反了位填充规则，从而确保所有其他可能未察觉到错误的 ECU 也能检测到该错误。\n\nECU 内部设有计数器，当检测到错误时会递增，而检测到有效帧时则会递减。如果这些计数器达到某个阈值，它们便会开始认为“我可能是导致 CAN\n错误的原因”，并停止使用主动错误帧来破坏帧（此时它们会变为“错误被动”状态）。\n\n如果错误持续发生，ECU 将判定自身应进入“总线关闭”状态，并与 CAN 总线断开连接。如果你为 CAN 接收器设置了错误的波特率，就会遇到总线关闭的问题。\n\n点击此链接以了解更多关于 CAN 错误的信息。CAN 协议定义的错误包括：\n\n * 位错误 ：（仅限发送端）ECU 尝试发送一位数据，但在总线上却观察到了不同的位。\n * 填充错误 ：位填充未正确执行。\n * CRC 错误 ：CRC 与预期值不匹配。\n * 格式错误 ：某个固定位未达到预期值（例如，ECU 观察到第一个 EOF 位为零，但该位本应始终为一）。\n * 确认错误 ：（仅限发送方）未检测到 ACK 位为显性电平（无人进行确认）。具体细节请参阅下文。\n\n与错误帧类似的还有过载帧 。它们的形式与错误帧相同，但不会增加错误计数器。过载帧只能在 IFS 字段（即“间隔期”）传输期间发送，原因可能是某个 ECU\n需要额外时间来处理帧，或者某个 ECU 检测到其他 ECU 违反了间隔期规定。\n\n警告\n\n默认情况下，RAMN ECU 启用了“自动重传”CAN 设置。这意味着当出现故障（例如短路）时，ECU\n会迅速进入总线关闭模式，因为它们会在发生错误后立即尝试重新传输，并很快达到计数器限制。您可以通过将\nhfdcan1.Init.AutoRetransmission = ENABLE; 更改为 hfdcan1.Init.AutoRetransmission =\nDISABLE; （在 main.c 中）并重新编译固件来更改此行为。此外，您也可以使用 AUTO_RECOVER_BUSOFF\n配置标志，以自动从总线关闭事件中恢复。\n\n\n致谢#\n\nCAN\n帧包含一个“ACK”位，该位始终为显性电平，并且必须由所有接收方发送，以确认它们已正确接收到该帧。需要注意的是，这一位（且仅这一位）是由多个接收方发送的，而非帧\n的发送方。\n\nACK 位必须始终由接收方发送，即使它们已激活过滤器且对接收到的帧并不感兴趣。\n\n一些 CAN 控制器具有仅监听模式，通常不会对帧进行应答。这种应答机制的一个后果是，CAN 总线必须始终拥有至少两个活动的 ECU。\n\n\nCAN 过滤器#\n\n由于 CAN 协议仅允许广播帧，ECU 会接收到大量它们并不需要的消息，从而造成过载。因此，CAN 控制器通常提供多种选项来设置各种 CAN\n过滤器，以便仅接收它们关心的标识符对应的消息。\n\n现代微控制器支持多种类型的过滤器，但传统上，一个过滤器由一个值和一个掩码定义。诸如 candump 之类的工具接受以下格式的过滤器：\n\n我们以标准标识符的接收过滤器为例，此类标识符长度为11位。掩码和值的长度均与标识符相同。\n\n掩码 0x7FF 对应的二进制为 11111111111，表示您关心标识符中的所有位 。因此，CAN 滤波器将仅接受标识符与该值完全一致的消息。例如，与\ncandump 配合使用的滤波器“1BB:7FF”将仅显示 ID 为 0x1BB 的 CAN 消息。\n\n\n\n掩码 0x000 对应的二进制为 00000000000，表示您不关心标识符中的任何一位 。这意味着 CAN 滤波器将接受所有标识符（CAN\n控制器可能对扩展和标准标识符需要不同的滤波器，因此您仍可能拒绝扩展标识符）。\n\n如果您使用滤波器“1BB:000”启动 candump，它将显示所有 ID——这里的 1BB\n没有任何影响，因为掩码表明所有位都不重要。此掩码与“000:000”和“FFF:000”是等效的。\n\n\n\n掩码不必非得是 0x000 或 0x7FF，你也可以使用它们来指定更高级的条件。\n\n例如，你可以使用001:001（仅关注最低位，且该位应为1）来仅显示奇数标识符，或者使用000:001（仅关注最低位，且该位应为0）来仅显示偶数标识符。\n\n\n\n要指定一个范围，可以使用以 1 开头、以 0 结尾的掩码。一个常见的过滤器是你需要记住的 7e0:7F0。此过滤器表示你希望显示从 0x7e0 到 0x7ef\n范围内的 CAN ID，这些 ID 对应于 RAMN 中的 UDS 诊断消息。\n\n\n\n\n位定时#\n\nCAN 总线具有单一固定的标称波特率，在现代车辆中通常为 500 kbps。大多数 CAN 工具会允许你直接指定 CAN\n总线的波特率，但有些工具可能会要求你提供具体的位定时参数。\n\n理论#\n\nCAN 协议将单个比特划分为若干个时间量子 。一个时间量子对应于 CAN 控制器时钟的周期 。RAMN 的 CAN 控制器采用 40 MHz\n的时钟，因此相应的时间量子为 25 ns。\n\nCAN 控制器认为一个位由四个段组成，每个段由若干时间量子构成：\n\n * 同步段。\n * 传播段。\n * 相位缓冲段1。\n * 阶段缓冲区段 2。\n\nECU 均依赖于不同的时钟，这些时钟并不完美，存在轻微的同步偏差。CAN 控制器可以通过动态调整相位缓冲段 1 和相位缓冲段 2 的长度来调节 CAN\n帧位的长度。同步跳转宽度（SJW）参数指定了这些调整的最大范围。\n\n采样点对应于相位缓冲段 1 的末端和相位缓冲段 2 的起始位置，是 CAN 接收器实际观测 CAN\n信号电压的时间点。如果采样点过早，可能会在电压尚未稳定时就进行读取（例如由于振铃现象）。如果采样点过晚，则可能读取到下一个位的信息。通常建议将采样点设置在\n75%到 90%之间。\n\n实践#\n\n同步段始终为一个时间量子长度。在实际应用中，传播段和相位缓冲段 1 经常被合并为一个单独的段。因此，STM32 CAN 控制器（以及一般的 CAN\n控制器）会要求您提供两个用于决定波特率的值：\n\n * TSEG1：传播段与相位缓冲段 1 的总长度。\n * TSEG2：阶段缓冲区 2 段的大小。\n\n您需要选择 TSEG1 和 TSEG2，以满足以下条件：\n\n\n\n其中，乘数为您的 CAN 位时间与 CAN 控制器时间量子之间的比率。\n\n例如，如果您的 CAN 控制器时钟为 40 MHz（时间量子为 25 纳秒），而您希望 CAN 波特率为 500 kbps（位时间为 2 微秒），则您的乘数为：\n\n\n\n因此，只要满足以下条件，您可以任意选择 TSEG1 和 TSEG2：\n\n\n\nRAMN 使用 TSEG1 = 60 和 TSEG2 = 19，因此采样点位于 76%（即 (60 + 1) / 80）。然而，它也可以使用其他组合，例如\nTSEG1 = 69 和 TSEG2 = 10，此时仍会得到完全相同的波特率。\n\n对于 SJW 值，应从最低值开始，如果遇到 CAN 错误，则将其调高。\n\n\nCAN FD#\n\n具有灵活数据速率的控制器局域网（CAN FD） 是 CAN 的最新演进版本，支持更高的带宽。RAMN 与 CAN FD 兼容。本节总结了在使用 CAN FD\n替代 CAN 时您应了解的最低要求。\n\n尽管 CAN FD 控制器能够理解和传输经典 CAN 帧，但经典 CAN 控制器无法识别 CAN FD 帧，因此会破坏这些帧 。如果您希望传输 CAN FD\n帧，需确保总线上的所有 ECU 均与 CAN FD 兼容（默认情况下，RAMN 即为此情况）。\n\nCAN FD 允许的最大有效载荷为 64 字节。DLC 字段大小（4 位）保持不变，而大于 8 的 DLC 代表特定的尺寸：\n\n * DLC 为 9 表示有效载荷大小为 12。\n * DLC 为 10 表示有效载荷大小为 16。\n * DLC 为 11 表示有效载荷大小为 20。\n * DLC 为 12 表示有效载荷大小为 24。\n * DLC 为 13 表示有效载荷大小为 32。\n * DLC 为 14 表示有效载荷大小为 48。\n * DLC 为 15 表示有效载荷大小为 64。\n\nCAN FD 引入了“比特率切换”功能：CAN\n控制器在传输数据时可以提高波特率（即缩短比特时间）。当设置比特率切换（BRS）标志时，就会发生比特率切换。因此，CAN FD\n控制器会请求两组不同的比特定时参数：“标称”和“数据”。\n\nCAN FD 在 CAN FD 帧中增加了一个“错误状态指示器”位标志，用于指定该帧的发送方当前处于主动错误模式还是被动错误模式（参见 错误帧与总线关闭 ）。\n\nCAN FD 中不存在 RTR 标志。\n\n实际上存在 CAN FD 的两个版本 ：“ISO CAN FD”和“非 ISO CAN FD”，由于存在细微的协议差异，两者互不兼容。","routePath":"/docs/userguide/can_tutorial","lang":"","toc":[{"text":"简介","id":"简介","depth":2,"charIndex":3},{"text":"连接到 CAN","id":"连接到-can","depth":2,"charIndex":1127},{"text":"在计算机上观察 CAN 流量","id":"在计算机上观察-can-流量","depth":2,"charIndex":1621},{"text":"简单示例","id":"简单示例","depth":3,"charIndex":1942},{"text":"Python-CAN（Windows、Linux）","id":"python-canwindowslinux","depth":4,"charIndex":1949},{"text":"SavvyCAN（Windows、Linux）","id":"savvycanwindowslinux","depth":4,"charIndex":2410},{"text":"与 Linux 的接口","id":"与-linux-的接口","depth":2,"charIndex":2876},{"text":"将 slcan 转换为 socketCAN","id":"将-slcan-转换为-socketcan","depth":3,"charIndex":2994},{"text":"CAN 波特率","id":"can-波特率","depth":3,"charIndex":3863},{"text":"RAMN 的 vcand 脚本","id":"ramn-的-vcand-脚本","depth":3,"charIndex":4295},{"text":"在 Linux 上试验 CAN","id":"在-linux-上试验-can","depth":2,"charIndex":4516},{"text":"Cansniffer","id":"cansniffer","depth":3,"charIndex":4535},{"text":"Candump","id":"candump","depth":3,"charIndex":5608},{"text":"Cansend","id":"cansend","depth":3,"charIndex":6677},{"text":"Canplayer","id":"canplayer","depth":3,"charIndex":7689},{"text":"Wireshark（Linux）","id":"wiresharklinux","depth":3,"charIndex":8199},{"text":"（略微）高级 CAN 概念","id":"略微高级-can-概念","depth":2,"charIndex":8350},{"text":"CAN 总线终端电阻","id":"can-总线终端电阻","depth":3,"charIndex":8367},{"text":"显性位与隐性位","id":"显性位与隐性位","depth":3,"charIndex":8517},{"text":"标志位及其他 CAN 总线字段","id":"标志位及其他-can-总线字段","depth":3,"charIndex":8704},{"text":"位填充","id":"位填充","depth":3,"charIndex":9079},{"text":"错误帧与总线关闭","id":"错误帧与总线关闭","depth":3,"charIndex":9369},{"text":"致谢","id":"致谢","depth":3,"charIndex":10438},{"text":"CAN 过滤器","id":"can-过滤器","depth":3,"charIndex":10645},{"text":"位定时","id":"位定时","depth":3,"charIndex":11453},{"text":"理论","id":"理论","depth":4,"charIndex":11551},{"text":"实践","id":"实践","depth":4,"charIndex":11976},{"text":"CAN FD","id":"can-fd","depth":3,"charIndex":12478}],"domain":"","frontmatter":{},"version":""},{"id":35,"title":"与 UDS 交互","content":"#\n\n在“与 ISO-TP 交互”一节中介绍的 ISO-TP 层允许发送和接收最大长度为 4095 字节的任意有效载荷。现代车辆中的 ECU 很可能会将 ISO-TP\n数据解释为本节所述的 UDS 命令。\n\n\nUDS 基础知识#\n\n统一诊断服务 (UDS) 是一种用于 ECU 诊断和编程的协议。网上有许多相关的教程，你也可以找到总结其工作原理的海报。\n\nUDS 遵循简单的请求-响应机制：你向 ECU 发送一个有效载荷，然后会收到一个作为响应的有效载荷。\n\n请求的第一个字节表示服务 ID；有效载荷的其余部分则表示该服务的参数。第二个字节通常（但并非总是）表示服务的子功能。\n\n应答的第一个字节表示对请求的响应：要么是肯定响应（服务 ID + 0x40），要么是否定响应（0x7f）；有效载荷的其余部分则代表参数。\n\n\nRAMN 标准 UDS 服务#\n\nRAMN ECU 支持多种 UDS 服务。它们为此使用以下 ISO-TP CAN ID：\n\n * ECU A 使用 0x7e0 接收命令，使用 0x7e8 发送应答。\n * ECU B 使用 0x7e1 接收命令，使用 0x7e9 发送应答。\n * ECU C 使用 0x7e2 接收命令，使用 0x7ea 发送应答。\n * ECU D 使用 0x7e3 接收命令，使用 0x7eb 发送应答。\n * 所有 ECU 均使用 0x7df 通过功能寻址接收命令（命令广播）。\n\n如果您将 ECU A 用作 USB 转 CAN 适配器，则它不会通过 CAN 回应您的 UDS 请求；您应改用 USB 串行接口。\n\n您可以通过查看 ramn_uds.c 源代码文件来确认 ECU 支持哪些标准服务：\n\n * 服务 0x10（诊断会话控制）\n * 服务 0x11（ECU 复位）\n * 服务 0x14（清除诊断信息）\n * 服务 0x19（读取 DTC 信息）\n * 服务 0x22（按标识符读取数据）\n * 服务 0x23（按地址读取内存）\n * 服务 0x27（安全访问）\n * 服务 0x2E（按标识符写入数据）\n * 服务 0x31（例程控制）\n * 服务 0x34（请求下载）\n * 服务 0x35（请求上传）\n * 服务 0x36（传输数据）\n * 服务 0x37（请求传输退出）\n * 服务 0x3D（按地址写入内存）\n * 服务 0x3E（测试人员存在）\n * 服务 0x85（控制 DTC 设置）\n * 服务 0x87（链路控制）\n\n除了标准服务之外，ECU A 还增加了两项自定义服务：\n\n * 服务 0x41（在屏幕上显示指定像素）\n * 服务 0x42（加载并启动提供的 Chip-8 游戏）\n\n这些服务将在本指南的后续部分进行说明。\n\n服务 ID 低于 0x10 的诊断服务由 J1979 标准定义，并在 J1979 服务（OBD-II PIDs）中进行了说明。\n\n警告\n\nRAMN ECU 的 UDS/J1979 实现经过了轻微简化（包含大量虚拟参数），以更好地容错并更适合初学者使用。您尤其需要注意以下与实际 ECU\n可能存在的差异：\n\n * RAMN ECU 采用普通寻址方式，但实际应用中的 ECU 可能会使用不同的寻址方法（参见寻址方式）。\n * 默认情况下，RAMN ECU 接受填充和未填充的 CAN 消息。而在实际应用中，ECU 可能仅接受填充的 CAN 消息（CAN 消息长度为 8）。您可以将\n   -p 0:0 选项与 isotpsend 结合使用，以零字节对 CAN 消息进行填充。\n\n当您使用功能寻址时，只能使用单帧命令（有效载荷小于 7 字节）。如果 ECU 无法处理以功能寻址方式接收到的命令，通常将完全不会作出响应。\n\n\n正面响应#\n\n如果 ECU 接受了您的请求，它将以一个有效载荷作为响应，该有效载荷以您所请求的服务 ID 加上 0x40 开头。例如，如果您请求的服务 ID 是\n0x3E，并且 ECU 接受了该请求，则其响应将以 0x7E（0x3E + 0x40）开头。如果您请求的服务 ID 是 0x10，并且 ECU\n接受了该请求，则其响应将以 0x50（0x10 + 0x40）开头。\n\n服务通常允许您通过将服务参数的第一个比特设置为“1”（抑制肯定响应）来禁用肯定响应。\n\n\n负面响应#\n\n如果 ECU 拒绝了您的请求，它将以一个以 0x7F 开头的三字节有效载荷进行回复。其中，第二个字节表示被拒绝的服务，第三个字节表示错误代码。您也可以在\nramn_uds.c 中找到可能的错误代码列表。您最有可能遇到的错误代码包括：\n\n * 0x11 - “服务不支持”。\n * 0x12 - “子功能不支持”：这意味着该服务很可能受支持，只是您请求的特定子功能不受支持。\n * 0x13 - “消息长度错误或格式无效”：这意味着该服务（以及适用时的子功能）是受支持的，但您的请求大小无效（参数字节数过多或不足）。\n * 0x31 -\n   “请求超出范围”：这意味着您的请求格式有效且受支持，但参数超出了有效范围。例如，您尝试读取一个不存在的内存地址（但您提供的地址格式是有效的）。\n * 0x33 - “安全访问被拒绝”：这意味着在使用该服务之前，您需要先解锁（参见安全访问 (0x27)）。\n * 0x7E - “活动会话中不支持该服务”：这意味着您必须首先请求一个不同的诊断会话（参见诊断会话控制 (0x10)）。\n\n您还可能遇到与时间相关的“错误”：\n\n * 0x21 - “忙，重复请求”：您的命令可能是正确的，但您必须稍后重试（您需要发送另一个请求）。\n * 0x78 - “请求已正确接收，响应待处理”：ECU 将稍后作出响应（您无需再次发送请求）。\n\n这些错误代码是极其宝贵的信息来源，有助于您学习如何正确使用 UDS 服务。\n\n\n使用 Linux 和测试仪存在 (0x3E) 的示例#\n\n您可以分别使用 isotpsend 和 isotprecv 来发送 UDS 命令并接收其响应。此外，您还可以使用 isotpdump 以 UDS 助记符显示\nUDS 流量，从而便于解析。\n\n如果您尚未完成，请确保将您的 RAMN 配置为 CAN Linux 接口（参见将 slcan 转换为 socketCAN）。\n\n例如，要与接口 can0 上的 ECU B（使用 CAN ID 0x7e1/0x7e9）进行交互，请打开终端并输入：\n\n\n\n此终端将显示您 UDS 请求的响应。再打开一个终端，并输入：\n\n\n\n该终端将显示 UDS 流量（包括请求和响应）。\n\n最后，打开第三个终端，你将使用它来输入你的 UDS 请求。例如，你可以通过以下命令发送一个 UDS 请求：\n\n\n\n其中“3E 00”表示你要使用“Tester Present”服务，并携带参数“0x00”。Tester Present 是一种简单的服务，用于告知 ECU\n当前正在进行操作，以防止其超时。\n\n你应该在 isotprecv 终端上观察到收到了回复“7E 00”：\n\n\n\n这里的 7E 等于 0x3E+0x40，表示 ECU 已接受你的请求（并以参数“0x00”进行响应）。你应该在 isotpdump\n终端上看到，它已自动为你解析了该请求：\n\n\n\n如果你发送了一个无效的命令，例如将“3E 00”误发为“3E 00 00”，你应该会观察到不同的 UDS 通信流量：\n\n\n\n\n\nECU 的响应为“7F 3E 13”。“7F”表示服务 ID 为“3E”的请求因错误代码“13”而被拒绝，正如您在 isotpdump\n终端中所看到的，“13”的含义是“消息长度错误或格式无效”。\n\n注意\n\n如果您想与除 ECU B 之外的其他 ECU 进行通信，则需要为所有命令更改 -s 和 -d 选项。您可以使用 candump can0,7e0:7f0 代替\nisotpdump 来显示任何 UDS 流量，但它不会为您解析 UDS 命令。\n\n对于许多服务而言，第一个参数仅为 7 位长，且第一位用于指示是否抑制正面响应。如果你使用参数“0x80”，实际上发送的是参数“0x00”，并要求 ECU\n在无错误时无需应答。\n\n例如，如果你输入以下命令：\n\n\n\n除非发生错误，否则你将不会收到来自 ECU 的任何响应。\n\n你可能希望使用别名来缩短上述命令。你可以通过以下脚本创建有用的别名：\n\n\n\n你需要为每个打开的终端执行此脚本（可以简单地将内容复制粘贴到终端中并执行）。执行之后，你将能够通过以下方式从 ECU B 接收数据：\n\n\n\n并简单地通过以下方式将数据发送至 ECU B：\n\n\n\n您也可以类似地使用命令别名 dumpECUB 来转储上述流量。\n\n\nRAMN UDS 服务#\n\n\n诊断会话控制 (0x10)#\n\n许多 UDS 服务默认情况下不可用，您首先需要使用诊断会话控制服务请求一个“诊断会话”。默认情况下，ECU 处于“默认会话”（代码\n0x01）。其他可能的标准会话包括“编程会话”（代码 0x02）、“扩展诊断会话”（代码 0x03）以及“安全系统诊断会话”（代码 0x04）。\n\n真实的 ECU 通常会验证车辆状态是否允许会话切换。例如，在驾驶车辆时，您不应能够启动编程会话。如果将 RAMN 连接到驾驶模拟器，ECU\n将检查车辆当前是否处于停止状态。如果未满足此条件，ECU 将以错误代码“0x22”进行响应，该代码表示“条件不正确”。\n\n要使用此服务，只需将会话代码作为唯一参数提供，例如启动一个编程会话：\n\n\n\n\n\n\nECU 重置 (0x11)#\n\n此服务可用于重置 ECU。它仅有一个参数，即重置类型。RAMN ECU 仅支持重置类型 0x01（硬重置），使用方法如下：\n\n\n\n或者，如果您不希望 ECU 在接收到请求时作出响应：\n\n\n\n警告\n\n如果 ECU 处于默认会话状态，则不会接受重置请求；您必须先使用诊断会话控制 (0x10) 才能使用此服务。\n\n此命令支持功能寻址。如果您希望同时重置所有 ECU，可以将这些命令发送至 ID 0x7df：\n\n\n\n请注意，这里的 -d 7e9 并不重要；该命令会被所有 ECU 接收并处理。\n\n\n\n\n按标识符读取数据 (0x22)#\n\n这是从 ECU 读取数据的一种常用服务。它接受两个字节作为参数，这两个字节代表您希望读取的 16 位数据标识符 (DID)。尽管某些 ECU 允许一次性读取多个\nDID，但 RAMN ECU 每次请求仅允许读取一个 DID。\n\n部分 DID 具有标准含义（请参阅本教程以获取列表）。例如，您可以使用 DID 0xF184 查询 ECU 固件的编译时间：\n\n\n\n\n\n您也可以使用 DID 0xF18C 查询 ECU 的序列号硬件（该硬件在每个 ECU 中应是唯一的）：\n\n\n\n\n\n警告\n\n通过 ID 读取数据可能会返回较长的数据负载，这意味着它们将通过 ISO-TP 进行分段传输。您必须主动设置一个 ISO-TP 接收器（例如，使用\nisotprecv -s 7e1 -d 7e9 -l can0 ）。如果没有激活的接收器，ECU\n将无法接收到继续传输所需的“流控制帧”，您只会观察到其响应中的“首帧”。\n\n\n通过标识符写入数据（0x2E）#\n\n您也可以使用 UDS 写入任意 DID。只需提供您想要写入的 DID 以及要写入的数据即可。例如，DID 0xF190 指的是 ECU\n的车辆识别码（VIN）。您可以使用通过标识符写入数据服务，将一个 17 位字符的字符串写入 DID 0xF190。请务必先启动一个编程会话：\n\n\n\n然后，使用通过标识符写入数据服务：\n\n\n\n现在，您应该能够使用通过标识符读取数据来读取之前写入内存的任意 VIN：\n\n\n\n\n\n该值被写入闪存，因此即使在复位后仍会保留。如果您重新刷写 ECU 并重置其内存，通过标识符读取数据服务可能会提示您的请求超出范围。\n\n您可以安装 xxd 工具，以便在可读的 ASCII 文本与 isotpsend 和 isotprecv 所使用的十六进制字符串之间轻松进行转换：\n\n\n\n使用以下命令可将 ASCII 字符串（例如 VIN0123456789ABCD）转换为 isotpsend 可识别的十六进制字符串（例如 2E F1 90 56\n49 4E 30 31 32 33 34 35 36 37 38 39 41 42 43 44）：\n\n\n\n反之亦然：\n\n\n\n\n读取 DTC 信息（0x19）#\n\n汽车爱好者通常希望获取的一类信息是诊断故障代码（DTC）。DTC 是车辆中出现的问题报告，并由 ISO 15031-6 标准定义。\n\nDTC 由一个字母（U、C、P 或 B）和四个数字组成。\n\n字母表示问题所属的领域：“U”代表网络（ECU A），“C”代表底盘（ECU B），“P”代表动力总成（ECU C），“B”代表车身（ECU\nD）。第一位数字表明该 DTC 是标准定义（“0”）还是制造商特定定义（“1”）。\n\n例如，DTC“P0650”表示动力总成领域出现了问题。其中的“0”表示该 DTC\n为标准定义，在此上下文中，“6”代表“计算机输出电路”，而“50”则表示“故障指示灯（MIL）控制电路故障”。\n\n网上有大量关于 DTC 解读的信息可供参考。如果第一位数字是零，则 DTC\n具有唯一定义；但如果第一位是“1”，则其定义因制造商而异，并且在不同车辆中可能有不同的含义。\n\n在较早的 KWP2000 协议中，DTC 曾以两个字节的形式存储，该协议早于 UDS。UDS\n引入了第三个字节，即故障类型字节（FTB），以报告更多关于问题的详细信息。用于定义 DTC 值的两个字节分别称为“高字节”和“中字节”，而“低字节”则代表\nFTB。\n\n * 首字母由最高两位表示：00 代表 P，01 代表 C，10 代表 B，11 代表 U。\n * 第一个数字由高字节的第 5 至第 4 位表示。\n * 第二个数字由高字节的第 0 至第 3 位表示。\n * 第三个数字由中字节的第 7 至第 4 位表示。\n * 第四个数字由中字节的第 0 至第 3 位表示。\n\n例如，DTC P0650 在 UDS 中的表示如下：\n\n\n\n在 UDS 负载中，这将显示为 06 50 <FTB>。\n\n最后，一个字节的最低位用于指示 DTC 的状态。该字节的每一位代表一个标志，其定义如下：\n\n * 第 0 位表示“测试失败”。\n * 第 1 位表示“本操作周期内测试失败”。\n * 第 2 位表示“待定 DTC”。\n * 第 3 位表示“已确认 DTC”。\n * 位 4 表示“自上次清除以来测试未完成”。\n * 位 5 表示“自上次清除以来测试失败”。\n * 位 6 表示“本操作周期内测试未完成”。\n * 位 7 表示“请求警告指示器”。\n\n因此，ECU 总共会向您发送每个 DTC 四个字节。要请求读取 DTC，您需要提供一个子功能和一个 DTC 状态掩码。RAMN ECU 支持子功能\n0x01，该功能返回与所提供掩码匹配的 DTC 数量；还支持子功能 0x02，该功能在同一帧中串联返回实际的 DTC。\n\n例如，如果您想请求待处理的 DTC 数量，可以使用子功能 0x01，并设置参数 0x04（必须将“待处理 DTC”置位）：\n\n\n\nECU 会以六个字节进行响应：\n\n * 第一个字节为 0x19 + 0x40 = 0x59，用于指示已接受请求。\n * 第二个字节重复子功能字节。\n * 第三个字节是“DTC 状态可用性掩码”——即 ECU 实际可以检查的状态标志位。\n * 第四个字节是“DTC 格式标识符”（例如，ISO 15031-6 DTC 格式为 0x00，ISO 14229-1 DTC 格式为 0x01）。\n * 最后两个字节表示 DTC 的数量。\n\n出于演示目的，RAMN ECU 在复位时会确保其内存中至少包含一个 DTC。该 DTC 的标志位始终标记为待处理状态，并且 ECU 不允许您通过掩码进行过滤。\n\n您可以使用以下命令询问 ECU B 内存中有多少个 DTC：\n\n\n\n您还可以使用以下命令要求 ECU B 向您发送所有 DTC：\n\n\n\n\n\n“59 01 04 00 00 00 01”的含义是：ECU 接受了您针对服务 0x19 和子功能 0x01（读取 DTC 数量）的请求，它仅支持 0x04\n掩码（用于待处理 DTC），采用 DTC 格式 0x00，并且内存中存储了 0x0001 个 DTC。\n\n“59 02 04 45 63 00 04”的含义是：ECU 接受了您针对服务 0x19 和子功能 0x02（读取 DTC）的请求，它支持 0x04\n掩码，并且存在一个 DTC：0x4563，故障类型位为 0x00，状态为 0x04（待处理）。0x4563 以“01”开头，表示这是一个底盘域的\nDTC（“C”），因此对应的 DTC 为“C0563”（出于演示目的，此处为任意设定）。\n\n\n清除诊断信息 (0x14)#\n\n此服务可用于从 ECU 的内存中清除 DTC。它使用一个 3 字节的参数来指示要清除哪一组 DTC。与排放相关的系统 DTC 可以通过“00 00\n00”来清除，而所有 DTC 则可通过“FF FF FF”来清除。其他可能的值则由制造商自定义。\n\n例如，您可以使用以下方式清除 ECU B 内存中的所有 DTC：\n\n\n\n您可以通过在执行该命令前后分别读取 DTC 的数量，来验证 DTC 是否已被清除。ECU 在复位事件后会自动重新生成 DTC。\n\n\n\n\n控制 DTC 设置（0x85）#\n\n此服务允许临时禁用 DTC，以防止 ECU 在诊断过程中添加新的 DTC。您可以使用子功能 0x01 来允许新 DTC 的生成，使用 0x02 来禁用它们。\n\n启用 DTC：\n\n\n\n禁用 DTC：\n\n\n\n\n安全访问 (0x27)#\n\n某些服务可能要求您先解锁 ECU，然后才能使用。您会发现这些服务，因为它们会对您的请求回复错误代码 0x33（拒绝安全访问）。\n\n安全访问服务可用于解锁 ECU。\n\n安全访问可用于通过 ECU 实现简单的质询/响应身份验证。您首先需要从 ECU\n请求一个“种子”。然后，您必须执行一些绝密算法，以从该种子计算出一个“密钥”，并将该“密钥”发送到 ECU\n以解锁它。请注意，此处的密钥并不指加密密钥；而是指对质询的响应。\n\n此服务有不同的安全级别。要请求级别 1 的种子，请使用以下命令：\n\n\n\n您应该注意，ECU 会向您发送一个 4 字节的种子作为响应。该种子由 ECU 的真随机数生成器 (TRNG) 生成。您可以请求任意数量的种子。\n\n\n\n要解锁 ECU，您需要计算种子值与 0x12345678 的异或值。这仅用于演示目的，并不是一个安全的身份验证机制。\n\n在 Linux 中，您可以使用以下命令计算要发送到 ECU 的“密钥”（以 7D 70 9F 4D 为例）：\n\n\n\n您可以使用与请求相同的命令，但将安全级别加 1，以将您的答案（在本例中为 6F 44 C9 35）发送到 ECU：\n\n\n\n如果 ECU 接受您的 UDS 请求（第一个字节为 0x67），则表示您提供了正确的“密钥”，ECU 现已解锁到级别 1。\n\n\n\n在尝试使用安全访问时，您可能会遇到以下错误代码：\n\n * 0x24（请求序列错误）：您在未先请求种子的情况下尝试使用密钥。\n\n * 0x35（密钥无效）：您提供的密钥错误。\n\n * 0x36（尝试次数超限）：您的失败尝试次数过多。\n\n * 0x37（所需时间延迟未到期）：您需要等待更长时间后再尝试解锁 ECU（通常是在复位之后，以防止暴力破解）。\n\n\n例程控制 (0x31)#\n\n例程控制服务可用于实现标准服务未涵盖的功能。例程通过一个两位字节的标识符进行识别。与 DID 类似，UDS 标准定义了许多标准例程标识符，但标识符 0x0200\n至 0xDFFF 为 ECU 专用。\n\n例程控制服务可配合三种子功能使用：\n\n * 0x01 开始一个例程。\n * 0x02 用于停止例程。\n * 0x03 用于请求例程的执行结果。\n\n此服务使用以下参数：<子功能> <例程标识符> <可选例程参数>。RAMN ECU 提供了以下例程：\n\n * 例程 0x0200 可用于请求 ECU 停止发送周期性 CAN 消息。\n * 例程 0x0201 可用于擦除 EEPROM（其中保存有 DTC 和 VIN）。\n * 例程 0x0202 可用于将 EEPROM 复制到备用存储器库（通过 UDS 重新刷写 ECU 时）。\n * 例程 0x0203 可用于请求 ECU 回显您所传输的内容（用于负载测试）。\n * 例程 0x0204 可用于请求 ECU 回显请求的前 4 个字节（用于 PC 到 ECU 的链路测试）。\n * 例程 0x0205 可用于请求 ECU 传输指定大小的 UDS 有效载荷（用于 ECU 到 PC 的链路测试）。\n * 例程 0x0206 可用于计算 ECU 闪存的 CRC 校验值。\n * 例程 0x0207 可用于启用自动驾驶模式（需与 CARLA 配合使用）。\n * 例程 0x0208 可用于向 ECU 添加任意 DTC 故障码。\n * 例程 0x0209 可用于执行任意 ARM（Cortex M-33）Shell 代码。\n * 例程 0x0210 可用于重置 BOOT 选项字节（以修复固件损坏的 ECU）。\n * 例程 0x0211 可用于强制 ECU 切换内存 Bank（同样用于修复 ECU）。\n * 例程 0xFF00 可用于擦除备用固件。\n * 例程 0xFF01 可用于验证内存并切换内存 Bank。\n\n由于这些例程可能会修改 ECU 闪存，因此请勿随意操作，除非您清楚自己在做什么。有关如何使用这些例程，请参阅 ramn_uds.c 。\n\n例如，您可以要求 ECU B 停止发送周期性报文，方法如下：\n\n\n\n并且你可以要求 ECU B 恢复发送周期性报文，方法是：\n\n\n\n\n按地址读取内存 (0x23)#\n\n按地址读取内存服务可用于读取任意 ECU 地址。您自然需要提供两个参数：地址和要读取的字节数。\n\n与按标识符读取数据服务所使用的 DID 不同，实际 ECU\n地址的大小可能因微控制器架构而异。因此，您必须提供第三个参数，用于指定地址和内存字段的大小（地址长度格式标识符）。该参数为一个字节，其高 4\n位表示“size”参数的大小，低 4 位表示“address”参数的大小。\n\n按地址读取内存参数的格式为<格式标识符> <地址> <size>。\n\n例如，假设您想从地址 0x08000000（RAMN ECU 程序闪存的起始地址）读取 4\n个字节。“4”可以容纳在一个字节中，因此您可以使用一个字节来提供要读取的大小。STM32 微控制器使用的地址为 32 位长（4\n字节）。因此，您可以使用格式标识符 0x14（地址 4 字节，size 1 字节）。\n\n你可以通过以下方式请求内存读取：\n\n\n\n格式标识符指的是大小参数的尺寸（它并非您想要读取的字节数），这一点可能会让一些人感到困惑。如果您愿意，可以将大小参数（4）作为 2 字节或 4\n字节的参数来提供。因此，以下命令与上述命令严格等效：\n\n\n\n该服务会立即返回所读取的数据。例如，您可以使用以下方式读取 ECU B 程序闪存的前 256 字节（地址为 0x08000000）：\n\n\n\n\n\n请注意，在这种情况下，请求和响应均为分片的 ISO-TP 帧，因此您必须在另一个终端上启用 isotprecv。\n\n同样，您也可以读取微控制器的 RAM（起始地址为 0x20000000）：\n\n\n\n\n\n如果你想了解 RAMN ECU 将变量存储在哪些地址上，必须编译固件，并查看构建过程生成的“.map”文件。\n\n\n按地址写入内存 (0x3D)#\n\n按地址写入内存与按地址读取内存的工作方式相同，只是它额外需要一个参数来指定您希望写入到指定地址的数据。由于这允许覆盖 RAM（且仅限于\nRAM），如果您不清楚自己在做什么，可能会导致 ECU 崩溃。\n\n例如，您可以使用以下命令将“01 02 03 04”写入内存地址 0x20000000：\n\n\n\n\n\n此命令仅在您首先请求编程会话并通过安全访问（0x27）解锁 ECU\n后才会被接受。您可以通过在操作前后使用按地址读取内存功能来验证内存是否已正确写入。变量地址取决于您所使用的固件的确切版本。在本示例中使用的版本中，0x20000\n000 对应于 CAN 适配器的“错误状态”变量，该变量可被覆盖而不会影响稳定性。如果您不清楚您的命令覆盖了哪些变量，则应重置 ECU。\n\n\n链路控制 (0x87)#\n\n此服务可用于更改 CAN 总线的波特率，例如，在通过 UDS 重新刷写 ECU 时可提高速度。它需要两个步骤：\n\n * 一条命令用于验证 ECU 是否接受波特率变更。\n * 一条命令用于切换至新的波特率。\n\n请注意，虽然真实的 ECU 在诊断会话结束后会自动恢复到原始波特率，但 RAMN ECU\n则会保持当前波特率直至下次复位。标准实现采用功能寻址和正面响应抑制，以同时向所有 ECU 发送切换命令。然而，RAMN ECU 会在切换波特率前先关闭其 CAN\n控制器并等待一秒钟，以更好地容忍更多的时序问题，因此您可以单独与每个 ECU 进行通信。\n\n您可以使用此服务，它包含以下三种子功能之一：\n\n * 0x01 使用一个字节的波特率标识符来验证波特率变更（例如，0x12 对应 500000 bps）。\n * 0x02 使用三个字节的具体波特率值来验证波特率变更（例如，0x7A120 对应 500000 bps）。\n * 0x03 切换至新的波特率。\n\nRAMN ECU 支持子功能 0x01 和 0x03。您必须为子功能 0x01 提供的参数是一个字节的标识符：\n\n * 0x10 表示 125000 bps。\n * 0x11 表示 250000 bps。\n * 0x12 表示 500000 bps。\n * 0x13 表示 1000000 bps。\n\n要切换到新的波特率，请使用子功能 0x03，无需任何参数。如果您希望在无错误时让 ECU 不予响应，请改用 0x83。\n\n在更改 ECU 的波特率时，您还需要同步更新 CAN 适配器的波特率。如果您使用的是 slcan 适配器，则需要重启 slcand，并使用 -s 选项（参见\nCAN 波特率）。\n\n对于 125000 bps 使用 -s4，250000 bps 使用 -s5，500000 bps 使用 -s6，1000000 bps 使用 -s8。\n\n例如，可以使用以下命令将所有 ECU 的 RAMN 波特率逐一更新为 1000000 bps（假设您的接口为/dev/ttyACM0）：\n\n\n\n这还将重启您的 CAN 接口，因此您需要重新启动所有 CAN 命令。\n\n\n\n你可以通过使用功能寻址，将命令同时发送至所有 ECU，从而简化通信流量，并利用正面响应抑制功能，要求它们在未发生错误时无需应答。\n\n\n\n这样仅需两条 CAN 报文即可实现相同的波特率变更。\n\n\n\n\n请求上传（0x35）#\n\n此服务可用于向 ECU 请求数据“上传”。请注意，在嵌入式系统中，“上传”通常指的是从 ECU\n到计算机的数据传输（这意味着您正在将数据“下载”到您的计算机）。这可用于转储 RAMN ECU\n的闪存。虽然使用按地址读取内存（0x23）服务也可以达到相同的效果，但该服务在可用时支持压缩和加密。\n\n其使用方法如下：\n\n * 调用此服务以请求数据上传。\n * 根据需要多次调用传输数据（0x36）服务以接收数据。\n * 调用请求传输退出（0x37）服务以完成传输。\n\n此服务包含多个参数：\n\n * 一个字节用于指定压缩和加密方法。RAMN 仅支持 0x00，表示两者均未使用。\n * 一个字节用于指定地址和大小字段的长度（类似于按地址读取内存 (0x23)）。RAMN ECU 支持 0x44（4 字节大小，4 字节地址）。\n * 若干字节用于指定数据的地址。\n * 若干字节用于指定（未压缩）数据的长度。\n\n例如，你可以通过以下方式请求从地址 0x08000000 转移 256（0x100）字节：\n\n\n\nECU 应当回复：\n\n * 其地址字段和大小字段的长度。由于没有地址，此处的地址大小始终为 0，仅最高 4 位有意义。\n * 它将用于传输的最大尺寸（包括服务标识符和数据参数）。\n\n\n\n\n传输数据 (0x36)#\n\n传输数据用于实现由另一服务启动的传输（例如，请求上传 (0x35) 或请求下载\n(0x34)）。每次调用传输数据服务对应于一个数据块的传输。您必须提供一个“块计数器”，第一个数据块的计数器从 0x01 开始。当计数器达到 0xFF\n后会溢出，并从 0x00 重新开始。\n\n例如，在请求上传 (0x35) 示例之后，您可以执行以下命令：\n\n\n\nECU 将以块计数器的回显作为响应，随后发送待读取的数据。\n\n如果您尝试读取或写入超出指定数据大小范围的数据，将收到错误代码 0x24，表示“请求序列错误”。\n\n\n\n如果您正在写入数据，则必须在块计数器之后提供数据字节，而 ECU 仅会以块计数器的回显作为响应。\n\n\n请求传输退出（0x37）#\n\n请求传输退出服务用于终止传输。如果您希望确认下载或启动另一项传输，则必须调用此服务。此服务可能包含可选参数，但 RAMN ECU\n无需任何参数，因此只需简单地发送“37”即可：\n\n\n\nECU 应当以“77”作为回应。\n\n\n\n\n请求下载 (0x34)#\n\n请求下载的工作方式与请求上传 (0x35) 相同，但数据位于客户端的请求端，而非 ECU 的应答端。仅当 RAMN ECU 具有双内存区（微控制器参考号以\nCET6 结尾）时才支持此功能。与按地址写入内存 (0x3D) 不同，此服务可将数据写入 ECU 的闪存，例如用于固件更新。\n\n例如，您可以使用以下命令在地址 0x08000000 处启动 0x100 字节的下载：\n\n\n\nECU 将指定后续“传输数据”调用中必须包含的数据大小，因此您必须根据 ECU 返回的值进行相应调整。\n\n完成固件文件的“请求下载”传输后，并不会立即使 ECU 使用您上传的新固件。您还需要结合例程控制来验证新固件。对于 RAMN，这可以通过以下方式实现：\n\n * 例行控制 0x0202 用于请求 ECU 将其当前的 EEPROM 复制到备用存储器区。\n\n * 例行控制 0xFF01，用于请求 ECU 切换存储区（并使用新的固件）。\n\n\nJ1979 服务（OBD-II PID）#\n\n低于 0x10 的服务由 J1979 标准定义（参见 OBD-II PID）。RAMN 支持以下 J1979 服务：\n\n * 服务 0x01（请求当前诊断数据）\n\n * 服务 0x03（请求 DTC）\n\n * 服务 0x04（清除 DTC）\n\n * 服务 0x09（请求车辆信息）\n\n\n请求当前诊断数据 (0x01)#\n\n此服务可用于读取车辆的当前数据。使用时需提供一个字节的参数，该参数表示您希望读取的数据（“PID”）。PID 0x00 用于指示 ECU 支持哪些 PID（从\n0x01 到 0x20）。ECU 将以 4 个字节（0x20 位）进行响应，当对应 PID 被支持时，相应位将被置为 1（请参考此链接以获取示意图）。如果\nPID 0x20 被支持，则它依次用于指示从 0x21 到 0x40 的哪些 PID 被支持，以此类推。\n\n例如，您可以使用以下命令询问 ECU C 支持哪些 PID：\n\n\n\n\n\n请注意，isotpdump 无法解析这些命令，因为从技术上讲，它们并非 UDS 服务。\n\nECU 以 41 00 BE 1F A8 13 响应命令 01 00。与 UDS 类似，41 对应于服务 ID 加\n0x40，表示这是一个肯定响应。第二个字节是对请求参数的回显。\n\nBE 的二进制表示为 10111110，这意味着 ECU C 支持 PID 1、3、4、5、6、7，但不支持 PID 2 和 8。您可以通过尝试读取 PID\n1、2 和 3 来验证这一观察结果。与 UDS 类似，否定响应由 0x7F 加上请求的服务 ID 和错误代码组成。\n\n\n\n\n\n您可以在 OBD-II PIDs 的维基百科页面上找到每个 PID 的含义和格式。以下 PID 可能尤其值得关注：\n\n * 0x0C（发动机转速）。\n * 0x0D（车速）。\n * 0x1F（车辆启动后的运行时间）。\n * 0x1C（车辆使用的 OBD 标准）- RAMN 使用 10（JOBD）。\n * 0x49（加速踏板位置）。\n * 0xA6（里程表）。\n\n请注意，RAMN 的 J1979 实现所返回的许多值均为占位符值，可能无法正确反映模拟器的状态。不过，PID 0x1F 和 0x49 应始终得到正确实现：\n\n\n\n\n\n在此情况下，ECU C 回复当前加速踏板位置为 0xFB（98%），我们可以观察到两次读取 PID 0x1F 命令之间间隔了 4 秒。\n\n\n请求 DTC（0x03）#\n\n服务 0x03 用于请求 ECU 存储的 DTC。与 UDS 不同，该服务无需提供任何参数。相反，若要请求待处理 DTC 或永久性\nDTC，应使用其他服务（分别为 0x07 和 0x0A）。需要注意的是，RAMN 会将服务 0x07 和 0x0A 视为服务 0x03\n的别名，因此您也可以直接使用它们。\n\n有关 DTC 的更多信息，请参阅读取 DTC 信息（0x19）。此服务每个 DTC 仅返回 2 个字节（没有状态掩码或 FTB）。您可以使用以下命令要求 ECU\nC 显示其存储的 DTC：\n\n\n\n\n\nECU C 的响应为 43 01 01 72。第一个字节 43 表示肯定回答，01 表示存在一个 DTC，其值为 0172。\n\n\n清除 DTC（0x04）#\n\n此服务可用于清除 DTC，也可在不带参数的情况下使用。例如，您可以使用以下命令来读取 DTC、清除 DTC 并再次读取 DTC：\n\n\n\n\n\n\n请求车辆信息 (0x09)#\n\n此服务与请求当前诊断数据 (0x01) 类似，用于读取车辆信息。它同样使用一个字节的参数来指定要读取的 PID，其中 PID 0x00 用于指示支持哪些\nPID。PID 0x02 对应 VIN，PID 0x0A 对应 ECU 名称。您可以通过以下命令读取这些 PID：\n\n\n\n\n\n请注意，如果您尚未将 VIN 写入 ECU，则返回的答案将仅为零。","routePath":"/docs/userguide/diag_tutorial","lang":"","toc":[{"text":"UDS 基础知识","id":"uds-基础知识","depth":2,"charIndex":104},{"text":"RAMN 标准 UDS 服务","id":"ramn-标准-uds-服务","depth":3,"charIndex":360},{"text":"正面响应","id":"正面响应","depth":3,"charIndex":1562},{"text":"负面响应","id":"负面响应","depth":3,"charIndex":1796},{"text":"使用 Linux 和测试仪存在 (0x3E) 的示例","id":"使用-linux-和测试仪存在-0x3e-的示例","depth":3,"charIndex":2428},{"text":"RAMN UDS 服务","id":"ramn-uds-服务","depth":2,"charIndex":3612},{"text":"诊断会话控制 (0x10)","id":"诊断会话控制-0x10","depth":3,"charIndex":3627},{"text":"ECU 重置 (0x11)","id":"ecu-重置-0x11","depth":3,"charIndex":3955},{"text":"按标识符读取数据 (0x22)","id":"按标识符读取数据-0x22","depth":3,"charIndex":4219},{"text":"通过标识符写入数据（0x2E）","id":"通过标识符写入数据0x2e","depth":3,"charIndex":4642},{"text":"读取 DTC 信息（0x19）","id":"读取-dtc-信息0x19","depth":3,"charIndex":5152},{"text":"清除诊断信息 (0x14)","id":"清除诊断信息-0x14","depth":3,"charIndex":7029},{"text":"控制 DTC 设置（0x85）","id":"控制-dtc-设置0x85","depth":3,"charIndex":7273},{"text":"安全访问 (0x27)","id":"安全访问-0x27","depth":3,"charIndex":7394},{"text":"例程控制 (0x31)","id":"例程控制-0x31","depth":3,"charIndex":8151},{"text":"按地址读取内存 (0x23)","id":"按地址读取内存-0x23","depth":3,"charIndex":9130},{"text":"按地址写入内存 (0x3D)","id":"按地址写入内存-0x3d","depth":3,"charIndex":9877},{"text":"链路控制 (0x87)","id":"链路控制-0x87","depth":3,"charIndex":10231},{"text":"请求上传（0x35）","id":"请求上传0x35","depth":3,"charIndex":11264},{"text":"传输数据 (0x36)","id":"传输数据-0x36","depth":3,"charIndex":11823},{"text":"请求传输退出（0x37）","id":"请求传输退出0x37","depth":3,"charIndex":12142},{"text":"请求下载 (0x34)","id":"请求下载-0x34","depth":3,"charIndex":12270},{"text":"J1979 服务（OBD-II PID）","id":"j1979-服务obd-ii-pid","depth":2,"charIndex":12694},{"text":"请求当前诊断数据 (0x01)","id":"请求当前诊断数据-0x01","depth":3,"charIndex":12860},{"text":"请求 DTC（0x03）","id":"请求-dtc0x03","depth":3,"charIndex":13739},{"text":"清除 DTC（0x04）","id":"清除-dtc0x04","depth":3,"charIndex":14072},{"text":"请求车辆信息 (0x09)","id":"请求车辆信息-0x09","depth":3,"charIndex":14158}],"domain":"","frontmatter":{},"version":""},{"id":36,"title":"更进一步","content":"#\n\n\n接下来该做什么#\n\n如果你已完成本节中的所有教程，并正在寻找新的内容，可以尝试挑战 CTF 训练页面中的题目，或者重温过去包含 RAMN 的专业 CTF 比赛（CTF 解题报告\n）。\n\n\n使用外部适配器#\n\n虽然你可以将 ECU A 用作 USB 转 CAN 适配器，但你可能更倾向于使用外部 CAN 适配器以及配套的分析工具套件。例如，你可以将 BUSMASTER\n与 PCAN-USB 配合使用。这些工具通常允许你加载一个数据库文件（“DBC 文件”），该文件指定了 CAN 帧中每个比特所代表的具体含义。\n\n\nRAMN 的 DBC 文件#\n\nRAMN 的“DBC”和“DBF”文件位于 misc 文件夹中。您可以使用这些文件来帮助分析 RAMN 的默认信号。\n\n例如，借助 BUSMASTER 和兼容的外部适配器，您可以选择“数据库 -> 关联”，并加载 .DBF 文件。\n\n\n\n这将允许您用助记符替换 CAN 标识符和有效载荷，如下所示。\n\n\n\n\n\n这将使您能够记录并显示在 CAN 总线上观察到的数值图表。\n\n\n\nRAMN 的 GitHub 仓库中提供了一个 PID 控制示例 ,该示例在 RAMN ECU 上以闭环方式与驾驶模拟器（参见 CARLA）协同实现。\n\n\n其他 CAN 工具#\n\n其他 CAN 软件工具也可用于与 RAMN 的 ECU 进行交互。\n\n例如,Caring Caribou 提供了多种与 UDS 和 XCP 交互的功能。请按照此处的说明进行安装：\n\n\n\n然后，在您的主目录中创建一个 .canrc 文件（可使用 nano ~/.canrc），并添加以下内容：\n\n\n\n如果您需要以 root 用户身份执行，应改在 /root/.canrc 中创建 .canrc 文件。\n\n之后您应该能够使用 caring caribou 的模块。\n\n\nUDS#\n\n你可以使用发现模块来确定 RAMN 的 ECU 所使用的 CAN ID。\n\n\n\n\n\n你可以使用“services”模块来查看 ECU B 支持哪些服务：\n\n\n\n在另一个窗口中，你可以使用 isotpdump can0 -s 7e1 -d 7e9 -c -u 来观察流量。\n\n\n\n您可以使用以下命令读取 ECU B 的所有可能的 DID：\n\n\n\n如果遇到错误，请尝试执行 sudo ifconfig can0 txqueuelen 10000 。\n\n\n\n\nXCP#\n\n请参考帮助页面，了解如何使用 Caring Caribou 的 XCP 模块：\n\n\n\n您可以使用发现模块扫描 XCP 对（自动黑名单选项会先监听流量，以避免误报）：\n\n\n\n您可以向 ECU 查询其基本信息，例如针对 ECU B：\n\n\n\n在另一个窗口中，使用 candump can0,552:7fe 来观察 XCP 流量。\n\n你可以尝试使用 XCP 转储 ECU B 固件的前 256 字节，命令如下：\n\n\n\n\nCAN 脚本编写#\n\n对于 CTF 和其他高级 CAN 活动，你可以使用 python-can 来自动化 CAN 通信。\n\npython-can 可用于直接在 CAN 层上自动化帧的传输。你可以在这里找到一系列示例。示例 send_one.py 将向你展示如何简单地发送一条 CAN\n消息，receive_all.py 将展示如何接收 CAN 消息，而 asyncio_demo.py 则会演示如何将 CAN 消息的接收与发送关联起来。\n\n同样地，can-isotp 可用于自动化 ISO-TP 消息的传输。有关示例，请参阅其 文档 。\n\n最后，udsoncan 可用于 UDS 通信交换。","routePath":"/docs/userguide/going_further","lang":"","toc":[{"text":"接下来该做什么","id":"接下来该做什么","depth":2,"charIndex":3},{"text":"使用外部适配器","id":"使用外部适配器","depth":2,"charIndex":97},{"text":"RAMN 的 DBC 文件","id":"ramn-的-dbc-文件","depth":3,"charIndex":261},{"text":"其他 CAN 工具","id":"其他-can-工具","depth":2,"charIndex":542},{"text":"UDS","id":"uds","depth":3,"charIndex":787},{"text":"XCP","id":"xcp","depth":3,"charIndex":1020},{"text":"CAN 脚本编写","id":"can-脚本编写","depth":2,"charIndex":1232}],"domain":"","frontmatter":{},"version":""},{"id":37,"title":"","content":"","routePath":"/docs/userguide/","lang":"","toc":[],"domain":"","frontmatter":{"overview":true},"version":""},{"id":38,"title":"与 ISO-TP 交互","content":"#\n\n如 与 CAN 交互 中所述，ECU 通常会通过 CAN 提供诊断功能，并遵循若干标准文档的要求：\n\n * 统一诊断服务（UDS）\n * 关键字协议 2000（KWP2000）\n * 通用测量与标定协议（XCP）\n\n诊断涉及客户端（诊断工具）与服务器（ECU）之间的大量数据传输，例如将新的固件文件发送到 ECU。 CAN 帧的有效载荷最多只能容纳 8 字节（对于 CAN\nFD 则为 64 字节），因此最好使用传输层来支持更大有效载荷的传输。 ISO-TP（ISO 15765-2）（有时也称为\nCAN-TP）是一种传输层，旨在促进此类数据传输。\n\n\nISO-TP 基础#\n\nISO-TP（ISO 15765-2）是 UDS 和 KWP2000 使用的传输层。它允许传输最大达 4095 字节的有效载荷。其工作原理是将每个 CAN\n帧的第一个字节（或多个字节）用作报头，这一点与 IP 协议占用以太网帧前几个字节的方式类似。\n\nISO-TP 通常用于建立一对一的通信通道：一个客户端和一个服务器。客户端通过发送具有特定（静态）标识符的 CAN\n帧来发出请求，而服务器则通过发送具有另一个特定（静态）标识符的 CAN 帧进行响应。例如，RAMN 的 ECU B 监听 ID 为 0x7e1 的 CAN\n帧（由诊断工具发送），并将其解释为 ISO-TP 帧，然后通过发送 ID 为 0x7e9 的 CAN 帧作出应答。这称为正常寻址\n,但还有其他类型的寻址方式（参见寻址）。\n\nISO-TP 报头采用动态大小的报头（协议控制信息，PCI）。报头的类型由报头的第一个半字节（ 前四位 )定义。共有四种类型的报头：\n\n * 单帧 [SF，首字节为 0X]：这是用于 ISO-TP 有效载荷的单字节报头，适用于 7 字节或更短的有效载荷。\n * 首帧 [FF，首字节为 1X]：这是一个两字节报头，用于启动 8 字节或更长 ISO-TP 有效载荷的传输。\n * 连续帧 [CF，首字节为 2X]：这是一个单字节报头，用于延续由“首帧”报头开始的传输。\n * 流控帧 [FC，首字节为 3X]：这是一个三字节报头，由接收方用来控制 ISO-TP 传输的速度。\n\n尽管 ISO-TP 具备流控机制，但它并未包含用于确认帧已正确重组的“确认”机制。表示 ISO-TP 数据的 CAN 帧可能会用任意值进行填充（常见的填充值包括\n0xCC、0xAA 和 0x00），以确保其始终为 8 字节长度。\n\n\n单帧#\n\n单帧（报头格式为“0X”）是简单的 ISO-TP 帧：其报头表明，整个 ISO-TP 有效载荷包含在 CAN 帧中，位于报头之后。这意味着该 ISO-TP\n帧的长度为 7 字节或更短，否则有效载荷及其一字节的报头将无法容纳在一个单独的 CAN 帧中。\n\n第二个半字节的值表示 ISO-TP 有效载荷的长度。例如，“01”表示一个字节的 ISO-TP 有效载荷，“05”则表示五字节的 ISO-TP 有效载荷。\n\n对于单帧而言，无需流量控制，因此单帧即代表了整个 ISO-TP 传输过程。例如，如果诊断工具希望向 ECU B 发送 ISO-TP 有效载荷“00 11 22\n33 44”（5 字节），它将发送以下 CAN 帧：\n\n\n\n请注意，ISO-TP 有效载荷的大小为 5 字节 ,但相关的 CAN 帧却是 6 字节 ,因为 CAN 帧中有一字节用作报头。\n\n\n首帧与连续帧#\n\n首帧（报头格式为“1XXX”）与连续帧（报头格式为“2X”）配合使用，以传输大于 7 字节的有效载荷。首帧指定了 ISO-TP\n有效载荷的长度，并且包含该有效载荷的前 6 个字节 。首字节的第二位半字节与报头的第二个字节拼接后，表示有效载荷的长度。例如，“10 09”的报头表示一个 9\n字节的 ISO-TP 帧，“1F FF”则表示一个 0xFFF（4095）字节的 ISO-TP 帧。\n\n连续帧包含该有效载荷的剩余部分。报头字节的第二位半字节用作索引，以确保有效载荷能够按顺序重新组装。\n\n例如，如果诊断工具希望将 ISO-TP 有效载荷“00 11 22 33 44 55 66 77 88 99 AA BB CC DD”（共 14 字节）发送至\nECU B，则会发送以下 CAN 帧：\n\n\n\n请注意，这代表了诊断工具所发送的全部内容，但对于大于7字节的帧，诊断工具实际上必须等待流控制帧，如下文所述。\n\n\n流量控制帧#\n\n流量控制帧（报头格式为“3XYYZZ”）由 ISO-TP 接收方发送，用于控制传输速度。由于此类帧由接收方发送，因此其使用的 CAN ID\n与其他帧不同。作为对“首帧”的响应，至少总会发现一个流量控制帧。\n\n流量控制帧的格式为“3X YY ZZ”，包含以下参数：\n\n * 标志位[X，4 位]：此字段包含实际的流量控制数据。1 表示“继续”，2 表示“等待”，3 表示“中止”。\n * 块大小 [YY, 8 位]：此参数指定客户端在等待下一个流量控制帧之前应发送的帧数。0 表示“无需等待，直接发送所有内容”。\n * 最小分离时间 (STmin) [ZZ, 8 位]：此字段指定了客户端在帧传输之间应等待的时间。0 表示“尽可能快速发送”，取值范围为 1 到 127\n   时，表示以毫秒为单位的延迟。0xF1 至 0xF9 用于指定 100 毫秒到 900 毫秒之间的较大延迟。介于这些值之间的数值已被标准保留。\n\n现代 ECU 通常会以“30 00 00”作为对“第一帧”的响应，这意味着“以最高速度发送所有数据”——在这种情况下，这将是整个通信过程中唯一的流控制帧。\n\n如果 ECU 回复的是“30 00 F9”，客户端也会在不等待流控制帧的情况下发送所有帧，但每帧之间会间隔 900 毫秒。\n\n如果 ECU 回复的是“30 01 00”，客户端将发送第一个“连续帧”，并在继续发送之前等待另一个流控制帧。\n\n\n示例#\n\n以下是一个完整的 ISO-TP 传输示例：\n\n\n\n请注意，最后没有确认应答。如果 ECU 使用的块大小不为零，则相同的数据交换将如下所示。\n\n\n\n\nLinux 上的 ISO-TP#\n\ncan-utils 软件包提供了多种工具用于与 ISO-TP 交互。您可能会用到以下三个命令：isotpsend 用于发送 ISO-TP 帧，isotprecv\n用于接收 ISO-TP 帧，以及 isotpdump 用于转储并解析 ISO-TP 流量。此外，您仍然可以使用前一指南中介绍的基本命令（参见与 CAN 交互）。\n\nUDS 命令将在另一节中详细说明。本节主要使用基本的 UDS 命令 “3E 00”，该命令应由 ECU 回应 “7E 00”。我们将此命令发送至 ECU\nB，它使用 ID 0x7e1 接收命令，使用 ID 0x7e9 回应命令。任何其他随机命令，很可能是无效的，应以 7F <您发送的第一个字节> <错误码字节>\n来回应，以指示您的命令存在错误。\n\n\ncandump#\n\n在使用 ISO-TP 进行实验时，你可能希望显示原始的 CAN 流量。这可以通过使用 candump 并配合正确的过滤器来实现。例如，如果你只想显示 ECU B\n的 ISO-TP 流量对应的 CAN 帧，则应仅显示 ID 为 0x7e1 和 0x7e9 的 CAN 帧：\n\n\n\n如果您想显示现代车辆中通常出现的所有 ISO-TP 帧，可以使用 ID 介于 0x7e0 和 0x7f 之间的过滤器来筛选帧（请参阅 CAN 过滤器 ）：\n\n\n\n在试验 ISO-TP 时，建议您始终保留一个终端执行此命令，以便可以直接观察 CAN 帧。\n\n\ncansend#\n\n尽管不推荐这样做，但并没有任何限制阻止您手动创建 ISO-TP 报头并发送 CAN 帧。要将 ISO-TP 有效载荷“3E 00”发送到 ECU\nB，您可以输入以下命令：\n\n\n\n在您的 candump 终端上，您应该会看到两条消息：\n\n * 您的请求（“3E 00”，由您通过 ID 0x7e1 发送）。\n * ECU 的响应（“7E 00”，由 ECU B 通过 ID 0x7e9 发送）。\n\n\n\n请注意，CAN 帧的 DLC（有效载荷大小）为 3，但 ISO-TP 有效载荷仅为 2 字节——这是因为 CAN 有效载荷的第一个字节用于指示 ISO-TP\n有效载荷的大小。此外，请注意，您的请求 CAN 报文中并未指定响应 CAN ID，该 ID 是静态设定的，不同于 TCP 等其他协议中的源端口和目的端口。\n\n如果您忽略流控制帧，并仅寄希望于时间 timing 正确，也可以直接发送分段帧。例如，要发送有效载荷 00 11 22 33 44 55 66 77（8\n字节），您可以输入：\n\n\n\n并在 candump 中观察响应结果。\n\n\n\n尽管在 ISO-TP 上层可能会出现错误信息（例如上述截图中的“7F 00 31”UDS 错误消息），但 在 ISO-TP 层却没有任何错误信息 。如果在格式化\nISO-TP 帧时出现错误，ECU 将直接不予响应。例如，对于以下格式错误的请求，ECU 不会作出任何回应，也不会报告相关错误。\n\n\n\n\n\nECU 通常对 ISO-TP 请求设置了非常快速的超时机制，如果帧发送不够迅速，传输将被关闭。建议您不要自行格式化 ISO-TP 帧，而是使用诸如\nisotpsend 之类的工具。\n\n\nisotpsend#\n\n命令 isotpsend 允许您向 ISO-TP 服务器发送任意有效载荷。作为参数，您需要提供 CAN 接口、源 CAN ID（客户端用于传输数据的\nID）以及目标 CAN ID（服务器用于传输流控帧的 ID）。有效载荷必须通过标准输入逐字节提供。在 Linux 中，这可以使用 echo\n命令来完成。例如，使用以下命令将两字节的 ISO-TP 有效载荷“3E 00”发送到 ECU B：\n\n\n\n\n\n这与之前使用 candump 捕获的 CAN 流量完全相同，只不过这次您无需自己添加报头。不过，您仍需提供目标 ID，因为 isotpsend\n会等待流控帧的到来。\n\n注意\n\n请注意，“源”对应于目标 ECU 所监听的 ID——这一点对某些人来说可能有些反直觉。与 TCP 协议中的“源”和“目的”的类比存在局限性：对于 ISO-TP\n而言，“源”和“目的”ID 是一组静态配对。如果你想与另一个 ECU 通信，你需要同时更改源和目的 。\n\n你可以使用 isotpsend 发送最大 4095 字节的有效载荷，而无需担心 ISO-TP 的格式问题。例如：\n\n\n\n应显示如下截图所示的流量。\n\n\n\n如果你只想测试 ISO-TP 链路，而对有效载荷内容不关心，可以使用-D 选项让 isotpsend 为你生成特定大小的有效载荷。此外，你还可以使用-f\n功能来强制设置客户端分离时间的值（单位为纳秒）。例如，使用以下命令生成一个 100 字节的有效载荷，并在每次传输之间设置 1 秒的延迟：\n\n\n\n你应该能够在 candump 终端中观察到缓慢的传输过程。\n\n\n\n\nisotprecv#\n\n命令 isotpsend 允许您发送 ISO-TP 帧，但它不会监听来自服务器（ECU）的响应。为此，您需要在另一个终端中使用\nisotprecv，并指定相同的参数：\n\n\n\n这将接收一个有效载荷后关闭，但您可以使用 -l 选项来监听多个 ISO-TP 有效载荷：\n\n\n\n如果您在一个终端中打开其中一条命令，并在另一个终端中使用 isotpsend，那么您应该能够在 isotprecv 终端中看到 ECU 对您的 ISO-TP\n有效载荷的响应。例如，在另一个终端中输入以下命令：\n\n\n\n然后观察 isotprecv 终端，它应该会显示来自 ECU 的响应。\n\n\n\n警告\n\n使用 isotprecv 和 isotpsend 时，请勿混淆源和目标——它们应使用相同的参数。如果您改为使用 isotprecv -s 7e9 -d 7e1\ncan0,您将不会监听 ECU B 的响应，而是会伪装成 ECU B，并监听与之相同的命令。通常情况下，真实 ECU 中的源 ID 低于目标 ID，因此：\n\n * 如果第一个参数小于第二个参数，则您正在监听 ECU 的响应（典型用法）。\n * 如果第二个参数小于第一个参数，则您正在伪装成一个 ECU（例如，如果您想开发一个 ECU 模拟器）。\n\n请注意，请求不会显示在 isotprecv 中，仅显示响应。您可以使用 isotpdump 在同一终端中同时显示请求和响应。\n\n\nisotpdump#\n\n命令 isotpdump 将在同一窗口中同时显示请求和响应。与 candump 类似，建议您保持一个终端窗口始终打开该命令。\n\n使用以下命令转储您与 ECU B 之间的流量：\n\n\n\n-c 选项为消息添加颜色，以便轻松区分请求（红色）和响应（蓝色）。\n\n如果您在另一个终端中输入以下 isotpsend 命令，应该能够观察到 ISO-TP 流量。\n\n\n\n\n\n您可以使用-a 选项以显示 ASCII 格式，并使用-u 选项将有效载荷解释为 UDS 流量：\n\n\n\n\n\n与 candump 不同，isotpdump 会自动去除报头，方便您直接识别实际的 ISO-TP 有效载荷。不过，它仍然会逐个显示 CAN\n帧。当有效载荷较大时，这种显示方式可能会显得有些繁杂，例如：\n\n\n\n\n\n\nisotpsniffer#\n\n如果您只想查看重构的有效载荷，可以改用 isotpsniffer。您可以使用以下语法：\n\n\n\n这应该只会显示重构后的有效载荷，例如在使用 isotpsend 传输大容量有效载荷时：\n\n\n\n\n\n\nisotpperf#\n\n您可以使用 isotpperf 来测量 ISO-TP 连接的性能，例如针对 ECU B：\n\n\n\n这将显示正在进行的传输，并测量其耗时。\n\n您可以通过本地强制设置-STmin 值（使用-f 选项）来尝试各种传输。打开另一个窗口，输入以下命令以发送最大尺寸且具有不同时间间隔的有效载荷：\n\n\n\n\n\n\nisotpserver#\n\n如果您希望通过 IP 网络访问 ECU 的 ISO-TP 服务器，可以使用 isotpserver。例如，如果您希望将来自 ECU B（ISO-TP 对\n0x7e1/0x7e9）的 ISO-TP 流量转发到 IP 端口 7777，可以使用以下命令：\n\n\n\n警告\n\n此命令允许任何能够访问您 IP 服务器的人员与 ECU B 进行通信。请仅在您清楚自己操作的情况下使用此功能。\n\n您可以使用例如 netcat 连接到此端口：\n\n\n\n您可以发送以 ASCII 格式嵌入在尖括号 <> 中的 ISO-TP 帧，例如，如果您输入 <3E00> 并按下回车键，您应在同一终端中收到 <7E00> 。\n\n\n\n此命令可用于远程与多人共享一个 ECU。但请注意，只有 ISO-TP 响应（且仅限响应）会被广播给所有客户端。您还可以使用 isotptun 命令创建基于\nISO-TP 的 IP 隧道。\n\n\n（略微）高级 ISO-TP 概念#\n\n\n物理寻址与功能寻址#\n\n寻址方式有两种：\n\n * 物理寻址\n * 功能寻址\n\n在正常寻址模式下，诊断工具一次仅与一个 ECU 进行通信。\n\n在功能寻址中，诊断工具可以同时与一组 ECU 进行通信。它仅支持单帧，因为单帧无需流量控制，因此多个接收端可轻松同时接收。ECU 常用的函数地址为\n0x7DF，该地址由 OBD-II PID 定义。\n\n\n寻址#\n\nISO-TP 中定义了多种寻址类型：\n\n * 普通寻址 ：地址 ID 完全包含在 CAN 标识符中（例如，ECU B 的 0x7e1 和 0x7e9）。它适用于标准（11 位）和扩展（29 位）CAN\n   标识符。\n * 普通固定寻址 ：这是普通寻址的一种子格式，仅适用于 29 位扩展标识符，其中地址必须遵循 J1939 格式 。\n * 扩展寻址 ：CAN 有效载荷的第一个字节用作额外的地址字节。这意味着单帧和连续帧的报头大小变为两个字节，首帧为三个字节，流控帧则为四个字节。\n * 混合寻址 ：正常固定寻址与扩展寻址的混合使用。\n\n\nCAN FD#\n\n较新版本的 ISO-TP 利用了 CAN FD 提供的额外带宽（参见 CAN FD）。具体而言：\n\n * 单帧可容纳最多 62 字节的有效载荷。为此，CAN 帧的第一个字节应为“00”，而紧随其后的字节则用于指示 ISO-TP 有效载荷的大小（最多 62\n   字节，因为前两个字节已被报头占用）。\n * 分段帧（首帧+连续帧）可容纳最大 4GB 大小的有效载荷。为此，前两个字节应为“1000”，而随后的四个字节则用于指示 ISO-TP 有效载荷的大小。\n\n\n故障排除#\n\n如果您遇到超时问题（例如出现“read socket t: Connection timed out”之类的错误信息），这表明连接不可靠，即以下情况之一：\n\n * ECU A（您的 USB 转 CAN 适配器）将数据从 USB 传输到 CAN 的速度不够快。\n * 您的 PC 通过 USB 发送的数据不正确。\n\n如果问题出在 ECU A 上，其屏幕上应会显示错误信息。\n\n如果您使用的是虚拟机，其 USB 设置可能不够可靠。在 VirtualBox 中，前往“设置”->“USB”，并勾选“USB 3.0 (xHCI)\n控制器”（请确保您的虚拟机已关闭）。\n\n如果仍然失败，请尝试使用 -f 选项与 isotpsend 配合，以强制其降低速度，例如使用“-f 100000”。","routePath":"/docs/userguide/isotp_tutorial","lang":"","toc":[{"text":"ISO-TP 基础","id":"iso-tp-基础","depth":2,"charIndex":279},{"text":"单帧","id":"单帧","depth":3,"charIndex":1045},{"text":"首帧与连续帧","id":"首帧与连续帧","depth":3,"charIndex":1432},{"text":"流量控制帧","id":"流量控制帧","depth":3,"charIndex":1848},{"text":"示例","id":"示例","depth":3,"charIndex":2465},{"text":"Linux 上的 ISO-TP","id":"linux-上的-iso-tp","depth":2,"charIndex":2544},{"text":"candump","id":"candump","depth":3,"charIndex":2901},{"text":"cansend","id":"cansend","depth":3,"charIndex":3179},{"text":"isotpsend","id":"isotpsend","depth":3,"charIndex":3905},{"text":"isotprecv","id":"isotprecv","depth":3,"charIndex":4598},{"text":"isotpdump","id":"isotpdump","depth":3,"charIndex":5215},{"text":"isotpsniffer","id":"isotpsniffer","depth":3,"charIndex":5565},{"text":"isotpperf","id":"isotpperf","depth":3,"charIndex":5677},{"text":"isotpserver","id":"isotpserver","depth":3,"charIndex":5837},{"text":"（略微）高级 ISO-TP 概念","id":"略微高级-iso-tp-概念","depth":2,"charIndex":6245},{"text":"物理寻址与功能寻址","id":"物理寻址与功能寻址","depth":3,"charIndex":6265},{"text":"寻址","id":"寻址","depth":3,"charIndex":6437},{"text":"CAN FD","id":"can-fd","depth":3,"charIndex":6713},{"text":"故障排除","id":"故障排除","depth":3,"charIndex":6953}],"domain":"","frontmatter":{},"version":""},{"id":39,"title":"简介","content":"#\n\n本指南深入介绍了 RAMN 及其使用方法，可用于了解汽车系统，并为参加汽车类夺旗比赛（CTF）等活动做好准备。请先查阅快速入门指南 ,以获得总体概览。\n\n现代汽车网络通常由多个电子控制单元（ECU）组成，这些 ECU 通过各种通信协议连接到一个公共网络，例如控制器局域网（CAN）、带灵活数据速率的 CAN（CAN\nFD）以及本地互连网络（LIN）。RAMN 是一组简单的印刷电路板（PCB），可模拟此类汽车网络，其中四个 ECU 连接到一个公共的 CAN FD\n总线。尽管其复杂程度不及真实车辆，但它可以作为一个平台，帮助用户轻松学习和实验汽车系统。\n\n\nRAMN 硬件#\n\nRAMN 由“主板”和“扩展模块”组成。扩展模块并非严格必需，但有助于实现物理交互。RAMN 包含四个 ECU：ECU A、ECU B、ECU C 和 ECU\nD。每个 ECU 均可通过主板上的 PCB 标识进行识别。\n\n\n\nRAMN 的硬件设计文件已在 GitHub 上提供 。有关硬件的详细信息，请参阅 硬件 部分。\n\n在粗暴操作过程中，点烟器开关和转向电位器的盖子可能会脱落，请务必注意不要丢失。同时也要小心屏幕，它相当脆弱。\n\n\nRAMN 软件#\n\n每个 ECU 的运行均依赖于 STM32L5 微控制器（STM32L552 或 STM32L562）。STM32L552/562 参考手册可在此处获取：\n点击这里 。\n\nRAMN 的源代码同样已在 GitHub 上提供 。有关软件的详细信息，请参阅 固件 部分。\n\n所有 ECU 共用同一套源代码，仅通过预处理器变量来区分各个 ECU（从 TARGET_ECUA 到 TARGET_ECUD，定义于 ramn_config.h\n中）。使用 构建脚本可一次性为所有 ECU 编译源代码，但首先需要安装 STM32CubeIDE。\n\nECU 可以通过三种接口之一进行刷写（参见固件刷写）。STM32 嵌入式引导程序接口速度最快且使用最便捷，仅需通过 USB 连接即可为所有 ECU\n重新刷新固件。\n\n如果您希望对固件进行调试，则需要一个 JTAG 调试器，例如 ST-LINK/V2。\n\n\nECU 功能#\n\nECU A 配备了一个 USB 端口，可作为 USB 转 CAN/CAN FD 适配器（“slcan”适配器）使用。其他 ECU\n则配备传感器和执行器，用作简单的 ECU。因此，通过 USB 将 RAMN 连接到您的计算机，等同于拥有一款 USB 转 CAN 适配器，并将其连接到带有三个\nECU 的车辆的 OBD-II 端口 。\n\nECU B、C 和 D 各自具有一个周期性任务，用于读取物理控制装置的状态，将其状态广播到 CAN 总线上，并更新其输出设备的状态（例如 LCD 屏幕或 LED\n指示灯）。\n\nRAMN 可以通过 CARLA 文件夹 中的脚本连接到驾驶模拟器 CARLA。这使得我们能够观察驾驶模拟器中车辆的行为如何与物理 CAN 总线上不同 ECU\n发送的消息相关联。\n\nECU 支持标准诊断功能，例如可以使用统一诊断服务（UDS）进行访问：\n\n * ECU A 在 ID 0x7e0 处接收请求，并在 0x7e8 处响应。\n\n * ECU B 在 ID 0x7e1 处接收请求，并在 0x7e9 处响应。\n\n * ECU C 在 ID 0x7e2 处接收请求，并在 0x7ea 处响应。\n\n * ECU D 在 ID 0x7e3 处接收请求，并在 0x7eb 处进行响应。\n\n\n分析环境#\n\n您只需通过 USB 为主板供电（无论是否连接扩展设备），即可获得一个可用的 CAN 总线。您可以按照任意指南，使用任何您想要的工具来连接到 CAN\n总线。如果您没有相关工具，可以参考本指南，其中使用了 RAMN 内置的 slcan 适配器（因此您只需要一块 RAMN 板即可）。\n\n要完整地遵循本指南，您需要安装以下工具：\n\n * 一个终端仿真程序，例如 TeraTerm 或 Putty。我们建议您 下载并安装 TeraTerm。这将使您能够直接通过 USB 向 ECU A\n   发送串行命令。\n * 适用于 Windows 的 Python 环境，可在此下载 。请务必勾选“将 Python 添加到环境变量”（或 PATH）。这将使您能够在\n   Windows 上直接执行 RAMN 的 Python 脚本。如果您计划使用 CARLA，请确保使用受支持的版本（参见安装 CARLA)。\n * STM32CubeProgrammer 和 STM32CubeIDE,仅当您需要修改源代码和/或重新刷新 ECU 时才使用。\n * 一台 Linux 虚拟机（或原生系统）。这将使您能够使用诸如 can-utils 等开源工具与 RAMN 的 CAN 总线进行交互，并执行 RAMN\n   的脚本。请按照以下指南进行操作。\n\n\n准备配备 can-utils 的 Linux 机器#\n\nWindows#\n\n在 Windows 系统上，我们建议您安装 VirtualBox 并使用 Linux 发行版镜像。汽车爱好者的一个常见选择是 Kali Linux [ 1 ]。\n\n * 下载并安装 VirtualBox。\n * 下载 Kali Linux 预构建的虚拟机 。\n * 使用 7zip 解压 7z 镜像。\n * 双击 vbox 文件，使用 VirtualBox 打开。如果遇到 USB 问题，请打开“设置”>“USB”，尝试选择 USB 2.0 或 USB\n   3.0（虚拟机必须处于关机状态）。\n * 使用用户名 kali（密码 kali）登录。\n\n从这里开始，您应该能够按照以下 Linux 说明进行操作。\n\n脚注\n\n[ 1 ]：#\n\n如果您无法（或不愿）在虚拟机中运行 Linux 以使用 can-utils 工具，我们建议您学习并使用跨平台的 python-can\n库，它可在所有（Python）平台上运行，包括 Windows。\n\nLinux#\n\n * 打开终端窗口（例如，右键单击桌面并选择“在此处打开终端”）。\n * 输入以下命令以安装 can-utils：\n\n","routePath":"/docs/userguide/ramn_introduction","lang":"","toc":[{"text":"RAMN 硬件","id":"ramn-硬件","depth":2,"charIndex":281},{"text":"RAMN 软件","id":"ramn-软件","depth":2,"charIndex":510},{"text":"ECU 功能","id":"ecu-功能","depth":2,"charIndex":913},{"text":"分析环境","id":"分析环境","depth":2,"charIndex":1471},{"text":"准备配备 can-utils 的 Linux 机器","id":"准备配备-can-utils-的-linux-机器","depth":3,"charIndex":2041},{"text":"Windows","id":"windows","depth":4,"charIndex":2069},{"text":"Linux","id":"linux","depth":4,"charIndex":2499}],"domain":"","frontmatter":{},"version":""},{"id":40,"title":"与 USB 交互","content":"#\n\nRAMN 的 ECU A 配备了一个实现虚拟串行端口功能的 USB 接口。通过标准的 Slcan 命令 ,该串行端口可以将 ECU A 转换为一个 USB 转\nCAN 适配器。这也是本指南中我们之前使用的程序能够通过 RAMN 的 USB 端口读取和接收 CAN 消息的方式。\n\nRAMN 的 USB 端口还实现了多种自定义 RAMN 命令 ,可用于执行 slcan 协议未涵盖的操作，例如禁用特定 ECU 的电源。虽然与 slcan\n兼容的自定义命令使用起来不太方便，但也可以使用一个类似于传统 Linux 界面的命令行界面来替代。\n\n如果您不熟悉串行终端，请注意以下事项：\n\n * 在使用 RAMN 的 slcan 接口时，您需要将“CR”指定为行尾字符。\n * 您必须确保 RAMN 的串口未被任何其他程序（虚拟机或访问 CAN 的程序）占用。\n * 默认情况下，您不应期望任何串行接口支持“退格”字符。如果您在输入命令时出错，则需要从头开始重新输入。RAMN 的命令行界面支持退格功能，以提升用户友好性。\n\n警告\n\n更改 CAN 设置的命令（例如 CAN 滤波器或 CAN 波特率）通常要求您重新打开 CAN 外设（例如使用命令 O）。\n\n\n打开终端#\n\n\nWindows#\n\n在 Windows 上，可以使用诸如 TeraTerm 或 Putty 之类的程序访问串口。本指南中我们使用 TeraTerm。\n\n将 RAMN 连接到您电脑的 USB 端口。打开 TeraTerm，选择“串行”，然后按确定以打开串口。如果您看到多个 COM 端口，请通过插拔 RAMN\n时出现和消失的端口来确定哪个 COM 端口分配给了 RAMN。如果您未看到任何 COM 端口，请确认它当前未被转发到虚拟机。如果您未看到 COM\n端口，而是看到一个“DFU”设备，则意味着您需要先刷写该板（请参阅刷写脚本 ）。\n\n\n\n打开端口后，在顶部菜单栏中选择“设置 -> 终端...”，并更改以下设置：\n\n * 在新行接收选项中选择“CR+LF”。这将确保 slcan 的响应显示在不同的行上。\n * 如果您希望终端同时显示您输入的内容，请勾选“本地回显”。\n\n\n\n此时，您应该能够输入串行命令，并在终端上观察其响应。\n\n\nLinux#\n\n如果您更倾向于使用 Linux，您需要使用一个能够良好处理“CR 换行”设备的终端。我们建议您使用 picocom，可以通过以下命令进行安装：\n\n\n\n通过命令 dmesg 确定您的设备被分配的名称（在插入 RAMN\n板时查找出现的设备）。通常会分配一个类似“dev/ttyACM0”的名称。您可以使用以下命令打开 RAMN 的串口：\n\n\n\n从这里，您应该能够在终端中直接与 RAMN 进行交互。输入 control A 再按 control Q 即可退出界面，返回到正常的 Linux 终端。\n\n\nSlcan 命令#\n\n您可以在原始的 LAWICEL CAN232 手册中找到 slcan 命令列表。RAMN 的实现经过了轻微简化，以更好地容忍用户可能犯的更多错误。部分\nslcan 命令未被实现，或进行了轻微修改，以便更适配 STM32 的 CAN FD 控制器。\n\nSlcan 命令仅使用 ASCII 字符发送；一个字节的原始数据实际上由两个十六进制 ASCII 字符表示 [ 1 ]\n\n成功的 slcan 命令将由可选参数和一个“CR”字符（ASCII 13）响应。失败的 slcan 命令将由一个“BELL”字符（ASCII 7）响应，在\nTeraTerm 中，该字符应伴随错误声音。\n\n\n版本 - “V”#\n\n您可以通过使用 V 命令获取 slcan 适配器的软件版本：\n\n\n\n\n\n\n序列号 - “N”#\n\n同样，您也可以使用 N 命令获取硬件序列号：\n\n\n\n\n\n该数字对应于一个“N”，其后连接了 ECU A 的 STM32 微控制器的 12 字节唯一设备 ID。\n\n\n打开 - “O”#\n\n您可以通过在终端中输入 O（大写字母 o）并按下 ENTER 键，开始将 CAN 消息转发到串行接口。此命令无需任何参数。\n\n\n\n此命令应会显示当前的 CAN 流量，以确认您的电路板工作正常。\n\n\n\n\n关闭 - “C”#\n\n您可以通过使用命令 C 来停止上一条命令产生的流量，该命令会关闭端口，且无需任何参数。\n\n\n\n\n监听 - “L”#\n\nO 命令将 CAN 控制器设置为正常模式，这意味着您也可以发送 CAN 消息。而 L 命令则允许您使用 CAN 控制器的“仅监听”模式，从而禁止您发送 CAN\n消息，并避免无意中影响正在进行的 CAN 流量。\n\n\n\n\n设置波特率（标识符） - “S”#\n\nS 命令允许您更改 CAN 控制器的波特率。更改后，您需要重新打开端口（例如使用 O 或 L 命令）以验证更改是否生效。S\n命令使用一位数字标识符来指定波特率。有关这些标识符的列表，请参阅 CAN 波特率 。\n\n例如，您可以使用此命令并指定波特率标识符 6，该标识符对应 RAMN 的默认波特率 500 kbps：\n\n\n\n请注意，RAMN 默认自动采用 500 kbps 波特率，因此实际上您无需执行此命令。\n\n\n设置波特率（标识符） - “s”#\n\n如果所需的波特率没有对应的标识符，您也可以使用 s 命令来更改波特率。您不能直接指定波特率，而必须为 CAN\n控制器提供位定时参数。有关位定时的工作原理，请参阅位定时 。\n\n您必须为该函数提供两个字节：TSEG1 和 TSEG2，假设时钟频率为 40 MHz。例如，要直接设置 500 kbps 的波特率，您可以使用以下命令：\n\n\n\n这将根据位定时中的示例，将 TSEG1 设置为 0x3C（60），TSEG2 设置为 0x13（19）。\n\n\n发送 - “t” 和 “T”#\n\n您可以使用 t 发送带有标准标识符的 CAN 帧，使用 T 发送带有扩展标识符的 CAN 帧。您必须按顺序提供 CAN ID、DLC 和有效载荷。\n\n对于标准标识符，您必须提供 3 位数字；对于扩展标识符，则需提供 8 位数字。位数是固定的，因此如有必要，您必须用零进行填充。DLC 仅为一位 。有效载荷紧随\nDLC 之后，以十六进制形式表示。\n\n例如，您可以使用以下命令发送一个具有标准标识符 0x024、DLC 为 2 以及二进制数据“0x11 0xFF”的 CAN 帧：\n\n\n\n要传输带有扩展标识符的 CAN 帧，请改用“T”命令：\n\n\n\n请注意，没有“接收”命令：当 CAN 适配器接收到 CAN 消息时，它会通过 t 和 T 命令将其转发到 USB 串行接口，但此时您是在接收而非发送这些消息。\n\n\n发送 RTR - “r” 和 “R”#\n\n命令 r 和 R 的使用方式与 t 和 T 类似，但分别用于 RTR 命令的标准标识符和扩展标识符。您不应为此命令提供有效载荷，但仍需提供一位数的 DLC。\n\n例如，要发送一个带有标准标识符 0x701 且 DLC 为 8 的 RTR 请求：\n\n\n\n而要使用扩展标识符发送相同的帧：\n\n\n\n如果您不加过滤器直接输入此命令，将很难观察到 ECU B 的响应。\n\n\n设置过滤器 - “m”和“M”#\n\n硬件滤波器可使用 M 和 m 命令进行设置：M 用于选择数值，m 用于选择掩码。有关 CAN 滤波器的默认工作原理，请参阅 CAN 过滤器 。\n\n该格式与原始规范中的格式略有不同。 滤波器对标准标识符和扩展标识符独立生效。\n\n如果要为标准标识符应用滤波器，请使用三位参数；对于扩展标识符，则使用八位参数。\n\n例如，要应用滤波器值“701”和掩码“7ff”（仅接收 ID 0x701），请使用：\n\n\n\n然而，这将无法让您过滤扩展标识符。如果您还希望接收具有扩展标识符的相同 ID，则还需要为扩展标识符设置相同的过滤器：\n\n\n\n您需要通过再次打开 CAN 外设来应用此过滤器（例如：O 或 L）。应用此过滤器后，您应该能够发送一个 RTR 帧，并直接在终端中观察到响应：\n\n\n\n最后一个命令应由终端接收，而非由您自行发送。\n\n警告\n\n软件工具（例如 candump）通常对 slcan 帧使用软件滤波器，而非硬件滤波器。如果在硬件中应用了滤波器，它可能会一直保留到下次重置，并且可能无法被\nCAN 软件工具中的滤波器设置所覆盖。\n\n\n筛选类型 - “W”#\n\nRAMN 默认使用在 CAN 过滤器中说明的“值与掩码”过滤器。您可以使用稍作修改的命令“W”，以指定不同的过滤器类型。\n\n * W0 使用 STM32 的“范围”过滤器类型，该类型可指定您希望接收的一系列 ID。\n * W1 使用 STM32 的“双”过滤器类型，该类型可指定您希望接收的两个 ID。\n * W2 使用“值与掩码”过滤器（默认，当提供无效参数时也使用此过滤器）。\n * W3 使用 STM32 的“无 EIDM 范围”过滤器类型。\n\n使用“M”命令为过滤器提供第一个参数，使用“m”命令提供第二个参数。\n\n例如，使用“W0”可直接指定您希望接收的 ID 范围。如果您想接收从 0x700 到 0x703 的 ID，可以使用：\n\n\n\n这种方式比等效的“值与掩码”方式更具可读性。同样，这仅适用于标准标识符，因此您还必须同时使用 m00000700 和 M00000703 来接收扩展标识符。\n\n\n读取状态 - “F”#\n\n此命令返回一个字节（以两个十六进制字符表示），用于报告 CAN 控制器的状态。各比特位的含义请参阅 CAN232 数据手册\n（F[CR]命令）。“仲裁丢失”标志不受支持。\n\n此命令是为了与 slcan 兼容而实现的，但建议您改用自定义命令“E”直接读取 STM32 控制器标志。\n\n\n启用时间戳 - “Z”#\n\n您可以通过 Z1 启用时间戳，通过 Z0 将其禁用。时间戳以 2 字节值（四位数字）的形式附加在每帧末尾，每毫秒递增一次，并在\n0xEA60（60000）处溢出。请注意，这些实际上并非真正的“CAN 硬件”时间戳，而是使用 freeRTOS 定时器实现的软件时间戳。\n\n\n\n\n不支持的命令#\n\nRAMN 不支持以下 slcan 命令：“X”、“U”、“P”、“A”、“Q”。不过，这不应妨碍您将 RAMN 与大多数工具（例如 slcand）一起使用。\n\n\n自定义 RAMN 命令#\n\n\n读取错误标志 - E#\n\n此命令会转储 STM32 的 CAN FD 控制器所有可能的 CAN 错误以及 CAN 协议状态寄存器。有关每个位的含义，请参阅 ramn_debug.c 中的\nRAMN_DEBUG_DumpCANErrorRegisters 。\n\n\n读取 FIFO 状态 - q#\n\n此命令会转储所有可能的 FIFO 状态变量。有关每个位的含义，请参阅 main.c 中的 reportFIFOStatus_USB。\n\n\n读取 CAN 统计信息 - I#\n\n此命令会转储 CAN 统计信息，例如接收和发送的消息数量。有关每个位的含义，请参阅 ramn_debug.c 中的\nRAMN_DEBUG_ReportCANStats。\n\n\n使用预分频器设置位定时 - k#\n\n此命令可用于通过 2 字节预分频器设置标称位定时。其格式为 kxxxxyyzz,其中 xxxx 为预分频器，yy 为 TSEG1，zz 为\nTSEG2。例如，要设置 500 kbps 的波特率，可以不使用 TSEG1 = 69 和 TSEG2 = 20，而是使用预分频器 2，并将 TSEG1 设置为\n30（0x1E），TSEG2 设置为 9（0x9）：\n\n\n\n\n设置同步跳转宽度 - G#\n\n此命令允许您设置 CAN FD 控制器的同步跳转宽度 (SJW) 参数。您可以使用 Gxx 仅提供标称 SJW（xx），或使用 Gxxyy 同时提供标称\nSJW（xx）和数据 SJW（yy）。\n\n例如，使用以下命令将标称 SJW 设置为 10（0x0A）：\n\n\n\n例如，你可以观察到使用较大的 SJW 能够让你容忍更多的时序误差。比如，如果你输入：\n\n\n\n如果将波特率错误地设置为 506.3 kbps，同时将 SJW 值设为较小的 1，则不会观察到任何报文，只会出现 CAN\n错误。然而，如果你重新复位板卡，并将波特率设置为 506.3 kbps，同时将 SJW 值设为较大的 16，你应该能够无误地观察到 RAMN 的 500\nkbps 流量：\n\n\n\n\n启用自动重传 - a#\n\na 命令可用于启用 CAN 消息的自动重传功能。启用后，如果 ECU A 未能成功发送某条消息，则会自动进行重传。使用 a0 可将其禁用，而使用 a1\n则可将其启用。\n\n\n以受限模式打开 - l#\n\nl 命令（小写 l）可用于以“受限操作”模式启动 CAN 外设，在此模式下，外设能够确认 CAN\n帧，但无法发送帧或错误/过载帧。这与仅监听模式（L)不同，因为该模式确实会确认 CAN 帧。\n\n\n自定义 CAN FD 命令#\n\n以下自定义命令可用于在 RAMN 的 ECU A 上使用 CAN FD。请注意，这些设置仅适用于 ECU A，不适用于其他 ECU。有关 CAN FD\n的更多信息，请参阅 CAN FD。\n\n\n帧模式 - f#\n\n使用 f 来选择以何种模式打开 FD CAN 外设：\n\n * f0 用于经典 CAN 模式\n * f1 用于无比特率切换的 CAN FD 模式\n * f2 用于带比特率切换的 CAN FD 模式\n\n\n启用 ISO 模式 - i#\n\n使用 i0 在非 ISO CAN FD 模式下设置外设，使用 i1 在 ISO CAN FD 模式下设置外设。\n\n设置数据位时序 - K#\n\n使用 Kxxyyzz 将 xx 设置为预分频器，yy 设置为 TSEG1，zz 设置为 TSEG2。请注意，对于此命令，预分频器仅为一个字节。\n\n例如，要使用 2 Mbps 的数据波特率，请使用：\n\n\n\n\n发送不含 BRS 的 CAN FD 帧 - 0#\n\n以 0 开始一帧，以指定您希望以不含 BRS 的 CAN FD 方式执行剩余的命令。例如，使用以下命令发送一个不含比特率切换的 CAN FD 帧 ,其 CAN\nID 为 0x24，DLC 为 2，有效载荷为 0x01FF。\n\n\n\n您还可以对 r、t 和 T 命令使用相同的前缀。\n\n\n发送带有 BRS 的 CAN FD 帧 - 1#\n\n同样，以 1 开始一个帧，以指定您希望将命令的剩余部分作为带有 BRS 的 CAN FD 来执行。例如，使用以下命令发送一个带有比特率切换的 CAN FD 帧\n,CAN ID 为 0x24，DLC 为 2，有效载荷为 0x01FF。\n\n\n\n您还可以为 r、t 和 T 命令使用相同的前缀。\n\n\n包含 ESI 位 - v#\n\n使用 v0 和 v1 来启用或禁用在设置了“ESI”标志为“PASSIVE”的 CAN FD 帧末尾添加“i”字符。\n\n\n自定义 ECU 控制命令#\n\n\n显示帮助 - H#\n\n此命令会返回 RAMN 文档的链接。也可以通过 h 和 ? 调用。 %%\n\n\n获取随机字节 - j#\n\n此命令从 ECU A 的真随机数生成器中返回一个随机的字节 。\n\n\n获取随机整数 - J#\n\n此命令从 ECU A 的真随机数生成器中返回一个随机的整数 。\n\n\n启用调试日志 - d#\n\n此命令可启用调试日志：错误将以人类可读的方式显示。输入 d1 以启用调试日志，输入 d0 以禁用调试日志。\n\n\n错误时转储状态 - @#\n\n命令 @1 将在检测到错误时自动转储 CAN FIFO 状态和 CAN 错误状态寄存器。可通过 @0 将其禁用。\n\n\n以 DFU 模式重启 - D#\n\n此命令可用于在 DFU 模式下重启微控制器，以便通过 USB 重新刷新固件（详情请参阅 STM32 嵌入式引导程序接口 ）。请使用 DzZ 来执行该命令。\n\n\n启动 ECU 引导程序 - p#\n\n此命令可用于将 ECU B、C 或 D 重启至引导程序模式，以便通过 CAN FD 对其进行重新刷写（从 ECU A 的 USB 进行；详情请参阅 STM32\n嵌入式引导加载程序接口）。使用 pB 可将 ECU B 启动至引导程序模式，pC 用于 ECU C，pD 用于 ECU D。\n\n\n复位 - n#\n\n命令 n 将对所有 ECU 执行复位操作。\n\n\n启用电源 - y#\n\n此命令可用于分别独立地启用或禁用 ECU B、C 和 D 的电源。其格式为 yxz,其中 x 为 ECU 名称，z 为电源状态（0 或\n1）。例如，输入以下命令可禁用 ECU D 的电源。\n\n\n\n您应该能够看到 LED 指示灯熄灭。输入以下命令可再次启用 ECU D 的电源：\n\n\n\n\n启用所有电源 - Y#\n\n此命令与之前的命令类似，但几乎同时应用于 ECU B、C 和 D。使用 Y0 可禁用所有这些 ECU 的电源，而使用 Y1 则可重新启用它们。\n\n\n发送 UDS 消息 - %#\n\n命令 % 可用于通过 USB 向 ECU A 发送 UDS 消息，而无需使用 CAN。只需以十六进制字符串形式提供大小和 UDS\n有效载荷即可。其中，大小应首先以三位数字的形式给出。例如，使用以下命令发送一个“测试器存在”UDS 命令（2 字节有效载荷）“3E00”：\n\n\n\n\n\n\n进入命令行界面 -#\n\n输入 # 以进入更友好的命令行界面。与直接的 slcan 串口界面不同，它支持退格字符，并提供更具可读性的命令名称。\n\n\n退出命令行界面 - b#\n\n命令 b 可用于退出命令行界面\n\n\n显示 freeRTOS 统计信息 - X#\n\n命令 X 可用于显示 FreeRTOS 运行时统计信息，包括 CPU 使用率和堆栈使用情况。请注意，统计信息从启动时开始计算且不会被重置（因此，CPU\n使用率仅表示自启动以来的整体平均值）。\n\n\n内部命令#\n\n以下命令由 RAMN 的脚本在内部使用：\n\n * c 命令（使用 c0 启用或 c1 禁用）用于将设备激活为“CARLA”模式，在此模式下，设备会通过串行数据包定期向驾驶模拟器更新 CAN 总线状态。\n\n * u 命令是一个更新命令，用于同步驾驶模拟器与 RAMN 板。\n\n * w 命令用于在不打开 slcan 端口的情况下应用新的 CAN 外设设置。\n\n\n命令行界面#\n\nRAMN 的命令行界面 (CLI) 提供了与通过 CAN 接口相同的自定义功能，但以更加友好的方式呈现。只需输入 # 自定义 slcan\n命令即可打开它。然后，您可以输入常规命令，例如“help”以显示帮助页面。\n\n例如，您可以输入 play 1 来启动一个 Chip-8 游戏，或者输入 theme 3 将屏幕主题更改为主题编号\n3。如果您输入了无效的命令，系统将显示一条易于理解的错误信息，而不仅仅是发出“BELL”提示音。\n\n\n\n脚注\n\n[ 1 ]：#\n\n例如，要发送“7F”来表示字节 0x7F，实际上是在二进制数据中发送 ASCII 字符 0x37（“7”）和 0x46（“F”）。","routePath":"/docs/userguide/usb_tutorial","lang":"","toc":[{"text":"打开终端","id":"打开终端","depth":2,"charIndex":527},{"text":"Windows","id":"windows","depth":3,"charIndex":535},{"text":"Linux","id":"linux","depth":3,"charIndex":954},{"text":"Slcan 命令","id":"slcan-命令","depth":2,"charIndex":1211},{"text":"版本 - “V”","id":"版本---v","depth":3,"charIndex":1511},{"text":"序列号 - “N”","id":"序列号---n","depth":3,"charIndex":1559},{"text":"打开 - “O”","id":"打开---o","depth":3,"charIndex":1653},{"text":"关闭 - “C”","id":"关闭---c","depth":3,"charIndex":1765},{"text":"监听 - “L”","id":"监听---l","depth":3,"charIndex":1824},{"text":"设置波特率（标识符） - “S”","id":"设置波特率标识符---s","depth":3,"charIndex":1944},{"text":"设置波特率（标识符） - “s”","id":"设置波特率标识符---s-1","depth":3,"charIndex":-1},{"text":"发送 - “t” 和 “T”","id":"发送---t-和-t","depth":3,"charIndex":2411},{"text":"发送 RTR - “r” 和 “R”","id":"发送-rtr---r-和-r","depth":3,"charIndex":2783},{"text":"设置过滤器 - “m”和“M”","id":"设置过滤器---m和m","depth":3,"charIndex":2985},{"text":"筛选类型 - “W”","id":"筛选类型---w","depth":3,"charIndex":3468},{"text":"读取状态 - “F”","id":"读取状态---f","depth":3,"charIndex":3887},{"text":"启用时间戳 - “Z”","id":"启用时间戳---z","depth":3,"charIndex":4042},{"text":"不支持的命令","id":"不支持的命令","depth":3,"charIndex":4194},{"text":"自定义 RAMN 命令","id":"自定义-ramn-命令","depth":2,"charIndex":4284},{"text":"读取错误标志 - E","id":"读取错误标志---e","depth":3,"charIndex":4299},{"text":"读取 FIFO 状态 - q","id":"读取-fifo-状态---q","depth":3,"charIndex":4430},{"text":"读取 CAN 统计信息 - I","id":"读取-can-统计信息---i","depth":3,"charIndex":4516},{"text":"使用预分频器设置位定时 - k","id":"使用预分频器设置位定时---k","depth":3,"charIndex":4621},{"text":"设置同步跳转宽度 - G","id":"设置同步跳转宽度---g","depth":3,"charIndex":4821},{"text":"启用自动重传 - a","id":"启用自动重传---a","depth":3,"charIndex":5165},{"text":"以受限模式打开 - l","id":"以受限模式打开---l","depth":3,"charIndex":5264},{"text":"自定义 CAN FD 命令","id":"自定义-can-fd-命令","depth":2,"charIndex":5376},{"text":"帧模式 - f","id":"帧模式---f","depth":3,"charIndex":5488},{"text":"启用 ISO 模式 - i","id":"启用-iso-模式---i","depth":3,"charIndex":5598},{"text":"设置数据位时序 - K","id":"设置数据位时序---k","depth":4,"charIndex":5671},{"text":"发送不含 BRS 的 CAN FD 帧 - 0","id":"发送不含-brs-的-can-fd-帧---0","depth":3,"charIndex":5788},{"text":"发送带有 BRS 的 CAN FD 帧 - 1","id":"发送带有-brs-的-can-fd-帧---1","depth":3,"charIndex":-1},{"text":"包含 ESI 位 - v","id":"包含-esi-位---v","depth":3,"charIndex":6129},{"text":"自定义 ECU 控制命令","id":"自定义-ecu-控制命令","depth":2,"charIndex":6205},{"text":"显示帮助 - H","id":"显示帮助---h","depth":3,"charIndex":6221},{"text":"获取随机字节 - j","id":"获取随机字节---j","depth":3,"charIndex":6271},{"text":"获取随机整数 - J","id":"获取随机整数---j","depth":3,"charIndex":6318},{"text":"启用调试日志 - d","id":"启用调试日志---d","depth":3,"charIndex":6365},{"text":"错误时转储状态 - @","id":"错误时转储状态---","depth":3,"charIndex":6434},{"text":"以 DFU 模式重启 - D","id":"以-dfu-模式重启---d","depth":3,"charIndex":6507},{"text":"启动 ECU 引导程序 - p","id":"启动-ecu-引导程序---p","depth":3,"charIndex":6604},{"text":"复位 - n","id":"复位---n","depth":3,"charIndex":6767},{"text":"启用电源 - y","id":"启用电源---y","depth":3,"charIndex":6800},{"text":"启用所有电源 - Y","id":"启用所有电源---y","depth":3,"charIndex":6954},{"text":"发送 UDS 消息 - %","id":"发送-uds-消息---","depth":3,"charIndex":7041},{"text":"进入命令行界面 -","id":"进入命令行界面--","depth":3,"charIndex":7198},{"text":"退出命令行界面 - b","id":"退出命令行界面---b","depth":3,"charIndex":7271},{"text":"显示 freeRTOS 统计信息 - X","id":"显示-freertos-统计信息---x","depth":3,"charIndex":7303},{"text":"内部命令","id":"内部命令","depth":3,"charIndex":7424},{"text":"命令行界面","id":"命令行界面","depth":2,"charIndex":7611}],"domain":"","frontmatter":{},"version":""}]